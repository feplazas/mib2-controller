# MIB2 CONTROLLER - C√ìDIGO TYPESCRIPT CONSOLIDADO
# Generado: 2026-01-14 09:47:55
# Prop√≥sito: Revisi√≥n por IA externa


================================================================================
FILE: app/(tabs)/_layout.tsx
================================================================================

import { Tabs } from "expo-router";
import { useSafeAreaInsets } from "react-native-safe-area-context";

import { HapticTab } from "@/components/haptic-tab";
import { IconSymbol } from "@/components/ui/icon-symbol";
import { Platform } from "react-native";
import { useColors } from "@/hooks/use-colors";

export default function TabLayout() {
  const colors = useColors();
  const insets = useSafeAreaInsets();
  const bottomPadding = Platform.OS === "web" ? 12 : Math.max(insets.bottom, 8);
  const tabBarHeight = 64 + bottomPadding;

  return (
    <Tabs
      screenOptions={{
        tabBarActiveTintColor: colors.primary,
        headerShown: false,
        tabBarButton: HapticTab,
        tabBarStyle: {
          paddingTop: 12,
          paddingBottom: bottomPadding,
          height: tabBarHeight,
          backgroundColor: colors.background,
          borderTopColor: colors.border,
          borderTopWidth: 0.5,
        },
        tabBarLabelStyle: {
          fontSize: 11,
          fontWeight: '600',
        },
        tabBarIconStyle: {
          marginTop: 4,
        },
      }}
    >
      <Tabs.Screen
        name="index"
        options={{
          title: "Home",
          tabBarIcon: ({ color }) => <IconSymbol size={24} name="house.fill" color={color} />,
        }}
      />
      <Tabs.Screen
        name="usb-status"
        options={{
          title: "USB",
          tabBarIcon: ({ color}) => <IconSymbol size={24} name="antenna.radiowaves.left.and.right" color={color} />,
        }}
      />
      <Tabs.Screen
        name="auto-spoof"
        options={{
          title: "Spoof",
          tabBarIcon: ({ color }) => <IconSymbol size={24} name="bolt.fill" color={color} />,
        }}
      />
      <Tabs.Screen
        name="commands"
        options={{
          title: "Telnet",
          tabBarIcon: ({ color }) => (
            <IconSymbol size={24} name="chevron.left.forwardslash.chevron.right" color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="toolbox"
        options={{
          title: "Toolbox",
          tabBarIcon: ({ color }) => <IconSymbol size={24} name="wrench.fill" color={color} />,
        }}
      />
      <Tabs.Screen
        name="recovery"
        options={{
          title: "Recovery",
          tabBarIcon: ({ color }) => <IconSymbol size={24} name="bandage.fill" color={color} />,
        }}
      />
      <Tabs.Screen
        name="diag"
        options={{
          title: "Diag",
          tabBarIcon: ({ color }) => <IconSymbol size={24} name="chart.bar.fill" color={color} />,
        }}
      />
      <Tabs.Screen
        name="fec"
        options={{
          title: "FEC",
          tabBarIcon: ({ color }) => <IconSymbol size={24} name="key.fill" color={color} />,
        }}
      />
      <Tabs.Screen
        name="settings"
        options={{
          title: "Config",
          tabBarIcon: ({ color }) => <IconSymbol size={24} name="gear" color={color} />,
        }}
      />
      
      {/* Hidden tabs - accessible via navigation but not shown in tab bar */}
      <Tabs.Screen
        name="tools"
        options={{
          href: null,
        }}
      />
    </Tabs>
  );
}

================================================================================
FILE: app/(tabs)/auto-spoof.tsx
================================================================================

import { View, Text, ScrollView, TouchableOpacity, Alert } from 'react-native';
import { useState , useRef } from 'react';
import { ScreenContainer } from '@/components/screen-container';
import { useUsbStatus } from '@/lib/usb-status-context';
import { usbService } from '@/lib/usb-service';
import { backupService } from '@/lib/backup-service';
import { ChipsetStatusBadge } from '@/components/chipset-status-badge';
import { getChipsetCompatibility, canAttemptSpoofing, getCompatibilityMessage } from '@/lib/chipset-compatibility';
import { SuccessResultModal } from '@/components/success-result-modal';
import { EepromProgressIndicator } from '@/components/eeprom-progress-indicator';
import * as Haptics from 'expo-haptics';
import * as Sharing from 'expo-sharing';

type SpoofStep = 'idle' | 'validating' | 'creating_backup' | 'writing_vid_low' | 'writing_vid_high' | 'writing_pid_low' | 'writing_pid_high' | 'verifying' | 'success' | 'error';

export default function AutoSpoofScreen() {
  const { status, device } = useUsbStatus();
  const [isExecuting, setIsExecuting] = useState(false);
  const [currentStep, setCurrentStep] = useState<SpoofStep>('idle');
  const [errorMessage, setErrorMessage] = useState('');
  const [successMessage, setSuccessMessage] = useState('');
  const [eepromProgress, setEepromProgress] = useState(0);
  const [eepromBytesProcessed, setEepromBytesProcessed] = useState(0);
  const [eepromTotalBytes, setEepromTotalBytes] = useState(0);
  const [eepromOperation, setEepromOperation] = useState<'read' | 'write'>('read');
  const [showSuccessModal, setShowSuccessModal] = useState(false);
  const [spoofingResult, setSpoofingResult] = useState<{
    originalVID: string;
    originalPID: string;
    newVID: string;
    newPID: string;
    chipset: string;
    deviceName: string;
    timestamp: Date;
  } | null>(null);

  const [isTesting, setIsTesting] = useState(false);
  const [testResult, setTestResult] = useState<'success' | 'fail' | null>(null);
  const [skipVerification, setSkipVerification] = useState(false);

  const getStepText = (step: SpoofStep): string => {
    switch (step) {
      case 'idle':
        return 'Listo para iniciar';
      case 'validating':
        return 'Validando compatibilidad del chipset...';
      case 'creating_backup':
        return 'Creando backup de seguridad de EEPROM...';
      case 'writing_vid_low':
        return 'Escribiendo VID byte bajo (0x88)...';
      case 'writing_vid_high':
        return 'Escribiendo VID byte alto (0x89)...';
      case 'writing_pid_low':
        return 'Escribiendo PID byte bajo (0x8A)...';
      case 'writing_pid_high':
        return 'Escribiendo PID byte alto (0x8B)...';
      case 'verifying':
        return 'Verificando escritura...';
      case 'success':
        return '‚úÖ Spoofing completado exitosamente';
      case 'error':
        return '‚ùå Error durante el spoofing';
      default:
        return '';
    }
  };

  const getStepIcon = (step: SpoofStep): string => {
    if (currentStep === step && isExecuting) return '‚è≥';
    if (currentStep === 'success' && ['validating', 'creating_backup', 'writing_vid_low', 'writing_vid_high', 'writing_pid_low', 'writing_pid_high', 'verifying'].includes(step)) return '‚úÖ';
    if (currentStep === 'error') return '‚ùå';
    return '‚ö™';
  };

  const executeAutoSpoof = async () => {
    if (!device) {
      Alert.alert('Error', 'No hay dispositivo USB conectado');
      return;
    }

    const compatibility = getChipsetCompatibility(device.chipset || '');
    
    if (!canAttemptSpoofing(compatibility)) {
      Alert.alert(
        'Dispositivo No Compatible',
        getCompatibilityMessage(compatibility, device.chipset || 'desconocido')
      );
      return;
    }
    
    // DETECCI√ìN REAL de EEPROM vs eFuse
    Alert.alert(
      'üîç Detectando Tipo de EEPROM',
      'Se realizar√° una prueba REAL de escritura en un offset seguro para determinar si el chipset tiene EEPROM externa modificable o eFuse bloqueado.\n\nEsto NO modificar√° el VID/PID actual.',
      [
        { text: 'Cancelar', style: 'cancel' },
        { text: 'Detectar Ahora', onPress: async () => {
          try {
            await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
            
            // Realizar detecci√≥n REAL
            const eepromType = await usbService.detectEEPROMType();
            
            if (!eepromType.writable) {
              // eFuse detectado - BLOQUEAR spoofing
              await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
              Alert.alert(
                '‚ùå Spoofing Bloqueado',
                `Tipo detectado: ${eepromType.type.toUpperCase()}\n\n` +
                `Raz√≥n: ${eepromType.reason}\n\n` +
                `‚ö†Ô∏è Este chipset NO puede ser modificado de forma segura. El spoofing ha sido BLOQUEADO para prevenir bricking del adaptador.`,
                [{ text: 'Entendido' }]
              );
              return;
            }
            
            // EEPROM externa detectada - PERMITIR spoofing
            await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
            Alert.alert(
              '‚úÖ EEPROM Externa Detectada',
              `Tipo: ${eepromType.type.toUpperCase()}\n` +
              `Estado: MODIFICABLE\n\n` +
              `‚úÖ El chipset tiene EEPROM externa y puede ser modificado de forma segura.\n\n` +
              `¬øDeseas continuar con el spoofing?`,
              [
                { text: 'Cancelar', style: 'cancel' },
                { text: 'S√≠, Continuar', onPress: () => proceedWithSpoofing() }
              ]
            );
          } catch (error) {
            await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
            Alert.alert(
              '‚ùå Error de Detecci√≥n',
              `No se pudo detectar el tipo de EEPROM:\n\n${error}\n\n` +
              `Por seguridad, el spoofing ha sido BLOQUEADO.`
            );
          }
        }}
      ]
    );
    return;
    
    proceedWithSpoofing();
  };
  
  const proceedWithSpoofing = () => {

    if (!device) return;
    
    // Validaci√≥n adicional: Verificar que el dispositivo a√∫n est√° conectado
    if (status !== 'connected') {
      Alert.alert('Error', 'El dispositivo USB se desconect√≥. Por favor reconecta y vuelve a intentar.');
      return;
    }

    // Validaci√≥n: Advertir sobre cable OTG y alimentaci√≥n
    Alert.alert(
      'üîå Verificaci√≥n de Requisitos',
      '‚úÖ ANTES DE CONTINUAR, VERIFICA:\n\n' +
      '1. Cable OTG conectado correctamente\n' +
      '2. Adaptador USB enchufado firmemente\n' +
      '3. Bater√≠a del tel√©fono >20%\n' +
      '4. NO desconectar√°s el adaptador durante el proceso\n\n' +
      '‚ö†Ô∏è Desconectar durante la escritura puede INUTILIZAR el adaptador permanentemente.\n\n' +
      '¬øTodos los requisitos est√°n cumplidos?',
      [
        { text: 'Cancelar', style: 'cancel' },
        {
          text: 'S√≠, Continuar',
          onPress: () => showCriticalWarning(),
        },
      ]
    );
  };

  const showCriticalWarning = () => {
    // Confirmaci√≥n con advertencias
    Alert.alert(
      '‚ö†Ô∏è Advertencia Cr√≠tica',
      'Esta operaci√≥n modificar√° permanentemente la EEPROM del adaptador USB.\n\n' +
      '‚ö†Ô∏è RIESGOS:\n' +
      '‚Ä¢ Puede inutilizar el dispositivo ("bricking")\n' +
      '‚Ä¢ No se puede deshacer f√°cilmente\n' +
      '‚Ä¢ Requiere reconexi√≥n f√≠sica del adaptador\n\n' +
      '‚úÖ REQUISITOS:\n' +
      '‚Ä¢ Adaptador ASIX AX88772A o AX88772B\n' +
      '‚Ä¢ EEPROM externa (NO eFuse)\n' +
      '‚Ä¢ Alimentaci√≥n estable durante el proceso\n\n' +
      '¬øDeseas continuar?',
      [
        { text: 'Cancelar', style: 'cancel' },
        {
          text: 'Continuar',
          style: 'destructive',
          onPress: () => showFinalConfirmation(),
        },
      ]
    );
  };

  const showFinalConfirmation = () => {
    Alert.alert(
      '‚ö†Ô∏è Confirmaci√≥n Final',
      '√öLTIMA OPORTUNIDAD PARA CANCELAR\n\n' +
      'üìã Resumen de cambios:\n' +
      `‚Ä¢ VID actual: ${usbService.formatVIDPID(device!.vendorId, device!.productId)}\n` +
      '‚Ä¢ VID nuevo: 0x2001 (D-Link)\n' +
      '‚Ä¢ PID nuevo: 0x3C05 (DUB-E100)\n\n' +
      '‚úÖ Se crear√° un backup autom√°tico antes de escribir\n\n' +
      '‚ö†Ô∏è NO TOQUES EL ADAPTADOR DURANTE EL PROCESO\n\n' +
      '¬øEjecutar spoofing AHORA?',
      [
        { text: 'NO, Cancelar', style: 'cancel' },
        {
          text: 'S√ç, Ejecutar',
          style: 'destructive',
          onPress: () => performSpoof(),
        },
      ]
    );
  };

  const performSpoof = async () => {
    if (!device) return;

    setIsExecuting(true);
    setErrorMessage('');
    setSuccessMessage('');
    setCurrentStep('validating');

    try {
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);

      // Paso 1: Validar compatibilidad
      const compatibility = getChipsetCompatibility(device.chipset || '');
      if (!canAttemptSpoofing(compatibility)) {
        throw new Error('Dispositivo no compatible para spoofing');
      }
      await new Promise(resolve => setTimeout(resolve, 500));

      // Paso 2: Crear backup autom√°tico
      setCurrentStep('creating_backup');
      setEepromOperation('read');
      setEepromTotalBytes(256); // EEPROM t√≠pica de 256 bytes
      
      // Simular progreso de lectura de backup
      for (let i = 0; i <= 100; i += 10) {
        setEepromProgress(i);
        setEepromBytesProcessed(Math.floor((i / 100) * 256));
        await new Promise(resolve => setTimeout(resolve, 50));
      }
      
      await backupService.createBackup(device);
      await new Promise(resolve => setTimeout(resolve, 200));

      // Resetear progreso para escritura
      setEepromOperation('write');
      setEepromProgress(0);
      setEepromBytesProcessed(0);
      setEepromTotalBytes(4); // 4 bytes a escribir (VID low, VID high, PID low, PID high)
      
      // Paso 3: Escribir VID byte bajo (0x88 = 0x01)
      setCurrentStep('writing_vid_low');
      setEepromProgress(25);
      setEepromBytesProcessed(1);
      await usbService.writeEEPROM(0x88, '01', skipVerification);
      await new Promise(resolve => setTimeout(resolve, 100));

      // Paso 4: Escribir VID byte alto (0x89 = 0x20)
      setCurrentStep('writing_vid_high');
      setEepromProgress(50);
      setEepromBytesProcessed(2);
      await usbService.writeEEPROM(0x89, '20', skipVerification);
      await new Promise(resolve => setTimeout(resolve, 100));

      // Paso 5: Escribir PID byte bajo (0x8A = 0x05)
      setCurrentStep('writing_pid_low');
      setEepromProgress(75);
      setEepromBytesProcessed(3);
      await usbService.writeEEPROM(0x8A, '05', skipVerification);
      await new Promise(resolve => setTimeout(resolve, 100));

      // Paso 6: Escribir PID byte alto (0x8B = 0x3C)
      setCurrentStep('writing_pid_high');
      setEepromProgress(100);
      setEepromBytesProcessed(4);
      await usbService.writeEEPROM(0x8B, '3C', skipVerification);
      await new Promise(resolve => setTimeout(resolve, 100));

      // Paso 7: Verificar escritura
      setCurrentStep('verifying');
      const vidLow = await usbService.readEEPROM(0x88, 1);
      const vidHigh = await usbService.readEEPROM(0x89, 1);
      const pidLow = await usbService.readEEPROM(0x8A, 1);
      const pidHigh = await usbService.readEEPROM(0x8B, 1);

      if (vidLow.data !== '01' || vidHigh.data !== '20' || pidLow.data !== '05' || pidHigh.data !== '3C') {
        throw new Error('Verificaci√≥n fall√≥: Los datos escritos no coinciden');
      }

      // √âxito
      setCurrentStep('success');
      
      // Capturar resultado para modal
      setSpoofingResult({
        originalVID: usbService.formatVIDPID(device.vendorId, 0).split(':')[0],
        originalPID: usbService.formatVIDPID(0, device.productId).split(':')[1],
        newVID: '0x2001',
        newPID: '0x3C05',
        chipset: device.chipset || 'Desconocido',
        deviceName: device.deviceName,
        timestamp: new Date(),
      });
      
      const verificationNote = skipVerification 
        ? '\n‚ö†Ô∏è IMPORTANTE: Verificaci√≥n omitida. Debes reconectar el adaptador para confirmar que el spoofing fue exitoso.\n'
        : '';
      
      setSuccessMessage(
        'Spoofing completado exitosamente.\n\n' +
        'üìã Valores escritos:\n' +
        '‚Ä¢ VID: 0x2001 (D-Link)\n' +
        '‚Ä¢ PID: 0x3C05 (DUB-E100)\n' +
        verificationNote +
        '\nüîå PASOS OBLIGATORIOS:\n' +
        '1Ô∏è‚É£ Desconecta el adaptador USB del cable OTG\n' +
        '2Ô∏è‚É£ Espera 5-10 segundos (importante)\n' +
        '3Ô∏è‚É£ Vuelve a conectar el adaptador\n' +
        '4Ô∏è‚É£ Ve a "Estado USB" para verificar VID/PID\n' +
        '5Ô∏è‚É£ Si no cambi√≥, usa "Test de Spoofing" para diagn√≥stico\n\n' +
        'üì° Si el VID/PID no cambia despu√©s de reconectar, ve a la pesta√±a "Diag" para ver logs detallados de la operaci√≥n.'
      );
      
      await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
      
      // Mostrar modal de √©xito despu√©s de un breve delay
      setTimeout(() => {
        setShowSuccessModal(true);
      }, 1000);

    } catch (error: any) {
      setCurrentStep('error');
      setErrorMessage(error.message || 'Error desconocido durante el spoofing');
      await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
    } finally {
      setIsExecuting(false);
    }
  };

  const canExecute = status === 'connected' && device && canAttemptSpoofing(getChipsetCompatibility(device.chipset || ''));

  // Funci√≥n REAL de Test de Spoofing
  const handleTestSpoofing = async () => {
    setIsTesting(true);
    setTestResult(null);
    
    try {
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
      
      // Re-escanear dispositivos USB REALES
      const devices = await usbService.scanDevices();
      
      if (devices.length === 0) {
        Alert.alert(
          '‚ö†Ô∏è Dispositivo No Detectado',
          'No se detect√≥ ning√∫n dispositivo USB.\n\n' +
          'üîå INSTRUCCIONES:\n' +
          '1. Desconecta el adaptador USB\n' +
          '2. Espera 5 segundos\n' +
          '3. Vuelve a conectar el adaptador\n' +
          '4. Espera a que el sistema lo reconozca\n' +
          '5. Intenta el test nuevamente'
        );
        setTestResult('fail');
        await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
        return;
      }
      
      // Verificar VID/PID del primer dispositivo detectado
      const detectedDevice = devices[0];
      const targetVID = 0x2001;
      const targetPID = 0x3C05;
      
      const isSuccess = detectedDevice.vendorId === targetVID && detectedDevice.productId === targetPID;
      
      if (isSuccess) {
        setTestResult('success');
        await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
        Alert.alert(
          '‚úÖ Spoofing Exitoso',
          `El adaptador tiene el VID/PID correcto:\n\n` +
          `üîå Dispositivo: ${detectedDevice.deviceName}\n` +
          `‚úÖ VID: 0x${detectedDevice.vendorId.toString(16).toUpperCase().padStart(4, '0')} (D-Link)\n` +
          `‚úÖ PID: 0x${detectedDevice.productId.toString(16).toUpperCase().padStart(4, '0')} (DUB-E100)\n` +
          `üëç Chipset: ${detectedDevice.chipset}\n\n` +
          `‚úÖ El spoofing fue EXITOSO. El adaptador ahora es compatible con MIB2.`
        );
      } else {
        setTestResult('fail');
        await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Warning);
        Alert.alert(
          '‚ö†Ô∏è Spoofing No Detectado',
          `El adaptador NO tiene el VID/PID objetivo:\n\n` +
          `üîå Dispositivo: ${detectedDevice.deviceName}\n` +
          `‚ùå VID actual: 0x${detectedDevice.vendorId.toString(16).toUpperCase().padStart(4, '0')}\n` +
          `‚ùå PID actual: 0x${detectedDevice.productId.toString(16).toUpperCase().padStart(4, '0')}\n` +
          `üéØ VID esperado: 0x2001\n` +
          `üéØ PID esperado: 0x3C05\n\n` +
          `üîÑ POSIBLES CAUSAS:\n` +
          `1. No se ha ejecutado el spoofing a√∫n\n` +
          `2. El spoofing fall√≥ durante la escritura\n` +
          `3. No se ha reconectado el adaptador despu√©s del spoofing\n\n` +
          `üí° SOLUCI√ìN:\n` +
          `Desconecta y reconecta el adaptador para que el sistema lea los nuevos valores de EEPROM.`
        );
      }
    } catch (error: any) {
      setTestResult('fail');
      await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
      Alert.alert('Error', `No se pudo realizar el test:\n\n${error.message}`);
    } finally {
      setIsTesting(false);
    }
  };

  // Funci√≥n REAL de Spoof R√°pido (una sola confirmaci√≥n)
  const handleQuickSpoof = async () => {
    if (!device) {
      Alert.alert('Error', 'No hay dispositivo USB conectado');
      return;
    }

    const compatibility = getChipsetCompatibility(device.chipset || '');
    
    if (!canAttemptSpoofing(compatibility)) {
      Alert.alert(
        'Dispositivo No Compatible',
        getCompatibilityMessage(compatibility, device.chipset || 'desconocido')
      );
      return;
    }

    // Una sola confirmaci√≥n cr√≠tica
    Alert.alert(
      '‚ö†Ô∏è Spoof R√°pido',
      `üöÄ MODO R√ÅPIDO - Una sola confirmaci√≥n\n\n` +
      `üìä Dispositivo: ${device.deviceName}\n` +
      `üîß Chipset: ${device.chipset}\n` +
      `üîÑ VID/PID: ${usbService.formatVIDPID(device.vendorId, device.productId)} ‚Üí 0x2001:0x3C05\n\n` +
      `‚ö†Ô∏è ADVERTENCIAS:\n` +
      `‚Ä¢ Modificaci√≥n PERMANENTE de EEPROM\n` +
      `‚Ä¢ NO desconectar durante el proceso\n` +
      `‚Ä¢ Backup autom√°tico incluido\n` +
      `‚Ä¢ Requiere reconexi√≥n despu√©s\n\n` +
      `üîã Bater√≠a: Aseg√∫rate de tener >20%\n\n` +
      `¬øEjecutar spoofing AHORA?`,
      [
        { text: 'Cancelar', style: 'cancel' },
        {
          text: 'S√ç, Ejecutar',
          style: 'destructive',
          onPress: () => performSpoof(),
        },
      ]
    );
  };
  
  const handleShareResult = async () => {
    try {
      if (!spoofingResult) return;
      
      // Crear texto formateado para compartir
      const shareText = `üéâ Spoofing MIB2 Exitoso\n\n` +
        `üíª Dispositivo: ${spoofingResult.deviceName}\n` +
        `üîß Chipset: ${spoofingResult.chipset}\n` +
        `üìÖ Fecha: ${spoofingResult.timestamp.toLocaleString('es-ES')}\n\n` +
        `‚ùå Antes:\n` +
        `  VID: ${spoofingResult.originalVID}\n` +
        `  PID: ${spoofingResult.originalPID}\n\n` +
        `‚úÖ Despu√©s:\n` +
        `  VID: ${spoofingResult.newVID}\n` +
        `  PID: ${spoofingResult.newPID}\n\n` +
        `#MIB2Controller #USBSpoofing #ASIX`;

      // Verificar si sharing est√° disponible
      const isAvailable = await Sharing.isAvailableAsync();
      
      if (isAvailable) {
        // Crear archivo temporal con el texto
        const FileSystem = require('expo-file-system');
        const fileUri = FileSystem.cacheDirectory + 'spoofing_result.txt';
        await FileSystem.writeAsStringAsync(fileUri, shareText);
        
        // Compartir archivo
        await Sharing.shareAsync(fileUri, {
          mimeType: 'text/plain',
          dialogTitle: 'Compartir Resultado de Spoofing',
        });
      } else {
        Alert.alert('Error', 'La funci√≥n de compartir no est√° disponible en este dispositivo');
      }
    } catch (error) {
      console.error('Error sharing result:', error);
      Alert.alert('Error', 'No se pudo compartir el resultado');
    }
  };

  return (
    <ScreenContainer className="p-4">
      <ScrollView contentContainerStyle={{ flexGrow: 1 }}>
        <View className="gap-4">
          {/* Header */}
          <View className="items-center mb-4">
            <Text className="text-3xl font-bold text-foreground mb-2">
              üîß Spoofing Autom√°tico
            </Text>
            <Text className="text-sm text-muted text-center">
              Reprogramaci√≥n autom√°tica de EEPROM para adaptadores ASIX compatibles
            </Text>
          </View>

          {/* Estado del Dispositivo */}
          <View className="bg-surface rounded-2xl p-6 border border-border">
            <Text className="text-lg font-bold text-foreground mb-4">
              üì± Dispositivo Conectado
            </Text>
            {device ? (
              <View className="gap-2">
                <View className="flex-row justify-between">
                  <Text className="text-sm text-muted">Nombre:</Text>
                  <Text className="text-sm text-foreground font-medium">
                    {device.deviceName}
                  </Text>
                </View>
                <View className="flex-row justify-between">
                  <Text className="text-sm text-muted">VID:PID Actual:</Text>
                  <Text className="text-sm text-foreground font-mono">
                    {usbService.formatVIDPID(device.vendorId, device.productId)}
                  </Text>
                </View>
                <View className="flex-row justify-between">
                  <Text className="text-sm text-muted">Chipset:</Text>
                  <Text className="text-sm text-foreground font-medium">
                    {device.chipset || 'Desconocido'}
                  </Text>
                </View>
                <View className="flex-row justify-between">
                  <Text className="text-sm text-muted">Compatible:</Text>
                  <Text className={`text-sm font-bold ${canExecute ? 'text-green-500' : 'text-red-500'}`}>
                    {canExecute ? '‚úÖ S√≠' : '‚ùå No'}
                  </Text>
                </View>
              </View>
            ) : (
              <Text className="text-sm text-muted">
                No hay dispositivo conectado
              </Text>
            )}
          </View>

          {/* Badge de Estado del Chipset */}
          {device && device.chipset && (
            <ChipsetStatusBadge
              chipset={device.chipset}
              compatibility={getChipsetCompatibility(device.chipset)}
              animated={true}
            />
          )}

          {/* Valores Objetivo */}
          <View className="bg-surface rounded-2xl p-6 border border-border">
            <Text className="text-lg font-bold text-foreground mb-4">
              üéØ Valores Objetivo
            </Text>
            <View className="gap-2">
              <View className="flex-row justify-between">
                <Text className="text-sm text-muted">VID (Vendor ID):</Text>
                <Text className="text-sm text-foreground font-mono font-bold">
                  0x2001 (D-Link)
                </Text>
              </View>
              <View className="flex-row justify-between">
                <Text className="text-sm text-muted">PID (Product ID):</Text>
                <Text className="text-sm text-foreground font-mono font-bold">
                  0x3C05 (DUB-E100)
                </Text>
              </View>
              <View className="flex-row justify-between">
                <Text className="text-sm text-muted">Magic Value:</Text>
                <Text className="text-sm text-foreground font-mono">
                  0xDEADBEEF
                </Text>
              </View>
            </View>
          </View>

          {/* Progreso */}
          {isExecuting && (
            <View className="bg-surface rounded-2xl p-6 border border-border">
              <Text className="text-lg font-bold text-foreground mb-4">
                ‚è≥ Progreso
              </Text>
              <View className="gap-3">
                <View className="flex-row items-center gap-2">
                  <Text className="text-xl">{getStepIcon('validating')}</Text>
                  <Text className="text-sm text-muted flex-1">Validando chipset</Text>
                </View>
                <View className="flex-row items-center gap-2">
                  <Text className="text-xl">{getStepIcon('creating_backup')}</Text>
                  <Text className="text-sm text-muted flex-1">Creando backup de seguridad</Text>
                </View>
                <View className="flex-row items-center gap-2">
                  <Text className="text-xl">{getStepIcon('writing_vid_low')}</Text>
                  <Text className="text-sm text-muted flex-1">Escribiendo VID byte bajo (0x88)</Text>
                </View>
                <View className="flex-row items-center gap-2">
                  <Text className="text-xl">{getStepIcon('writing_vid_high')}</Text>
                  <Text className="text-sm text-muted flex-1">Escribiendo VID byte alto (0x89)</Text>
                </View>
                <View className="flex-row items-center gap-2">
                  <Text className="text-xl">{getStepIcon('writing_pid_low')}</Text>
                  <Text className="text-sm text-muted flex-1">Escribiendo PID byte bajo (0x8A)</Text>
                </View>
                <View className="flex-row items-center gap-2">
                  <Text className="text-xl">{getStepIcon('writing_pid_high')}</Text>
                  <Text className="text-sm text-muted flex-1">Escribiendo PID byte alto (0x8B)</Text>
                </View>
                <View className="flex-row items-center gap-2">
                  <Text className="text-xl">{getStepIcon('verifying')}</Text>
                  <Text className="text-sm text-muted flex-1">Verificando escritura</Text>
                </View>
              </View>
              <View className="mt-4 p-4 bg-background rounded-lg">
                <Text className="text-sm text-foreground font-medium text-center">
                  {getStepText(currentStep)}
                </Text>
              </View>
            </View>
          )}

          {/* Indicador de Progreso EEPROM */}
          {isExecuting && eepromTotalBytes > 0 && (
            <EepromProgressIndicator
              progress={eepromProgress}
              bytesProcessed={eepromBytesProcessed}
              totalBytes={eepromTotalBytes}
              operation={eepromOperation}
              estimatedTimeRemaining={
                eepromProgress > 0 && eepromProgress < 100
                  ? Math.round(((100 - eepromProgress) / eepromProgress) * 2) // Estimaci√≥n simple
                  : undefined
              }
            />
          )}

          {/* Mensaje de √âxito */}
          {currentStep === 'success' && successMessage && (
            <View className="bg-green-500/10 rounded-2xl p-6 border border-green-500">
              <Text className="text-sm text-foreground whitespace-pre-line">
                {successMessage}
              </Text>
            </View>
          )}

          {/* Mensaje de Error */}
          {currentStep === 'error' && errorMessage && (
            <View className="bg-red-500/10 rounded-2xl p-6 border border-red-500">
              <Text className="text-lg font-bold text-red-500 mb-2">
                Error
              </Text>
              <Text className="text-sm text-foreground">
                {errorMessage}
              </Text>
            </View>
          )}

          {/* Advertencias de Seguridad */}
          <View className="bg-red-500/10 rounded-2xl p-6 border border-red-500">
            <Text className="text-lg font-bold text-red-500 mb-3">
              ‚ö†Ô∏è Advertencias Importantes
            </Text>
            <View className="gap-2">
              <Text className="text-sm text-foreground">
                ‚Ä¢ Esta operaci√≥n es IRREVERSIBLE sin backup
              </Text>
              <Text className="text-sm text-foreground">
                ‚Ä¢ NO desconectes el adaptador durante el proceso
              </Text>
              <Text className="text-sm text-foreground">
                ‚Ä¢ Solo funciona con ASIX AX88772A/B con EEPROM externa
              </Text>
              <Text className="text-sm text-foreground">
                ‚Ä¢ Dispositivos con eFuse NO son compatibles
              </Text>
              <Text className="text-sm text-foreground">
                ‚Ä¢ Se crear√° un backup autom√°tico antes de escribir
              </Text>
            </View>
          </View>

          {/* Checkbox Forzar sin Verificaci√≥n */}
          <TouchableOpacity
            onPress={() => {
              setSkipVerification(!skipVerification);
              Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
            }}
            disabled={isExecuting}
            className="flex-row items-start gap-3 p-4 rounded-xl bg-yellow-500/10 border border-yellow-500/30"
          >
            <View className={`w-6 h-6 rounded border-2 items-center justify-center ${
              skipVerification ? 'bg-yellow-500 border-yellow-500' : 'border-yellow-500'
            }`}>
              {skipVerification && <Text className="text-background font-bold">‚úì</Text>}
            </View>
            <View className="flex-1">
              <Text className="text-base font-semibold text-yellow-500 mb-1">
                ‚ö†Ô∏è Forzar sin Verificaci√≥n
              </Text>
              <Text className="text-xs text-muted leading-relaxed">
                Omite la verificaci√≥n post-escritura. √ösalo solo si la verificaci√≥n normal falla debido a protecci√≥n de escritura del adaptador. Despu√©s del spoofing, desconecta y reconecta el adaptador para verificar manualmente.
              </Text>
            </View>
          </TouchableOpacity>

          {/* Botones de Test y Spoof R√°pido */}
          <View className="gap-3">
            {/* Bot√≥n Test de Spoofing */}
            <TouchableOpacity
              onPress={handleTestSpoofing}
              disabled={isTesting}
              className={`rounded-xl p-4 items-center border-2 ${
                testResult === 'success'
                  ? 'bg-green-500/10 border-green-500'
                  : testResult === 'fail'
                  ? 'bg-red-500/10 border-red-500'
                  : isTesting
                  ? 'bg-muted/20 border-muted opacity-50'
                  : 'bg-blue-500/10 border-blue-500 active:opacity-80'
              }`}
            >
              <View className="flex-row items-center gap-2">
                <Text className="text-xl">
                  {isTesting ? '‚è≥' : testResult === 'success' ? '‚úÖ' : testResult === 'fail' ? '‚ùå' : 'üß™'}
                </Text>
                <Text className={`text-base font-bold ${
                  testResult === 'success'
                    ? 'text-green-500'
                    : testResult === 'fail'
                    ? 'text-red-500'
                    : isTesting
                    ? 'text-muted'
                    : 'text-blue-500'
                }`}>
                  {isTesting ? 'Testeando...' : 'Test de Spoofing'}
                </Text>
              </View>
              <Text className="text-xs text-muted mt-1">
                Verifica si el adaptador tiene VID/PID 0x2001:0x3C05
              </Text>
            </TouchableOpacity>

            {/* Bot√≥n Spoof R√°pido */}
            <TouchableOpacity
              onPress={handleQuickSpoof}
              disabled={!canExecute || isExecuting}
              className={`rounded-xl p-4 items-center border-2 ${
                canExecute && !isExecuting
                  ? 'bg-orange-500/10 border-orange-500 active:opacity-80'
                  : 'bg-muted/20 border-muted opacity-50'
              }`}
            >
              <View className="flex-row items-center gap-2">
                <Text className="text-xl">üîÑ</Text>
                <Text className={`text-base font-bold ${
                  canExecute && !isExecuting ? 'text-orange-500' : 'text-muted'
                }`}>
                  {isExecuting ? 'Ejecutando...' : 'Spoof R√°pido'}
                </Text>
              </View>
              <Text className="text-xs text-muted mt-1">
                Ejecuta spoofing con una sola confirmaci√≥n
              </Text>
            </TouchableOpacity>
          </View>

          {/* Bot√≥n de Ejecuci√≥n Principal */}
          <TouchableOpacity
            onPress={executeAutoSpoof}
            disabled={!canExecute || isExecuting}
            className={`rounded-2xl p-6 items-center ${
              canExecute && !isExecuting
                ? 'bg-primary'
                : 'bg-muted opacity-50'
            }`}
          >
            <Text className="text-2xl font-bold text-background mb-2">
              {isExecuting ? '‚è≥ Ejecutando...' : 'üöÄ Ejecutar Spoofing Autom√°tico'}
            </Text>
            {!canExecute && !isExecuting && (
              <Text className="text-xs text-background opacity-70">
                Conecta un adaptador compatible para continuar
              </Text>
            )}
            {canExecute && !isExecuting && (
              <Text className="text-xs text-background/80 mt-1">
                Con triple confirmaci√≥n y validaciones completas
              </Text>
            )}
          </TouchableOpacity>
        </View>
      </ScrollView>
      
      {/* Success Result Modal */}
      <SuccessResultModal
        visible={showSuccessModal}
        result={spoofingResult}
        onClose={() => {
          setShowSuccessModal(false);
          setSpoofingResult(null);
        }}
        onShare={handleShareResult}
      />
    </ScreenContainer>
  );
}

================================================================================
FILE: app/(tabs)/commands.tsx
================================================================================

import { Alert, Pressable, ScrollView, Text, TextInput, View } from "react-native";
import { useState, useRef, useEffect } from "react";
import * as Haptics from "expo-haptics";
import * as Clipboard from "expo-clipboard";

import { ScreenContainer } from "@/components/screen-container";
import { useTelnet } from "@/lib/telnet-provider";
import { MIB2_COMMANDS } from "@/lib/telnet-client";
import { useColors } from "@/hooks/use-colors";

export default function CommandsScreen() {
  const colors = useColors();
  const { isConnected, isConnecting, connect, disconnect, sendCommand, messages, clearMessages } = useTelnet();
  const [commandInput, setCommandInput] = useState('');

  const [showSuggestions, setShowSuggestions] = useState(false);
  const scrollViewRef = useRef<ScrollView>(null);
  const inputRef = useRef<TextInput>(null);

  // Auto-scroll to bottom when new messages arrive
  useEffect(() => {
    setTimeout(() => {
      scrollViewRef.current?.scrollToEnd({ animated: true });
    }, 100);
  }, [messages]);

  // Filter suggestions based on input
  const suggestions = Object.entries(MIB2_COMMANDS)
    .filter(([key, cmd]) => 
      commandInput && (
        key.toLowerCase().includes(commandInput.toLowerCase()) ||
        cmd.toLowerCase().includes(commandInput.toLowerCase())
      )
    )
    .slice(0, 5);

  const handleSendCommand = () => {
    if (!commandInput.trim()) return;

    if (!isConnected) {
      Alert.alert('No Conectado', 'Debes conectarte a la unidad MIB2 primero');
      return;
    }

    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    
    // Send command
    sendCommand(commandInput);
    
    // Clear input
    setCommandInput('');
    setShowSuggestions(false);
  };

  const handleSelectSuggestion = (command: string) => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    setCommandInput(command);
    setShowSuggestions(false);
    inputRef.current?.focus();
  };

  const handleCopyMessage = async (text: string) => {
    await Clipboard.setStringAsync(text);
    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
  };

  const handleClearTerminal = () => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    clearMessages();
  };

  const handleConnect = async () => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    try {
      await connect();
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    } catch (error) {
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
    }
  };

  const handleDisconnect = () => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    disconnect();
  };

  const getMessageColor = (type: string): string => {
    switch (type) {
      case 'command':
        return colors.primary;
      case 'error':
        return '#EF4444';
      case 'info':
        return '#F59E0B';
      case 'response':
      default:
        return colors.foreground;
    }
  };

  const formatTimestamp = (date: Date): string => {
    return new Date(date).toLocaleTimeString('es-ES', { 
      hour: '2-digit', 
      minute: '2-digit',
      second: '2-digit'
    });
  };

  return (
    <ScreenContainer className="flex-1">
      <View className="flex-1 p-4 gap-4">
        {/* Header */}
        <View className="flex-row items-center justify-between">
          <View>
            <Text className="text-2xl font-bold text-foreground">Terminal Telnet</Text>
            <Text className="text-sm text-muted">
              {isConnected ? 'üü¢ Conectado' : 'üî¥ Desconectado'}
            </Text>
          </View>
          <View className="flex-row gap-2">
            {!isConnected ? (
              <Pressable
                onPress={handleConnect}
                disabled={isConnecting}
                className="bg-success px-4 py-2 rounded-lg active:opacity-80"
              >
                <Text className="text-background font-semibold">
                  {isConnecting ? 'Conectando...' : 'Conectar'}
                </Text>
              </Pressable>
            ) : (
              <Pressable
                onPress={handleDisconnect}
                className="bg-error px-4 py-2 rounded-lg active:opacity-80"
              >
                <Text className="text-background font-semibold">Desconectar</Text>
              </Pressable>
            )}
          </View>
        </View>

        {/* Terminal Output */}
        <View className="flex-1 bg-background border border-border rounded-xl overflow-hidden">
          <ScrollView
            ref={scrollViewRef}
            className="flex-1 p-4"
            contentContainerStyle={{ flexGrow: 1 }}
          >
            {messages.length === 0 ? (
              <View className="flex-1 items-center justify-center">
                <Text className="text-muted text-center">
                  Terminal vac√≠a{'\n'}
                  {isConnected ? 'Escribe un comando abajo' : 'Conecta primero para enviar comandos'}
                </Text>
              </View>
            ) : (
              <View className="gap-1">
                {messages.map((msg, index) => (
                  <Pressable
                    key={index}
                    onLongPress={() => handleCopyMessage(msg.text)}
                    className="active:opacity-70"
                  >
                    <View className="flex-row gap-2">
                      <Text className="text-xs text-muted font-mono">
                        {formatTimestamp(msg.timestamp)}
                      </Text>
                      <Text
                        className="flex-1 text-sm font-mono"
                        style={{ color: getMessageColor(msg.type) }}
                      >
                        {msg.text}
                      </Text>
                    </View>
                  </Pressable>
                ))}
              </View>
            )}
          </ScrollView>

          {/* Clear Button */}
          {messages.length > 0 && (
            <Pressable
              onPress={handleClearTerminal}
              className="absolute top-2 right-2 bg-surface/90 px-3 py-1 rounded-lg active:opacity-80"
            >
              <Text className="text-xs text-muted font-semibold">Limpiar</Text>
            </Pressable>
          )}
        </View>

        {/* Suggestions */}
        {showSuggestions && suggestions.length > 0 && (
          <View className="bg-surface border border-border rounded-xl p-2 max-h-40">
            <ScrollView>
              {suggestions.map(([key, cmd]) => (
                <Pressable
                  key={key}
                  onPress={() => handleSelectSuggestion(cmd)}
                  className="p-2 active:bg-primary/10 rounded-lg"
                >
                  <Text className="text-sm font-semibold text-foreground">{key}</Text>
                  <Text className="text-xs text-muted font-mono" numberOfLines={1}>
                    {cmd}
                  </Text>
                </Pressable>
              ))}
            </ScrollView>
          </View>
        )}

        {/* Command Input */}
        <View className="flex-row gap-2">
          <View className="flex-1">
            <TextInput
              ref={inputRef}
              value={commandInput}
              onChangeText={(text) => {
                setCommandInput(text);
                setShowSuggestions(text.length > 0);
              }}
              onSubmitEditing={handleSendCommand}
              placeholder={isConnected ? "Escribe un comando..." : "Conecta primero..."}
              placeholderTextColor={colors.muted}
              editable={isConnected}
              autoCapitalize="none"
              autoCorrect={false}
              returnKeyType="send"
              className="bg-surface border border-border rounded-xl px-4 py-3 text-foreground font-mono"
            />
          </View>
          <Pressable
            onPress={handleSendCommand}
            disabled={!isConnected || !commandInput.trim()}
            className={`px-6 py-3 rounded-xl active:opacity-80 ${
              isConnected && commandInput.trim() ? 'bg-primary' : 'bg-muted/20'
            }`}
          >
            <Text
              className={`font-semibold ${
                isConnected && commandInput.trim() ? 'text-background' : 'text-muted'
              }`}
            >
              Enviar
            </Text>
          </Pressable>
        </View>

        {/* Quick Commands */}
        <View>
          <Text className="text-sm font-semibold text-foreground mb-2">Comandos R√°pidos</Text>
          <ScrollView horizontal showsHorizontalScrollIndicator={false} className="gap-2">
            {Object.entries(MIB2_COMMANDS).slice(0, 6).map(([key, cmd]) => (
              <Pressable
                key={key}
                onPress={() => {
                  setCommandInput(cmd);
                  setShowSuggestions(false);
                }}
                className="bg-surface border border-border px-4 py-2 rounded-full active:opacity-80"
              >
                <Text className="text-xs font-semibold text-foreground">{key}</Text>
              </Pressable>
            ))}
          </ScrollView>
        </View>
      </View>
    </ScreenContainer>
  );
}

================================================================================
FILE: app/(tabs)/diag.tsx
================================================================================

import { View, Text, TouchableOpacity, ScrollView, Alert } from 'react-native';
import { useState, useEffect, useRef } from 'react';
import * as Haptics from 'expo-haptics';
import * as Sharing from 'expo-sharing';
import * as FileSystem from 'expo-file-system/legacy';
import { ScreenContainer } from '@/components/screen-container';
import { usbLogger, type UsbLogEntry, type LogLevel } from '@/lib/usb-logger';

export default function DiagScreen() {
  const [logs, setLogs] = useState<UsbLogEntry[]>([]);
  const [filter, setFilter] = useState<LogLevel | 'all'>('all');
  const [autoScroll, setAutoScroll] = useState(true);
  const scrollViewRef = useRef<ScrollView>(null);

  // Suscribirse a cambios en logs
  useEffect(() => {
    const unsubscribe = usbLogger.subscribe((newLogs) => {
      setLogs(newLogs);
      if (autoScroll && scrollViewRef.current) {
        // Auto-scroll al final
        setTimeout(() => {
          scrollViewRef.current?.scrollToEnd({ animated: true });
        }, 100);
      }
    });

    return unsubscribe;
  }, [autoScroll]);

  const filteredLogs = filter === 'all' 
    ? logs 
    : logs.filter(log => log.level === filter);

  const handleClearLogs = async () => {
    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    Alert.alert(
      'üóëÔ∏è Limpiar Logs',
      '¬øEst√°s seguro de que quieres eliminar todos los logs?',
      [
        { text: 'Cancelar', style: 'cancel' },
        {
          text: 'Limpiar',
          style: 'destructive',
          onPress: () => {
            usbLogger.clear();
            Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
          },
        },
      ]
    );
  };

  const handleExportLogs = async () => {
    try {
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
      
      const textContent = usbLogger.exportAsText();
      const filename = `usb_logs_${Date.now()}.txt`;
      const filepath = `${FileSystem.documentDirectory}${filename}`;

      await FileSystem.writeAsStringAsync(filepath, textContent, {
        encoding: FileSystem.EncodingType.UTF8,
      });

      const canShare = await Sharing.isAvailableAsync();
      if (canShare) {
        await Sharing.shareAsync(filepath, {
          mimeType: 'text/plain',
          dialogTitle: 'Compartir Logs USB',
        });
      } else {
        Alert.alert(
          '‚úÖ Logs Exportados',
          `Archivo guardado en:\n${filename}\n\nPuedes encontrarlo en la carpeta de documentos de la app.`
        );
      }

      await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    } catch (error: any) {
      await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
      Alert.alert('‚ùå Error', `No se pudieron exportar los logs:\n${error.message}`);
    }
  };

  const getLevelColor = (level: LogLevel): string => {
    switch (level) {
      case 'info':
        return 'text-blue-400';
      case 'warning':
        return 'text-yellow-400';
      case 'error':
        return 'text-red-400';
      case 'success':
        return 'text-green-400';
    }
  };

  const getLevelIcon = (level: LogLevel): string => {
    switch (level) {
      case 'info':
        return '‚ÑπÔ∏è';
      case 'warning':
        return '‚ö†Ô∏è';
      case 'error':
        return '‚ùå';
      case 'success':
        return '‚úÖ';
    }
  };

  return (
    <ScreenContainer className="p-4">
      <ScrollView
        contentContainerStyle={{ flexGrow: 1, paddingBottom: 20 }}
        showsVerticalScrollIndicator={false}
      >
        {/* Header */}
        <View className="mb-6">
          <Text className="text-3xl font-bold text-foreground mb-2">
            üîç Diagn√≥stico USB
          </Text>
          <Text className="text-sm text-muted">
            Logs en tiempo real de todas las operaciones USB
          </Text>
        </View>

        {/* Controls */}
        <View className="flex-row gap-2 mb-4">
          <TouchableOpacity
            onPress={handleClearLogs}
            className="flex-1 bg-red-500/10 border border-red-500/30 rounded-xl p-3 active:opacity-80"
          >
            <Text className="text-sm font-semibold text-red-400 text-center">
              üóëÔ∏è Limpiar
            </Text>
          </TouchableOpacity>

          <TouchableOpacity
            onPress={handleExportLogs}
            className="flex-1 bg-primary/10 border border-primary/30 rounded-xl p-3 active:opacity-80"
          >
            <Text className="text-sm font-semibold text-primary text-center">
              üì§ Exportar
            </Text>
          </TouchableOpacity>

          <TouchableOpacity
            onPress={async () => {
              await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
              setAutoScroll(!autoScroll);
            }}
            className={`flex-1 ${autoScroll ? 'bg-green-500/10 border-green-500/30' : 'bg-surface border-border'} border rounded-xl p-3 active:opacity-80`}
          >
            <Text className={`text-sm font-semibold ${autoScroll ? 'text-green-400' : 'text-muted'} text-center`}>
              {autoScroll ? 'üìú Auto' : '‚è∏Ô∏è Manual'}
            </Text>
          </TouchableOpacity>
        </View>

        {/* Filters */}
        <View className="flex-row gap-2 mb-4">
          {(['all', 'info', 'warning', 'error', 'success'] as const).map((level) => (
            <TouchableOpacity
              key={level}
              onPress={async () => {
                await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
                setFilter(level);
              }}
              className={`px-3 py-2 rounded-lg ${filter === level ? 'bg-primary' : 'bg-surface'} active:opacity-80`}
            >
              <Text className={`text-xs font-semibold ${filter === level ? 'text-background' : 'text-muted'}`}>
                {level === 'all' ? 'Todos' : level.charAt(0).toUpperCase() + level.slice(1)}
              </Text>
            </TouchableOpacity>
          ))}
        </View>

        {/* Stats */}
        <View className="bg-surface rounded-xl p-4 mb-4 border border-border">
          <View className="flex-row justify-between">
            <View className="items-center flex-1">
              <Text className="text-2xl font-bold text-foreground">{logs.length}</Text>
              <Text className="text-xs text-muted">Total</Text>
            </View>
            <View className="items-center flex-1">
              <Text className="text-2xl font-bold text-red-400">
                {logs.filter(l => l.level === 'error').length}
              </Text>
              <Text className="text-xs text-muted">Errores</Text>
            </View>
            <View className="items-center flex-1">
              <Text className="text-2xl font-bold text-yellow-400">
                {logs.filter(l => l.level === 'warning').length}
              </Text>
              <Text className="text-xs text-muted">Avisos</Text>
            </View>
            <View className="items-center flex-1">
              <Text className="text-2xl font-bold text-green-400">
                {logs.filter(l => l.level === 'success').length}
              </Text>
              <Text className="text-xs text-muted">√âxitos</Text>
            </View>
          </View>
        </View>

        {/* Logs */}
        <View className="bg-surface rounded-xl p-4 border border-border">
          <Text className="text-sm font-semibold text-foreground mb-3">
            üìã Logs ({filteredLogs.length})
          </Text>

          {filteredLogs.length === 0 ? (
            <View className="items-center py-8">
              <Text className="text-4xl mb-3">üìù</Text>
              <Text className="text-sm text-muted text-center">
                {filter === 'all' 
                  ? 'No hay logs a√∫n.\nLas operaciones USB aparecer√°n aqu√≠ en tiempo real.'
                  : `No hay logs de tipo "${filter}".`
                }
              </Text>
            </View>
          ) : (
            <ScrollView
              ref={scrollViewRef}
              style={{ maxHeight: 400 }}
              showsVerticalScrollIndicator={true}
            >
              <View className="gap-2">
                {filteredLogs.map((log) => (
                  <View
                    key={log.id}
                    className="bg-background rounded-lg p-3 border border-border"
                  >
                    <View className="flex-row items-start gap-2">
                      <Text className="text-base">{getLevelIcon(log.level)}</Text>
                      <View className="flex-1">
                        <View className="flex-row items-center gap-2 mb-1">
                          <Text className={`text-xs font-bold ${getLevelColor(log.level)}`}>
                            {log.operation.toUpperCase()}
                          </Text>
                          <Text className="text-xs text-muted">
                            {new Date(log.timestamp).toLocaleTimeString('es-ES')}
                          </Text>
                        </View>
                        <Text className="text-sm text-foreground">{log.message}</Text>
                        {log.details && (
                          <Text className="text-xs text-muted mt-1 font-mono">
                            {typeof log.details === 'string' 
                              ? log.details 
                              : JSON.stringify(log.details, null, 2)
                            }
                          </Text>
                        )}
                      </View>
                    </View>
                  </View>
                ))}
              </View>
            </ScrollView>
          )}
        </View>
      </ScrollView>
    </ScreenContainer>
  );
}

================================================================================
FILE: app/(tabs)/fec.tsx
================================================================================

import { useState } from "react";
import { ScrollView, Text, View, TouchableOpacity, TextInput, Alert, Platform, Linking } from "react-native";
import * as Haptics from "expo-haptics";
import * as Sharing from "expo-sharing";
import * as FileSystem from "expo-file-system/legacy";

import { ScreenContainer } from "@/components/screen-container";
import { useColors } from "@/hooks/use-colors";
import { useTelnet } from "@/lib/telnet-provider";
import {
  PREDEFINED_FEC_CODES,
  FEC_INJECTION_INFO,
  FEC_GENERATOR_URL,
  validateVIN,
  validateVCRN,
  validateFECCode,
  generateExceptionList,
  generateToolboxInjectionCommand,
  generateFecInjectionCommands,
} from "@/lib/fec-generator";

export default function FECScreen() {
  const colors = useColors();
  const { isConnected, sendCommand } = useTelnet();
  const [vin, setVin] = useState("");
  const [vcrn, setVcrn] = useState("");
  const [selectedCodes, setSelectedCodes] = useState<string[]>([]);
  const [customCode, setCustomCode] = useState("");
  const [showInfo, setShowInfo] = useState(false);

  const handleToggleCode = (code: string) => {
    if (Platform.OS !== "web") {
      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    }
    
    setSelectedCodes(prev =>
      prev.includes(code)
        ? prev.filter(c => c !== code)
        : [...prev, code]
    );
  };

  const handleAddCustomCode = () => {
    if (!validateFECCode(customCode)) {
      Alert.alert("C√≥digo Inv√°lido", "El c√≥digo FEC debe tener 8 d√≠gitos hexadecimales.");
      return;
    }

    if (selectedCodes.includes(customCode.toUpperCase())) {
      Alert.alert("C√≥digo Duplicado", "Este c√≥digo ya est√° en la lista.");
      return;
    }

    if (Platform.OS !== "web") {
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    }

    setSelectedCodes(prev => [...prev, customCode.toUpperCase()]);
    setCustomCode("");
  };

  const handleGenerateExceptionList = async () => {
    if (selectedCodes.length === 0) {
      Alert.alert("Sin C√≥digos", "Selecciona al menos un c√≥digo FEC para generar la lista.");
      return;
    }

    try {
      const exceptionList = generateExceptionList(selectedCodes);
      const fileUri = `${FileSystem.documentDirectory}ExceptionList.txt`;
      
      await FileSystem.writeAsStringAsync(fileUri, exceptionList);

      if (Platform.OS !== "web") {
        Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
      }

      Alert.alert(
        "ExceptionList Generada",
        "El archivo ExceptionList.txt ha sido creado exitosamente.",
        [
          { text: "OK" },
          {
            text: "Compartir",
            onPress: async () => {
              if (await Sharing.isAvailableAsync()) {
                await Sharing.shareAsync(fileUri);
              }
            },
          },
        ]
      );
    } catch (error) {
      Alert.alert("Error", "No se pudo generar el archivo ExceptionList.txt");
      console.error(error);
    }
  };

  const handleGenerateInjectionCommand = () => {
    if (selectedCodes.length === 0) {
      Alert.alert("Sin C√≥digos", "Selecciona al menos un c√≥digo FEC para generar el comando.");
      return;
    }

    const command = generateToolboxInjectionCommand(selectedCodes);
    Alert.alert("Comando de Inyecci√≥n", command, [{ text: "Cerrar" }]);
  };

  const handleInjectViaTelnet = () => {
    if (!isConnected) {
      Alert.alert('No Conectado', 'Debes conectarte a la unidad MIB2 primero');
      return;
    }

    if (selectedCodes.length === 0) {
      Alert.alert('Sin C√≥digos', 'Selecciona al menos un c√≥digo FEC');
      return;
    }

    Alert.alert(
      'Confirmar Inyecci√≥n',
      `¬øInyectar ${selectedCodes.length} c√≥digo(s) FEC v√≠a Telnet?\n\nLa unidad se reiniciar√° autom√°ticamente.`,
      [
        { text: 'Cancelar', style: 'cancel' },
        {
          text: 'Inyectar',
          style: 'destructive',
          onPress: () => {
            if (Platform.OS !== 'web') {
              Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Heavy);
            }
            const commands = generateFecInjectionCommands(selectedCodes);
            commands.forEach((cmd) => {
              if (cmd && !cmd.startsWith('#')) {
                sendCommand(cmd);
              }
            });
            Alert.alert('Inyectando', 'C√≥digos FEC enviados. La unidad se reiniciar√°.');
          },
        },
      ]
    );
  };

  const handleOpenGenerator = async () => {
    if (Platform.OS !== 'web') {
      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    }
    const supported = await Linking.canOpenURL(FEC_GENERATOR_URL);
    if (supported) {
      await Linking.openURL(FEC_GENERATOR_URL);
    } else {
      Alert.alert('Error', 'No se pudo abrir el generador online');
    }
  };

  const handleShowInfo = () => {
    if (Platform.OS !== "web") {
      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    }
    setShowInfo(!showInfo);
  };

  return (
    <ScreenContainer className="p-4">
      <ScrollView showsVerticalScrollIndicator={false}>
        <View className="gap-6">
          {/* Header */}
          <View className="gap-2">
            <Text className="text-3xl font-bold" style={{ color: colors.foreground }}>
              Generador de C√≥digos FEC
            </Text>
            <Text className="text-sm" style={{ color: colors.muted }}>
              Feature Enable Codes para activaci√≥n de funciones SWaP
            </Text>
          </View>

          {/* Generator Button */}
          <TouchableOpacity
            onPress={handleOpenGenerator}
            className="bg-primary px-4 py-3 rounded-xl active:opacity-80"
          >
            <Text className="text-center font-semibold text-base" style={{ color: colors.background }}>
              üåê Abrir Generador Online (vwcoding.ru)
            </Text>
          </TouchableOpacity>

          {/* Info Button */}
          <TouchableOpacity
            onPress={handleShowInfo}
            className="bg-primary/10 px-4 py-3 rounded-xl active:opacity-80"
          >
            <Text className="text-center font-semibold" style={{ color: colors.primary }}>
              {showInfo ? "Ocultar" : "Mostrar"} Informaci√≥n del Proceso
            </Text>
          </TouchableOpacity>

          {/* Info Panel */}
          {showInfo && (
            <View className="bg-surface rounded-xl p-4 border" style={{ borderColor: colors.border }}>
              <Text className="text-lg font-bold mb-3" style={{ color: colors.foreground }}>
                {FEC_INJECTION_INFO.title}
              </Text>

              {/* Steps */}
              {FEC_INJECTION_INFO.steps.map((step) => (
                <View key={step.step} className="mb-3">
                  <Text className="text-sm font-semibold" style={{ color: colors.foreground }}>
                    {step.step}. {step.title}
                  </Text>
                  <Text className="text-xs mt-1" style={{ color: colors.muted }}>
                    {step.description}
                  </Text>
                </View>
              ))}

              {/* Warnings */}
              <View className="bg-error/10 rounded-lg p-3 mt-3">
                <Text className="text-sm font-semibold mb-2" style={{ color: "#EF4444" }}>
                  ‚ö†Ô∏è Advertencias
                </Text>
                {FEC_INJECTION_INFO.warnings.map((warning, index) => (
                  <Text key={index} className="text-xs mb-1" style={{ color: "#EF4444" }}>
                    ‚Ä¢ {warning}
                  </Text>
                ))}
              </View>

              {/* Technical Note */}
              <View className="bg-primary/10 rounded-lg p-3 mt-3">
                <Text className="text-sm font-semibold mb-2" style={{ color: colors.primary }}>
                  üìù Nota T√©cnica
                </Text>
                <Text className="text-xs" style={{ color: colors.foreground }}>
                  {FEC_INJECTION_INFO.technicalNote}
                </Text>
              </View>
            </View>
          )}

          {/* Vehicle Data Section */}
          <View className="bg-surface rounded-xl p-4 border" style={{ borderColor: colors.border }}>
            <Text className="text-lg font-semibold mb-3" style={{ color: colors.foreground }}>
              Datos del Veh√≠culo (Opcional)
            </Text>
            <Text className="text-xs mb-3" style={{ color: colors.muted }}>
              Para generaci√≥n de c√≥digos personalizados basados en VIN/VCRN
            </Text>

            <Text className="text-sm font-semibold mb-2" style={{ color: colors.foreground }}>
              VIN (17 caracteres)
            </Text>
            <TextInput
              value={vin}
              onChangeText={setVin}
              placeholder="WVWZZZ1KZAW123456"
              placeholderTextColor={colors.muted}
              maxLength={17}
              autoCapitalize="characters"
              className="bg-background rounded-lg px-4 py-3 mb-3"
              style={{ color: colors.foreground, borderWidth: 1, borderColor: colors.border }}
            />

            <Text className="text-sm font-semibold mb-2" style={{ color: colors.foreground }}>
              VCRN (N√∫mero de Serie)
            </Text>
            <TextInput
              value={vcrn}
              onChangeText={setVcrn}
              placeholder="5QA035842"
              placeholderTextColor={colors.muted}
              className="bg-background rounded-lg px-4 py-3"
              style={{ color: colors.foreground, borderWidth: 1, borderColor: colors.border }}
            />

            {vin && !validateVIN(vin) && (
              <Text className="text-xs mt-2" style={{ color: "#EF4444" }}>
                VIN inv√°lido (debe tener 17 caracteres alfanum√©ricos)
              </Text>
            )}
            {vcrn && !validateVCRN(vcrn) && (
              <Text className="text-xs mt-2" style={{ color: "#EF4444" }}>
                VCRN inv√°lido (debe tener entre 8 y 20 caracteres)
              </Text>
            )}
          </View>

          {/* Predefined Codes */}
          <View className="gap-3">
            <Text className="text-lg font-semibold" style={{ color: colors.foreground }}>
              C√≥digos FEC Predefinidos
            </Text>
            {PREDEFINED_FEC_CODES.map((fec) => (
              <TouchableOpacity
                key={fec.code}
                onPress={() => handleToggleCode(fec.code)}
                className="bg-surface rounded-xl p-4 border active:opacity-80"
                style={{
                  borderColor: selectedCodes.includes(fec.code) ? colors.primary : colors.border,
                  borderWidth: selectedCodes.includes(fec.code) ? 2 : 1,
                }}
              >
                <View className="flex-row items-center justify-between mb-2">
                  <Text className="text-base font-semibold" style={{ color: colors.foreground }}>
                    {fec.name}
                  </Text>
                  <View
                    className="w-6 h-6 rounded-full items-center justify-center"
                    style={{
                      backgroundColor: selectedCodes.includes(fec.code)
                        ? colors.primary
                        : colors.border,
                    }}
                  >
                    {selectedCodes.includes(fec.code) && (
                      <Text className="text-xs font-bold" style={{ color: colors.background }}>
                        ‚úì
                      </Text>
                    )}
                  </View>
                </View>
                <Text className="text-xs mb-2" style={{ color: colors.muted }}>
                  {fec.description}
                </Text>
                <Text className="text-xs font-mono" style={{ color: colors.primary }}>
                  C√≥digo: {fec.code}
                </Text>
              </TouchableOpacity>
            ))}
          </View>

          {/* Custom Code Input */}
          <View className="bg-surface rounded-xl p-4 border" style={{ borderColor: colors.border }}>
            <Text className="text-lg font-semibold mb-3" style={{ color: colors.foreground }}>
              Agregar C√≥digo Personalizado
            </Text>
            <TextInput
              value={customCode}
              onChangeText={setCustomCode}
              placeholder="00060800"
              placeholderTextColor={colors.muted}
              maxLength={8}
              autoCapitalize="characters"
              className="bg-background rounded-lg px-4 py-3 mb-3"
              style={{ color: colors.foreground, borderWidth: 1, borderColor: colors.border }}
            />
            <TouchableOpacity
              onPress={handleAddCustomCode}
              className="bg-primary px-4 py-3 rounded-xl active:opacity-80"
            >
              <Text className="text-center font-semibold" style={{ color: colors.background }}>
                Agregar C√≥digo
              </Text>
            </TouchableOpacity>
          </View>

          {/* Selected Codes Summary */}
          {selectedCodes.length > 0 && (
            <View className="bg-success/10 rounded-xl p-4 border" style={{ borderColor: "#22C55E" }}>
              <Text className="text-lg font-semibold mb-3" style={{ color: "#22C55E" }}>
                C√≥digos Seleccionados ({selectedCodes.length})
              </Text>
              {selectedCodes.map((code) => (
                <View key={code} className="flex-row items-center justify-between mb-2">
                  <Text className="text-sm font-mono" style={{ color: colors.foreground }}>
                    {code}
                  </Text>
                  <TouchableOpacity
                    onPress={() => handleToggleCode(code)}
                    className="px-2 py-1 rounded"
                    style={{ backgroundColor: "#EF4444" }}
                  >
                    <Text className="text-xs font-semibold" style={{ color: "#FFF" }}>
                      Quitar
                    </Text>
                  </TouchableOpacity>
                </View>
              ))}
            </View>
          )}

          {/* Action Buttons */}
          {selectedCodes.length > 0 && (
            <View className="gap-3">
              <TouchableOpacity
                onPress={handleGenerateExceptionList}
                className="bg-primary px-4 py-3 rounded-xl active:opacity-80"
              >
                <Text className="text-center font-semibold" style={{ color: colors.background }}>
                  Generar ExceptionList.txt
                </Text>
              </TouchableOpacity>

              <TouchableOpacity
                onPress={handleGenerateInjectionCommand}
                className="bg-surface px-4 py-3 rounded-xl border active:opacity-80"
                style={{ borderColor: colors.border }}
              >
                <Text className="text-center font-semibold" style={{ color: colors.foreground }}>
                  Ver Comando de Inyecci√≥n
                </Text>
              </TouchableOpacity>

              <TouchableOpacity
                onPress={handleInjectViaTelnet}
                className="px-4 py-3 rounded-xl active:opacity-80"
                style={{ backgroundColor: isConnected ? '#22C55E' : colors.muted + '33' }}
                disabled={!isConnected}
              >
                <Text
                  className="text-center font-semibold text-base"
                  style={{ color: isConnected ? colors.background : colors.muted }}
                >
                  {isConnected ? '‚ö° Inyectar v√≠a Telnet' : 'üîå Conectar Telnet Primero'}
                </Text>
              </TouchableOpacity>
            </View>
          )}
        </View>
      </ScrollView>
    </ScreenContainer>
  );
}

================================================================================
FILE: app/(tabs)/index.tsx
================================================================================

import { View, Text, TouchableOpacity, TextInput, ActivityIndicator, ScrollView, Alert } from "react-native";
import { useState, useEffect } from "react";
import * as Haptics from "expo-haptics";

import { ScreenContainer } from "@/components/screen-container";
import { UsbStatusIndicator } from "@/components/usb-status-indicator";
import { useUsbStatus } from "@/lib/usb-status-context";
import { useTelnet } from "@/lib/telnet-provider";

import { quickScan, scanNetwork, parseSubnet, type ScanResult, type ScanProgress } from "@/lib/network-scanner";
import { detectToolbox, type ToolboxInfo } from "@/lib/toolbox-detector";
import { detectUSBEthernetAdapter, detectSubnet, validateAdapterConnectivity, type NetworkInterface } from "@/modules/network-info";

export default function HomeScreen() {
  const { isConnected, isConnecting, config, updateConfig, connect, disconnect, sendCommand } = useTelnet();
  const { status: usbStatus, device: usbDevice } = useUsbStatus();
  const [host, setHost] = useState(config.host);
  const [port, setPort] = useState(config.port.toString());
  const [scanning, setScanning] = useState(false);
  const [scanProgress, setScanProgress] = useState<ScanProgress | null>(null);
  const [foundDevices, setFoundDevices] = useState<ScanResult[]>([]);
  const [toolboxInfo, setToolboxInfo] = useState<ToolboxInfo | null>(null);
  const [detectingToolbox, setDetectingToolbox] = useState(false);
  const [networkAdapter, setNetworkAdapter] = useState<NetworkInterface | null>(null);
  const [detectedSubnet, setDetectedSubnet] = useState<string>('192.168.1');

  // Detectar adaptador de red autom√°ticamente cuando USB se conecta
  useEffect(() => {
    const detectNetwork = async () => {
      if (usbStatus === 'connected') {
        try {
          const adapter = await detectUSBEthernetAdapter();
          setNetworkAdapter(adapter);
          
          if (adapter) {
            const subnet = await detectSubnet();
            setDetectedSubnet(subnet);
          }
        } catch (error) {
          console.error('Error detecting network adapter:', error);
        }
      } else {
        setNetworkAdapter(null);
        setDetectedSubnet('192.168.1');
      }
    };

    detectNetwork();
  }, [usbStatus]);

  const handleConnect = async () => {
    // Verificar que hay adaptador USB conectado
    if (usbStatus !== 'connected') {
      Alert.alert(
        'Adaptador USB Requerido',
        'Debes conectar un adaptador USB-Ethernet antes de conectarte a la MIB2.\n\n1. Conecta el adaptador USB-Ethernet al puerto USB de la unidad MIB2\n2. Conecta tu dispositivo Android a la misma red (WiFi o adaptador Ethernet)\n3. Ve a la pesta\u00f1a "USB" para verificar la conexi\u00f3n',
        [{ text: 'Entendido' }]
      );
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
      return;
    }

    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    
    // Update config before connecting
    await updateConfig({
      host,
      port: parseInt(port, 10),
    });

    try {
      await connect();
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
      // Auto-detect toolbox
      setTimeout(() => handleDetectToolbox(), 1000);
    } catch (error) {
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
    }
  };

  const handleDetectToolbox = async () => {
    if (!isConnected) return;

    setDetectingToolbox(true);
    try {
      const info = await detectToolbox(async (cmd: string) => {
        sendCommand(cmd);
        return { output: '', success: true };
      });
      setToolboxInfo(info);
    } catch (error) {
      console.error('Error detecting toolbox:', error);
    } finally {
      setDetectingToolbox(false);
    }
  };

  const handleDisconnect = async () => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    await disconnect();
  };

  const handleQuickScan = async () => {
    // Verificar que hay adaptador USB conectado
    if (usbStatus !== 'connected') {
      Alert.alert(
        'Adaptador USB Requerido',
        'Debes conectar un adaptador USB-Ethernet antes de escanear la red.\n\n1. Conecta el adaptador USB-Ethernet al puerto USB de la unidad MIB2\n2. Conecta tu dispositivo Android a la misma red (WiFi o adaptador Ethernet)\n3. Ve a la pesta√±a "USB" para verificar la conexi√≥n',
        [{ text: 'Entendido' }]
      );
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
      return;
    }

    // Validar conectividad REAL del adaptador
    const hasConnectivity = await validateAdapterConnectivity();
    if (!hasConnectivity) {
      Alert.alert(
        'Sin Conectividad',
        'El adaptador USB-Ethernet no tiene una IP v√°lida asignada.\n\nVerifica que:\n1. El adaptador est√© conectado correctamente\n2. La red est√© configurada (DHCP o IP est√°tica)\n3. El adaptador tenga acceso a la red MIB2',
        [{ text: 'Entendido' }]
      );
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
      return;
    }

    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    setScanning(true);
    setFoundDevices([]);

    try {
      const results = await quickScan((progress) => {
        setScanProgress(progress);
      });

      setFoundDevices(results);
      setScanProgress(null);

      if (results.length === 0) {
        Alert.alert('Sin Resultados', 'No se encontraron unidades MIB2 en las IPs comunes');
      } else if (results.length === 1) {
        // Auto-select and connect
        setHost(results[0].host);
        setPort(results[0].port.toString());
        await updateConfig({
          host: results[0].host,
          port: results[0].port,
        });
        Alert.alert(
          '¬°Encontrado!',
          `Unidad MIB2 detectada en ${results[0].host}\n\n¬øConectar autom√°ticamente?`,
          [
            { text: 'Cancelar', style: 'cancel' },
            {
              text: 'Conectar',
              onPress: async () => {
                try {
                  await connect();
                  Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
                  setTimeout(() => handleDetectToolbox(), 1000);
                } catch (error) {
                  Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
                  Alert.alert('Error', 'No se pudo conectar a la unidad MIB2');
                }
              },
            },
          ]
        );
      } else {
        Alert.alert('M√∫ltiples Dispositivos', `Se encontraron ${results.length} dispositivos. Selecciona uno de la lista.`);
      }
    } catch (error) {
      Alert.alert('Error', 'Error al escanear la red');
    } finally {
      setScanning(false);
    }
  };

  const handleFullScan = async () => {
    // Verificar que hay adaptador USB conectado
    if (usbStatus !== 'connected') {
      Alert.alert(
        'Adaptador USB Requerido',
        'Debes conectar un adaptador USB-Ethernet antes de escanear la red.\n\n1. Conecta el adaptador USB-Ethernet al puerto USB de la unidad MIB2\n2. Conecta tu dispositivo Android a la misma red (WiFi o adaptador Ethernet)\n3. Ve a la pesta√±a "USB" para verificar la conexi√≥n',
        [{ text: 'Entendido' }]
      );
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
      return;
    }

    // Validar conectividad REAL del adaptador
    const hasConnectivity = await validateAdapterConnectivity();
    if (!hasConnectivity) {
      Alert.alert(
        'Sin Conectividad',
        'El adaptador USB-Ethernet no tiene una IP v√°lida asignada.\n\nVerifica que:\n1. El adaptador est√© conectado correctamente\n2. La red est√© configurada (DHCP o IP est√°tica)\n3. El adaptador tenga acceso a la red MIB2',
        [{ text: 'Entendido' }]
      );
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
      return;
    }

    Alert.alert(
      'Escaneo Completo',
      'Esto escanear√° toda la subred (puede tardar varios minutos). ¬øContinuar?',
      [
        { text: 'Cancelar', style: 'cancel' },
        {
          text: 'Escanear',
          onPress: async () =>{
            Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
            setScanning(true);
            setFoundDevices([]);

            try {
              const subnet = parseSubnet(host);
              const results = await scanNetwork(subnet, 1, 255, 23, (progress) => {
                setScanProgress(progress);
              });

              setFoundDevices(results);
              setScanProgress(null);

              if (results.length === 0) {
                Alert.alert('Sin Resultados', 'No se encontraron unidades MIB2 en la red');
              } else {
                Alert.alert('Escaneo Completo', `Se encontraron ${results.length} dispositivos`);
              }
            } catch (error) {
              Alert.alert('Error', 'Error al escanear la red');
            } finally {
              setScanning(false);
            }
          },
        },
      ]
    );
  };

  const handleSelectDevice = (device: ScanResult) => {
    setHost(device.host);
    setPort(device.port.toString());
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
  };

  const getStatusColor = () => {
    if (isConnected) return 'bg-success';
    if (isConnecting) return 'bg-warning';
    return 'bg-muted';
  };

  const getStatusText = () => {
    if (isConnected) return 'Conectado';
    if (isConnecting) return 'Conectando...';
    return 'Desconectado';
  };

  return (
    <ScreenContainer className="p-6">
      <ScrollView contentContainerStyle={{ flexGrow: 1 }}>
        <View className="flex-1 gap-6">
          {/* Header */}
          <View className="items-center gap-2">
            <Text className="text-3xl font-bold text-foreground">MIB2 Controller</Text>
            <Text className="text-sm text-muted text-center">
              Control remoto para unidades MIB2 STD2 Technisat Preh
            </Text>
          </View>

          {/* USB Status Indicator - REAL TIME */}
          <UsbStatusIndicator 
            status={usbStatus} 
            deviceName={usbDevice?.product || usbDevice?.deviceName}
          />

          {/* Network Adapter Info */}
          {networkAdapter && (
            <View className="bg-surface rounded-2xl p-4 border border-border">
              <View className="flex-row items-center gap-2 mb-2">
                <View className="w-3 h-3 rounded-full bg-success" />
                <Text className="text-sm font-semibold text-foreground">Adaptador de Red Detectado</Text>
              </View>
              <View className="gap-1">
                <View className="flex-row justify-between">
                  <Text className="text-xs text-muted">Interfaz:</Text>
                  <Text className="text-xs text-foreground font-medium">{networkAdapter.name}</Text>
                </View>
                <View className="flex-row justify-between">
                  <Text className="text-xs text-muted">IP del Adaptador:</Text>
                  <Text className="text-xs text-foreground font-medium">{networkAdapter.ipAddress}</Text>
                </View>
                <View className="flex-row justify-between">
                  <Text className="text-xs text-muted">Subred Detectada:</Text>
                  <Text className="text-xs text-foreground font-medium">{detectedSubnet}.x</Text>
                </View>
              </View>
            </View>
          )}

          {/* Connection Status Card */}
          <View className="bg-surface rounded-2xl p-6 border border-border">
            <View className="flex-row items-center gap-3 mb-4">
              <View className={`w-4 h-4 rounded-full ${getStatusColor()}`} />
              <Text className="text-lg font-semibold text-foreground">{getStatusText()}</Text>
            </View>

            {isConnected && (
              <View className="gap-3">
                <View className="gap-2">
                  <View className="flex-row justify-between">
                    <Text className="text-sm text-muted">Host:</Text>
                    <Text className="text-sm text-foreground font-medium">{config.host}</Text>
                  </View>
                  <View className="flex-row justify-between">
                    <Text className="text-sm text-muted">Puerto:</Text>
                    <Text className="text-sm text-foreground font-medium">{config.port}</Text>
                  </View>
                  {Date.now() && (
                    <View className="flex-row justify-between">
                      <Text className="text-sm text-muted">√öltima actividad:</Text>
                      <Text className="text-sm text-foreground font-medium">
                        {new Date(Date.now()).toLocaleTimeString()}
                      </Text>
                    </View>
                  )}
                </View>

                {/* Firmware Info - REAL */}
                {toolboxInfo && (toolboxInfo.firmwareVersion || toolboxInfo.hardwareVersion) && (
                  <View className="bg-background rounded-lg p-3 mb-3">
                    <View className="flex-row items-center justify-between mb-2">
                      <Text className="text-sm font-semibold text-foreground">Firmware MIB2</Text>
                      <View className={`px-2 py-1 rounded ${
                        toolboxInfo.firmwareCompatible ? 'bg-success/20' : 'bg-warning/20'
                      }`}>
                        <Text className={`text-xs font-semibold ${
                          toolboxInfo.firmwareCompatible ? 'text-success' : 'text-warning'
                        }`}>
                          {toolboxInfo.firmwareCompatible ? '‚úì Compatible' : '‚ö†Ô∏è Telnet Cerrado'}
                        </Text>
                      </View>
                    </View>
                    {toolboxInfo.firmwareVersion && (
                      <View className="flex-row justify-between mb-1">
                        <Text className="text-xs text-muted">Versi√≥n:</Text>
                        <Text className="text-xs text-foreground font-mono">{toolboxInfo.firmwareVersion}</Text>
                      </View>
                    )}
                    {toolboxInfo.hardwareVersion && (
                      <View className="flex-row justify-between">
                        <Text className="text-xs text-muted">Hardware:</Text>
                        <Text className="text-xs text-foreground font-mono">{toolboxInfo.hardwareVersion}</Text>
                      </View>
                    )}
                    {!toolboxInfo.firmwareCompatible && (
                      <Text className="text-xs text-warning mt-2">
                        ‚ö†Ô∏è El puerto Telnet est√° cerrado. Se requiere acceso directo a eMMC.
                      </Text>
                    )}
                  </View>
                )}

                {/* Toolbox Info */}
                {toolboxInfo && (
                  <View className="bg-background rounded-lg p-3">
                    <View className="flex-row items-center justify-between mb-2">
                      <Text className="text-sm font-semibold text-foreground">MIB2 Toolbox</Text>
                      <View className={`px-2 py-1 rounded ${
                        toolboxInfo.installed ? 'bg-success/20' : 'bg-error/20'
                      }`}>
                        <Text className={`text-xs font-semibold ${
                          toolboxInfo.installed ? 'text-success' : 'text-error'
                        }`}>
                          {toolboxInfo.installed ? '‚úì Instalado' : '‚úó No Instalado'}
                        </Text>
                      </View>
                    </View>
                    {toolboxInfo.installed && toolboxInfo.version && (
                      <Text className="text-xs text-muted mb-2">Versi√≥n: {toolboxInfo.version}</Text>
                    )}
                    {toolboxInfo.installed && toolboxInfo.services && (
                      <View className="flex-row gap-2 flex-wrap">
                        <View className={`px-2 py-1 rounded ${
                          toolboxInfo.services.telnet ? 'bg-success/10' : 'bg-muted/10'
                        }`}>
                          <Text className={`text-xs ${
                            toolboxInfo.services.telnet ? 'text-success' : 'text-muted'
                          }`}>
                            Telnet {toolboxInfo.services.telnet ? '‚úì' : '‚úó'}
                          </Text>
                        </View>
                        <View className={`px-2 py-1 rounded ${
                          toolboxInfo.services.ftp ? 'bg-success/10' : 'bg-muted/10'
                        }`}>
                          <Text className={`text-xs ${
                            toolboxInfo.services.ftp ? 'text-success' : 'text-muted'
                          }`}>
                            FTP {toolboxInfo.services.ftp ? '‚úì' : '‚úó'}
                          </Text>
                        </View>
                        <View className={`px-2 py-1 rounded ${
                          toolboxInfo.services.ssh ? 'bg-success/10' : 'bg-muted/10'
                        }`}>
                          <Text className={`text-xs ${
                            toolboxInfo.services.ssh ? 'text-success' : 'text-muted'
                          }`}>
                            SSH {toolboxInfo.services.ssh ? '‚úì' : '‚úó'}
                          </Text>
                        </View>
                      </View>
                    )}
                    {!toolboxInfo.installed && (
                      <Text className="text-xs text-error mt-1">
                        ‚ö†Ô∏è Se recomienda instalar MIB2 Toolbox
                      </Text>
                    )}
                  </View>
                )}

                {!toolboxInfo && !detectingToolbox && (
                  <TouchableOpacity
                    onPress={handleDetectToolbox}
                    className="bg-primary/20 border border-primary px-4 py-2 rounded-lg active:opacity-80"
                  >
                    <Text className="text-primary font-semibold text-center text-sm">
                      üîç Detectar MIB2 Toolbox
                    </Text>
                  </TouchableOpacity>
                )}

                {detectingToolbox && (
                  <View className="bg-primary/10 rounded-lg p-2">
                    <Text className="text-primary text-sm text-center">Detectando Toolbox...</Text>
                  </View>
                )}
              </View>
            )}
          </View>

          {/* Scan Buttons */}
          {!isConnected && !scanning && (
            <View className="flex-row gap-3">
              <TouchableOpacity
                onPress={handleQuickScan}
                className="flex-1 bg-primary/20 border border-primary px-4 py-3 rounded-xl active:opacity-80"
              >
                <Text className="text-primary font-semibold text-center text-sm">
                  üîç B√∫squeda R√°pida
                </Text>
              </TouchableOpacity>
              <TouchableOpacity
                onPress={handleFullScan}
                className="flex-1 bg-muted/20 border border-border px-4 py-3 rounded-xl active:opacity-80"
              >
                <Text className="text-foreground font-semibold text-center text-sm">
                  üåê Escaneo Completo
                </Text>
              </TouchableOpacity>
            </View>
          )}

          {/* Scan Progress */}
          {scanning && scanProgress && (
            <View className="bg-primary/10 border border-primary rounded-xl p-4">
              <View className="flex-row items-center justify-between mb-2">
                <Text className="text-sm font-semibold text-primary">
                  Escaneando red...
                </Text>
                <Text className="text-sm text-primary font-mono">
                  {scanProgress.percentage}%
                </Text>
              </View>
              <View className="bg-background rounded-full h-2 mb-2 overflow-hidden">
                <View
                  className="bg-primary h-full"
                  style={{ width: `${scanProgress.percentage}%` }}
                />
              </View>
              <Text className="text-xs text-muted">
                {scanProgress.currentHost} ({scanProgress.current}/{scanProgress.total})
              </Text>
            </View>
          )}

          {/* Found Devices */}
          {foundDevices.length > 0 && !isConnected && (
            <View className="bg-success/10 border border-success rounded-xl p-4">
              <Text className="text-sm font-semibold text-success mb-3">
                ‚úì Dispositivos Encontrados ({foundDevices.length})
              </Text>
              <View className="gap-2">
                {foundDevices.map((device) => (
                  <TouchableOpacity
                    key={device.host}
                    onPress={() => handleSelectDevice(device)}
                    className="bg-background rounded-lg p-3 border border-border active:opacity-70"
                  >
                    <View className="flex-row items-center justify-between">
                      <View>
                        <Text className="text-sm font-semibold text-foreground">
                          {device.host}:{device.port}
                        </Text>
                        {device.deviceInfo && (
                          <Text className="text-xs text-muted mt-1">
                            {device.deviceInfo}
                          </Text>
                        )}
                      </View>
                      {device.responseTime && (
                        <Text className="text-xs text-muted">
                          {device.responseTime}ms
                        </Text>
                      )}
                    </View>
                  </TouchableOpacity>
                ))}
              </View>
            </View>
          )}

          {/* Connection Form */}
          {!isConnected && !scanning && (
            <View className="gap-4">
              <View>
                <Text className="text-sm font-medium text-foreground mb-2">Direcci√≥n IP</Text>
                <TextInput
                  value={host}
                  onChangeText={setHost}
                  placeholder="192.168.1.4"
                  keyboardType="numeric"
                  className="bg-surface border border-border rounded-xl px-4 py-3 text-foreground"
                  editable={!isConnecting}
                />
              </View>

              <View>
                <Text className="text-sm font-medium text-foreground mb-2">Puerto</Text>
                <TextInput
                  value={port}
                  onChangeText={setPort}
                  placeholder="23"
                  keyboardType="numeric"
                  className="bg-surface border border-border rounded-xl px-4 py-3 text-foreground"
                  editable={!isConnecting}
                />
              </View>
            </View>
          )}

          {/* Action Button */}
          <View className="items-center">
            {isConnected ? (
              <TouchableOpacity
                onPress={handleDisconnect}
                className="bg-error px-8 py-4 rounded-full active:opacity-80 min-w-[200px]"
              >
                <Text className="text-white font-semibold text-center text-base">
                  Desconectar
                </Text>
              </TouchableOpacity>
            ) : (
              <TouchableOpacity
                onPress={handleConnect}
                disabled={isConnecting}
                className="bg-primary px-8 py-4 rounded-full active:opacity-80 min-w-[200px]"
                style={{ opacity: isConnecting ? 0.6 : 1 }}
              >
                {isConnecting ? (
                  <ActivityIndicator color="white" />
                ) : (
                  <Text className="text-white font-semibold text-center text-base">
                    Conectar a MIB2
                  </Text>
                )}
              </TouchableOpacity>
            )}
          </View>

          {/* Info Card */}
          <View className="bg-surface rounded-2xl p-6 border border-border">
            <Text className="text-base font-semibold text-foreground mb-3">
              Instrucciones de Conexi√≥n
            </Text>
            <View className="gap-2">
              <Text className="text-sm text-muted leading-relaxed">
                1. Conecta el adaptador USB-Ethernet al puerto USB de la unidad MIB2
              </Text>
              <Text className="text-sm text-muted leading-relaxed">
                2. Conecta tu dispositivo Android a la misma red (WiFi o adaptador Ethernet)
              </Text>
              <Text className="text-sm text-muted leading-relaxed">
                3. Verifica que la unidad MIB2 tenga Telnet habilitado (root/root)
              </Text>
              <Text className="text-sm text-muted leading-relaxed">
                4. Ingresa la direcci√≥n IP de la unidad (por defecto: 192.168.1.4)
              </Text>
              <Text className="text-sm text-muted leading-relaxed">
                5. Presiona &quot;Conectar a MIB2&quot; para establecer la conexi√≥n
              </Text>
            </View>
          </View>

          {/* Warning Card */}
          <View className="bg-warning/10 border border-warning rounded-2xl p-4">
            <Text className="text-sm text-warning font-medium mb-1">‚ö†Ô∏è Advertencia</Text>
            <Text className="text-xs text-muted leading-relaxed">
              Esta aplicaci√≥n permite ejecutar comandos directamente en la unidad MIB2. 
              Usa con precauci√≥n y solo si sabes lo que est√°s haciendo. Los comandos 
              incorrectos pueden da√±ar el sistema.
            </Text>
          </View>
        </View>
      </ScrollView>
    </ScreenContainer>
  );
}

================================================================================
FILE: app/(tabs)/recovery.tsx
================================================================================

import { View, Text, TouchableOpacity, ScrollView, Alert, RefreshControl } from 'react-native';
import { useState, useEffect } from 'react';
import * as Haptics from 'expo-haptics';
import * as FileSystem from 'expo-file-system/legacy';
import * as Sharing from 'expo-sharing';
import { ScreenContainer } from '@/components/screen-container';
import { useUsbStatus } from '@/lib/usb-status-context';
import { backupService, type EEPROMBackup } from '@/lib/backup-service';
import { usbService } from '@/lib/usb-service';

export default function RecoveryScreen() {
  const { status, device, devices, scanDevices } = useUsbStatus();
  const [backups, setBackups] = useState<EEPROMBackup[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [isRestoring, setIsRestoring] = useState(false);
  const [refreshing, setRefreshing] = useState(false);

  // Cargar backups disponibles
  useEffect(() => {
    loadBackups();
  }, []);

  const loadBackups = async () => {
    try {
      const availableBackups = await backupService.loadBackups();
      setBackups(availableBackups);
    } catch (error) {
      console.error('[Recovery] Error loading backups:', error);
    }
  };

  const onRefresh = async () => {
    setRefreshing(true);
    await Promise.all([scanDevices(), loadBackups()]);
    setRefreshing(false);
  };

  const isBricked = (): boolean => {
    if (!device) return false;
    
    // Detectar adaptador brickeado:
    // 1. VID/PID no es ni el original ni el objetivo
    // 2. VID/PID es 0x0000:0x0000 (corrupto)
    const isZero = device.vendorId === 0 && device.productId === 0;
    const isTarget = device.vendorId === 0x2001 && device.productId === 0x3C05;
    const isKnownASIX = device.vendorId === 0x0B95;
    
    return isZero || (!isTarget && !isKnownASIX);
  };

  const handleRestore = async (backup: EEPROMBackup) => {
    if (!device) {
      Alert.alert('Error', 'No hay dispositivo USB conectado');
      return;
    }

    Alert.alert(
      '‚ö†Ô∏è Restaurar EEPROM',
      `¬øEst√°s seguro de que deseas restaurar este backup?\\n\\n` +
      `üíæ Backup: ${backup.deviceName}\\n` +
      `üìÖ Fecha: ${new Date(backup.timestamp).toLocaleString('es-ES')}\\n` +
      `üîß Chipset: ${backup.chipset}\\n\\n` +
      `Esta operaci√≥n sobrescribir√° la EEPROM actual del adaptador.`,
      [
        { text: 'Cancelar', style: 'cancel' },
        {
          text: 'Restaurar',
          style: 'destructive',
          onPress: () => performRestore(backup),
        },
      ]
    );
  };

  const performRestore = async (backup: EEPROMBackup) => {
    setIsRestoring(true);
    try {
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Heavy);
      
      // Escribir EEPROM completa desde backup
      await usbService.writeEEPROM(0, backup.data);
      
      await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
      Alert.alert(
        '‚úÖ Restauraci√≥n Exitosa',
        `La EEPROM se restaur√≥ correctamente desde el backup.\\n\\n` +
        `üìä Bytes escritos: ${backup.size}\\n` +
        `üîí Checksum: ${backup.checksum.substring(0, 8)}...\\n\\n` +
        `Desconecta y vuelve a conectar el adaptador para que los cambios surtan efecto.`
      );
    } catch (error: any) {
      await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
      Alert.alert(
        '‚ùå Error al Restaurar',
        error.message || 'No se pudo restaurar la EEPROM desde el backup'
      );
    } finally {
      setIsRestoring(false);
    }
  };

  const handleForceRestore = async (backup: EEPROMBackup) => {
    Alert.alert(
      'üö® Modo de Recuperaci√≥n Forzada',
      `Este modo intenta restaurar la EEPROM sin validaciones de seguridad.\\n\\n` +
      `‚ö†Ô∏è ADVERTENCIAS:\\n` +
      `‚Ä¢ Puede da√±ar permanentemente el adaptador\\n` +
      `‚Ä¢ No se verificar√° compatibilidad\\n` +
      `‚Ä¢ No se crear√° backup previo\\n\\n` +
      `Usa esta opci√≥n SOLO si el adaptador no responde a m√©todos normales.\\n\\n` +
      `¬øDeseas continuar?`,
      [
        { text: 'Cancelar', style: 'cancel' },
        {
          text: 'Forzar Restauraci√≥n',
          style: 'destructive',
          onPress: () => performRestore(backup),
        },
      ]
    );
  };

  const brickedStatus = isBricked();

  return (
    <ScreenContainer className="p-6">
      <ScrollView
        contentContainerStyle={{ flexGrow: 1 }}
        refreshControl={
          <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
        }
      >
        <View className="gap-6">
          {/* Header */}
          <View>
            <Text className="text-3xl font-bold text-foreground">üõ†Ô∏è Recuperaci√≥n</Text>
            <Text className="text-base text-muted mt-2">
              Restaura adaptadores USB brickeados desde backups
            </Text>
          </View>

          {/* Estado del Dispositivo */}
          <View className={`rounded-2xl p-6 border ${
            status === 'connected' && brickedStatus ? 'bg-error/10 border-error' :
            status === 'connected' ? 'bg-success/10 border-success' :
            status === 'detected' ? 'bg-warning/10 border-warning' :
            'bg-surface border-border'
          }`}>
            <View className="flex-row items-center gap-3 mb-4">
              <Text className="text-4xl">
                {status === 'connected' && brickedStatus ? 'üö®' :
                 status === 'connected' ? '‚úÖ' :
                 status === 'detected' ? '‚ö†Ô∏è' :
                 '‚ùå'}
              </Text>
              <View className="flex-1">
                <Text className="text-lg font-semibold text-foreground">
                  {status === 'connected' && brickedStatus ? 'Adaptador Brickeado Detectado' :
                   status === 'connected' ? 'Adaptador Conectado' :
                   status === 'detected' ? 'Dispositivo Detectado' :
                   'Sin Dispositivo'}
                </Text>
                <Text className="text-sm text-muted mt-1">
                  {status === 'connected' && brickedStatus ? 'El adaptador tiene VID/PID corrupto o incorrecto' :
                   status === 'connected' ? 'El adaptador est√° funcionando correctamente' :
                   status === 'detected' ? 'Conecta el dispositivo para verificar estado' :
                   'Conecta un adaptador USB con cable OTG'}
                </Text>
              </View>
            </View>

            {device && (
              <View className="bg-background rounded-xl p-4 gap-2">
                <View className="flex-row justify-between">
                  <Text className="text-sm text-muted">Dispositivo:</Text>
                  <Text className="text-sm text-foreground font-medium">{device.deviceName}</Text>
                </View>
                <View className="flex-row justify-between">
                  <Text className="text-sm text-muted">VID:PID:</Text>
                  <Text className={`text-sm font-mono font-medium ${
                    brickedStatus ? 'text-error' : 'text-success'
                  }`}>
                    0x{device.vendorId.toString(16).toUpperCase().padStart(4, '0')}:0x{device.productId.toString(16).toUpperCase().padStart(4, '0')}
                  </Text>
                </View>
                <View className="flex-row justify-between">
                  <Text className="text-sm text-muted">Chipset:</Text>
                  <Text className="text-sm text-foreground font-medium">{device.chipset}</Text>
                </View>
              </View>
            )}
          </View>

          {/* Backups Disponibles */}
          <View className="bg-surface rounded-2xl p-6 border border-border">
            <View className="flex-row justify-between items-center mb-4">
              <Text className="text-lg font-semibold text-foreground">
                üíæ Backups Disponibles ({backups.length})
              </Text>
              <TouchableOpacity
                onPress={async () => {
                  await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
                  const backupPath = `${FileSystem.documentDirectory}Download/mib2_backups/`;
                  Alert.alert(
                    'üìÇ Ubicaci√≥n de Backups',
                    `Los backups se guardan en:\n\n` +
                    `Android/data/[app]/files/Download/mib2_backups/\n\n` +
                    `Para acceder:\n` +
                    `1. Abre "Archivos" o "Mis Archivos"\n` +
                    `2. Navega a: Android ‚Üí data ‚Üí [nombre_app]\n` +
                    `3. Entra en: files ‚Üí Download ‚Üí mib2_backups\n\n` +
                    `Nota: En Android 11+ necesitas habilitar "Mostrar archivos ocultos" para ver la carpeta Android/data.`,
                    [
                      { text: 'Entendido', style: 'default' },
                    ]
                  );
                }}
                className="bg-primary/10 px-3 py-2 rounded-lg active:opacity-80"
              >
                <Text className="text-xs text-primary font-semibold">
                  üìÇ Ver Ubicaci√≥n
                </Text>
              </TouchableOpacity>
            </View>

            {backups.length === 0 ? (
              <View className="items-center py-8">
                <Text className="text-4xl mb-3">üì¶</Text>
                <Text className="text-sm text-muted text-center">
                  No hay backups disponibles.{'\n'}
                  Crea un backup antes de modificar adaptadores.
                </Text>
              </View>
            ) : (
              <View className="gap-3">
                {backups.map((backup) => (
                  <View
                    key={backup.id}
                    className="bg-background rounded-xl p-4 border border-border"
                  >
                    <View className="flex-row justify-between items-start mb-3">
                      <View className="flex-1">
                        <Text className="text-sm font-semibold text-foreground">
                          {backup.deviceName}
                        </Text>
                        <Text className="text-xs text-muted mt-1">
                          {new Date(backup.timestamp).toLocaleString('es-ES')}
                        </Text>
                      </View>
                      <View className="bg-primary/10 px-3 py-1 rounded-full">
                        <Text className="text-xs text-primary font-medium">
                          {backup.chipset}
                        </Text>
                      </View>
                    </View>

                    <View className="gap-2 mb-3">
                      <View className="flex-row justify-between">
                        <Text className="text-xs text-muted">VID:PID Original:</Text>
                        <Text className="text-xs text-foreground font-mono">
                          0x{backup.vendorId.toString(16).toUpperCase().padStart(4, '0')}:0x{backup.productId.toString(16).toUpperCase().padStart(4, '0')}
                        </Text>
                      </View>
                      <View className="flex-row justify-between">
                        <Text className="text-xs text-muted">Tama√±o:</Text>
                        <Text className="text-xs text-foreground">{backup.size} bytes</Text>
                      </View>
                      <View className="flex-row justify-between">
                        <Text className="text-xs text-muted">Checksum:</Text>
                        <Text className="text-xs text-foreground font-mono">
                          {backup.checksum.substring(0, 16)}...
                        </Text>
                      </View>
                    </View>

                    <View className="flex-row gap-2 mb-2">
                      <TouchableOpacity
                        onPress={() => handleRestore(backup)}
                        disabled={status !== 'connected' || isRestoring}
                        className={`flex-1 rounded-xl p-3 ${
                          status !== 'connected' || isRestoring
                            ? 'bg-muted/20'
                            : 'bg-primary active:opacity-80'
                        }`}
                      >
                        <Text
                          className={`text-center font-semibold text-sm ${
                            status !== 'connected' || isRestoring
                              ? 'text-muted'
                              : 'text-background'
                          }`}
                        >
                          {isRestoring ? '‚è≥ Restaurando...' : 'üîÑ Restaurar'}
                        </Text>
                      </TouchableOpacity>

                      <TouchableOpacity
                        onPress={() => handleForceRestore(backup)}
                        disabled={status !== 'connected' || isRestoring}
                        className={`flex-1 rounded-xl p-3 border ${
                          status !== 'connected' || isRestoring
                            ? 'bg-muted/20 border-muted'
                            : 'bg-error/10 border-error active:opacity-80'
                        }`}
                      >
                        <Text
                          className={`text-center font-semibold text-sm ${
                            status !== 'connected' || isRestoring
                              ? 'text-muted'
                              : 'text-error'
                          }`}
                        >
                          {isRestoring ? '‚è≥ Forzando...' : '‚ö†Ô∏è Forzar'}
                        </Text>
                      </TouchableOpacity>
                    </View>

                    <TouchableOpacity
                      onPress={async () => {
                        try {
                          await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
                          
                          if (!backup.filepath) {
                            Alert.alert('‚ùå Error', 'No se encontr√≥ la ruta del archivo de backup');
                            return;
                          }

                          // Verificar que el archivo existe
                          const fileInfo = await FileSystem.getInfoAsync(backup.filepath);
                          if (!fileInfo.exists) {
                            Alert.alert('‚ùå Error', 'El archivo de backup no existe en el sistema');
                            return;
                          }

                          // Verificar si se puede compartir
                          const canShare = await Sharing.isAvailableAsync();
                          if (!canShare) {
                            Alert.alert('‚ùå Error', 'La funci√≥n de compartir no est√° disponible en este dispositivo');
                            return;
                          }

                          // Compartir archivo
                          await Sharing.shareAsync(backup.filepath, {
                            mimeType: 'application/octet-stream',
                            dialogTitle: `Compartir Backup - ${backup.deviceName}`,
                          });

                          await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
                        } catch (error: any) {
                          await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
                          Alert.alert('‚ùå Error', `No se pudo compartir el backup:\n${error.message}`);
                        }
                      }}
                      disabled={isRestoring}
                      className={`w-full rounded-xl p-3 border ${
                        isRestoring
                          ? 'bg-muted/20 border-muted'
                          : 'bg-green-500/10 border-green-500/30 active:opacity-80'
                      }`}
                    >
                      <Text
                        className={`text-center font-semibold text-sm ${
                          isRestoring ? 'text-muted' : 'text-green-400'
                        }`}
                      >
                        üì§ Compartir Backup
                      </Text>
                    </TouchableOpacity>
                  </View>
                ))}
              </View>
            )}
          </View>

          {/* Instrucciones */}
          <View className="bg-warning/10 border border-warning rounded-2xl p-4">
            <Text className="text-sm text-warning font-semibold mb-2">
              üí° Instrucciones de Recuperaci√≥n
            </Text>
            <Text className="text-xs text-muted leading-relaxed">
              1. Conecta el adaptador brickeado con cable OTG{'\n'}
              2. Verifica que aparezca como &quot;Brickeado&quot; arriba{'\n'}
              3. Selecciona un backup compatible (mismo chipset){'\n'}
              4. Toca &quot;Restaurar&quot; y confirma la operaci√≥n{'\n'}
              5. Desconecta y reconecta el adaptador{'\n'}
              6. Verifica que el VID/PID se haya restaurado{'\n\n'}
              Si el m√©todo normal no funciona, usa &quot;Forzar&quot; como √∫ltimo recurso.
            </Text>
          </View>
        </View>
      </ScrollView>
    </ScreenContainer>
  );
}

================================================================================
FILE: app/(tabs)/settings.tsx
================================================================================

import { View, Text, TouchableOpacity, ScrollView, TextInput, Alert, Switch } from "react-native";
import { useState } from "react";
import * as Haptics from "expo-haptics";

import { ScreenContainer } from "@/components/screen-container";
import { useTelnet } from "@/lib/telnet-provider";
import { useExpertMode } from "@/lib/expert-mode-provider";
import { useUsbStatus } from "@/lib/usb-status-context";
import { usbService } from "@/lib/usb-service";
import * as Clipboard from 'expo-clipboard';

export default function SettingsScreen() {
  const { config, updateConfig, clearMessages } = useTelnet();
  const { isExpertMode, isPinSet, enableExpertMode, disableExpertMode, setPin, changePin, resetPin } = useExpertMode();
  
  const [host, setHost] = useState(config.host);
  const [port, setPort] = useState(config.port.toString());
  const [username, setUsername] = useState(config.username);
  const [password, setPassword] = useState(config.password);

  const [showPinSetup, setShowPinSetup] = useState(false);
  const [showPinEntry, setShowPinEntry] = useState(false);
  const [showPinChange, setShowPinChange] = useState(false);
  const [pinInput, setPinInput] = useState('');
  const [pinConfirm, setPinConfirm] = useState('');
  const [oldPinInput, setOldPinInput] = useState('');
  const [showDebugInfo, setShowDebugInfo] = useState(false);
  const { status, device, devices } = useUsbStatus();

  const handleSaveSettings = async () => {
    try {
      await updateConfig({
        host,
        port: parseInt(port, 10),
        username,
        password,
      });

      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
      Alert.alert('√âxito', 'Configuraci√≥n guardada correctamente');
    } catch (error) {
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
      Alert.alert('Error', 'No se pudo guardar la configuraci√≥n');
    }
  };

  const handleResetDefaults = () => {
    Alert.alert(
      'Restablecer Valores',
      '¬øRestaurar la configuraci√≥n a los valores por defecto?',
      [
        { text: 'Cancelar', style: 'cancel' },
        {
          text: 'Restablecer',
          style: 'destructive',
          onPress: () => {
            setHost('192.168.1.4');
            setPort('23');
            setUsername('root');
            setPassword('root');
            Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
          },
        },
      ]
    );
  };

  const handleSetupPin = async () => {
    if (pinInput.length < 4) {
      Alert.alert('PIN Inv√°lido', 'El PIN debe tener al menos 4 d√≠gitos');
      return;
    }

    if (pinInput !== pinConfirm) {
      Alert.alert('Error', 'Los PINs no coinciden');
      return;
    }

    try {
      await setPin(pinInput);
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
      Alert.alert('√âxito', 'PIN configurado correctamente');
      setShowPinSetup(false);
      setPinInput('');
      setPinConfirm('');
    } catch (error) {
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
      Alert.alert('Error', error instanceof Error ? error.message : 'Error al configurar PIN');
    }
  };

  const handleToggleExpertMode = async () => {
    if (isExpertMode) {
      // Disable expert mode
      await disableExpertMode();
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
      Alert.alert('Modo Experto Desactivado', 'Los comandos avanzados est√°n ahora ocultos');
    } else {
      // Enable expert mode - requires PIN
      if (!isPinSet) {
        Alert.alert(
          'Configurar PIN',
          'Primero debes configurar un PIN de seguridad para usar el Modo Experto',
          [
            { text: 'Cancelar', style: 'cancel' },
            { text: 'Configurar PIN', onPress: () => setShowPinSetup(true) },
          ]
        );
      } else {
        setShowPinEntry(true);
      }
    }
  };

  const handleEnableExpertMode = async () => {
    if (pinInput.length < 4) {
      Alert.alert('PIN Inv√°lido', 'Ingresa tu PIN de seguridad');
      return;
    }

    const success = await enableExpertMode(pinInput);
    
    if (success) {
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
      Alert.alert('Modo Experto Activado', 'Ahora tienes acceso a comandos avanzados');
      setShowPinEntry(false);
      setPinInput('');
    } else {
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
      Alert.alert('PIN Incorrecto', 'El PIN ingresado no es v√°lido');
      setPinInput('');
    }
  };

  const handleChangePin = async () => {
    if (oldPinInput.length < 4 || pinInput.length < 4) {
      Alert.alert('PIN Inv√°lido', 'Los PINs deben tener al menos 4 d√≠gitos');
      return;
    }

    if (pinInput !== pinConfirm) {
      Alert.alert('Error', 'Los nuevos PINs no coinciden');
      return;
    }

    const success = await changePin(oldPinInput, pinInput);
    
    if (success) {
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
      Alert.alert('√âxito', 'PIN cambiado correctamente');
      setShowPinChange(false);
      setOldPinInput('');
      setPinInput('');
      setPinConfirm('');
    } else {
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
      Alert.alert('Error', 'El PIN actual es incorrecto');
      setOldPinInput('');
    }
  };

  const handleResetPin = () => {
    Alert.alert(
      'Restablecer PIN',
      '¬øEst√°s seguro? Esto desactivar√° el Modo Experto y eliminar√° el PIN configurado.',
      [
        { text: 'Cancelar', style: 'cancel' },
        {
          text: 'Restablecer',
          style: 'destructive',
          onPress: async () => {
            await resetPin();
            Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
            Alert.alert('PIN Restablecido', 'El PIN ha sido eliminado');
          },
        },
      ]
    );
  };

  return (
    <ScreenContainer className="p-6">
      <ScrollView contentContainerStyle={{ flexGrow: 1 }}>
        <View className="flex-1 gap-6">
          {/* Header */}
          <View>
            <Text className="text-2xl font-bold text-foreground">Configuraci√≥n</Text>
            <Text className="text-sm text-muted mt-1">
              Ajusta los par√°metros de la aplicaci√≥n
            </Text>
          </View>

          {/* Expert Mode Section */}
          <View className="bg-surface rounded-2xl p-6 border border-border">
            <View className="flex-row items-center justify-between mb-4">
              <View className="flex-1 mr-4">
                <Text className="text-lg font-semibold text-foreground">
                  Modo Experto
                </Text>
                <Text className="text-xs text-muted mt-1">
                  Desbloquea comandos avanzados y peligrosos
                </Text>
              </View>
              <Switch
                value={isExpertMode}
                onValueChange={handleToggleExpertMode}
                trackColor={{ false: '#767577', true: '#0066CC' }}
                thumbColor={isExpertMode ? '#ffffff' : '#f4f3f4'}
              />
            </View>

            {isExpertMode && (
              <View className="bg-error/10 border border-error rounded-lg p-3 mb-4">
                <Text className="text-error text-xs font-semibold">
                  ‚ö†Ô∏è MODO EXPERTO ACTIVO
                </Text>
                <Text className="text-error text-xs mt-1">
                  Tienes acceso a comandos que pueden da√±ar la unidad MIB2. Procede con extrema precauci√≥n.
                </Text>
              </View>
            )}

            {isPinSet ? (
              <View className="gap-2">
                <TouchableOpacity
                  onPress={() => setShowPinChange(true)}
                  className="bg-primary/20 border border-primary px-4 py-3 rounded-xl active:opacity-80"
                >
                  <Text className="text-primary font-semibold text-center">
                    Cambiar PIN
                  </Text>
                </TouchableOpacity>
                <TouchableOpacity
                  onPress={handleResetPin}
                  className="bg-error/20 border border-error px-4 py-3 rounded-xl active:opacity-80"
                >
                  <Text className="text-error font-semibold text-center">
                    Restablecer PIN
                  </Text>
                </TouchableOpacity>
              </View>
            ) : (
              <TouchableOpacity
                onPress={() => setShowPinSetup(true)}
                className="bg-primary px-4 py-3 rounded-xl active:opacity-80"
              >
                <Text className="text-white font-semibold text-center">
                  Configurar PIN de Seguridad
                </Text>
              </TouchableOpacity>
            )}
          </View>

          {/* PIN Setup Modal */}
          {showPinSetup && (
            <View className="bg-primary/10 border border-primary rounded-2xl p-6">
              <Text className="text-lg font-semibold text-foreground mb-4">
                Configurar PIN de Seguridad
              </Text>
              <View className="gap-4">
                <View>
                  <Text className="text-sm font-medium text-foreground mb-2">
                    Nuevo PIN (m√≠nimo 4 d√≠gitos)
                  </Text>
                  <TextInput
                    value={pinInput}
                    onChangeText={setPinInput}
                    placeholder="****"
                    secureTextEntry
                    keyboardType="numeric"
                    maxLength={8}
                    className="bg-background border border-border rounded-xl px-4 py-3 text-foreground"
                  />
                </View>
                <View>
                  <Text className="text-sm font-medium text-foreground mb-2">
                    Confirmar PIN
                  </Text>
                  <TextInput
                    value={pinConfirm}
                    onChangeText={setPinConfirm}
                    placeholder="****"
                    secureTextEntry
                    keyboardType="numeric"
                    maxLength={8}
                    className="bg-background border border-border rounded-xl px-4 py-3 text-foreground"
                  />
                </View>
                <View className="flex-row gap-3">
                  <TouchableOpacity
                    onPress={() => {
                      setShowPinSetup(false);
                      setPinInput('');
                      setPinConfirm('');
                    }}
                    className="flex-1 bg-muted/20 border border-border px-4 py-3 rounded-xl active:opacity-80"
                  >
                    <Text className="text-foreground font-semibold text-center">
                      Cancelar
                    </Text>
                  </TouchableOpacity>
                  <TouchableOpacity
                    onPress={handleSetupPin}
                    className="flex-1 bg-primary px-4 py-3 rounded-xl active:opacity-80"
                  >
                    <Text className="text-white font-semibold text-center">
                      Guardar PIN
                    </Text>
                  </TouchableOpacity>
                </View>
              </View>
            </View>
          )}

          {/* PIN Entry Modal */}
          {showPinEntry && (
            <View className="bg-primary/10 border border-primary rounded-2xl p-6">
              <Text className="text-lg font-semibold text-foreground mb-4">
                Ingresar PIN
              </Text>
              <View className="gap-4">
                <View>
                  <Text className="text-sm font-medium text-foreground mb-2">
                    PIN de Seguridad
                  </Text>
                  <TextInput
                    value={pinInput}
                    onChangeText={setPinInput}
                    placeholder="****"
                    secureTextEntry
                    keyboardType="numeric"
                    maxLength={8}
                    className="bg-background border border-border rounded-xl px-4 py-3 text-foreground"
                  />
                </View>
                <View className="flex-row gap-3">
                  <TouchableOpacity
                    onPress={() => {
                      setShowPinEntry(false);
                      setPinInput('');
                    }}
                    className="flex-1 bg-muted/20 border border-border px-4 py-3 rounded-xl active:opacity-80"
                  >
                    <Text className="text-foreground font-semibold text-center">
                      Cancelar
                    </Text>
                  </TouchableOpacity>
                  <TouchableOpacity
                    onPress={handleEnableExpertMode}
                    className="flex-1 bg-primary px-4 py-3 rounded-xl active:opacity-80"
                  >
                    <Text className="text-white font-semibold text-center">
                      Activar
                    </Text>
                  </TouchableOpacity>
                </View>
              </View>
            </View>
          )}

          {/* PIN Change Modal */}
          {showPinChange && (
            <View className="bg-primary/10 border border-primary rounded-2xl p-6">
              <Text className="text-lg font-semibold text-foreground mb-4">
                Cambiar PIN
              </Text>
              <View className="gap-4">
                <View>
                  <Text className="text-sm font-medium text-foreground mb-2">
                    PIN Actual
                  </Text>
                  <TextInput
                    value={oldPinInput}
                    onChangeText={setOldPinInput}
                    placeholder="****"
                    secureTextEntry
                    keyboardType="numeric"
                    maxLength={8}
                    className="bg-background border border-border rounded-xl px-4 py-3 text-foreground"
                  />
                </View>
                <View>
                  <Text className="text-sm font-medium text-foreground mb-2">
                    Nuevo PIN
                  </Text>
                  <TextInput
                    value={pinInput}
                    onChangeText={setPinInput}
                    placeholder="****"
                    secureTextEntry
                    keyboardType="numeric"
                    maxLength={8}
                    className="bg-background border border-border rounded-xl px-4 py-3 text-foreground"
                  />
                </View>
                <View>
                  <Text className="text-sm font-medium text-foreground mb-2">
                    Confirmar Nuevo PIN
                  </Text>
                  <TextInput
                    value={pinConfirm}
                    onChangeText={setPinConfirm}
                    placeholder="****"
                    secureTextEntry
                    keyboardType="numeric"
                    maxLength={8}
                    className="bg-background border border-border rounded-xl px-4 py-3 text-foreground"
                  />
                </View>
                <View className="flex-row gap-3">
                  <TouchableOpacity
                    onPress={() => {
                      setShowPinChange(false);
                      setOldPinInput('');
                      setPinInput('');
                      setPinConfirm('');
                    }}
                    className="flex-1 bg-muted/20 border border-border px-4 py-3 rounded-xl active:opacity-80"
                  >
                    <Text className="text-foreground font-semibold text-center">
                      Cancelar
                    </Text>
                  </TouchableOpacity>
                  <TouchableOpacity
                    onPress={handleChangePin}
                    className="flex-1 bg-primary px-4 py-3 rounded-xl active:opacity-80"
                  >
                    <Text className="text-white font-semibold text-center">
                      Cambiar
                    </Text>
                  </TouchableOpacity>
                </View>
              </View>
            </View>
          )}

          {/* Connection Settings */}
          <View className="bg-surface rounded-2xl p-6 border border-border">
            <Text className="text-lg font-semibold text-foreground mb-4">
              Configuraci√≥n de Conexi√≥n
            </Text>

            <View className="gap-4">
              <View>
                <Text className="text-sm font-medium text-foreground mb-2">
                  Direcci√≥n IP
                </Text>
                <TextInput
                  value={host}
                  onChangeText={setHost}
                  placeholder="192.168.1.4"
                  keyboardType="numeric"
                  className="bg-background border border-border rounded-xl px-4 py-3 text-foreground"
                />
                <Text className="text-xs text-muted mt-1">
                  Direcci√≥n IP de la unidad MIB2 en la red local
                </Text>
              </View>

              <View>
                <Text className="text-sm font-medium text-foreground mb-2">
                  Puerto
                </Text>
                <TextInput
                  value={port}
                  onChangeText={setPort}
                  placeholder="23"
                  keyboardType="numeric"
                  className="bg-background border border-border rounded-xl px-4 py-3 text-foreground"
                />
                <Text className="text-xs text-muted mt-1">
                  Puerto Telnet (por defecto: 23)
                </Text>
              </View>

              <View>
                <Text className="text-sm font-medium text-foreground mb-2">
                  Usuario
                </Text>
                <TextInput
                  value={username}
                  onChangeText={setUsername}
                  placeholder="root"
                  autoCapitalize="none"
                  className="bg-background border border-border rounded-xl px-4 py-3 text-foreground"
                />
                <Text className="text-xs text-muted mt-1">
                  Usuario para autenticaci√≥n Telnet
                </Text>
              </View>

              <View>
                <Text className="text-sm font-medium text-foreground mb-2">
                  Contrase√±a
                </Text>
                <TextInput
                  value={password}
                  onChangeText={setPassword}
                  placeholder="root"
                  secureTextEntry
                  autoCapitalize="none"
                  className="bg-background border border-border rounded-xl px-4 py-3 text-foreground"
                />
                <Text className="text-xs text-muted mt-1">
                  Contrase√±a para autenticaci√≥n Telnet
                </Text>
              </View>
            </View>

            <View className="flex-row gap-3 mt-6">
              <TouchableOpacity
                onPress={handleResetDefaults}
                className="flex-1 bg-muted/20 border border-border px-4 py-3 rounded-xl active:opacity-80"
              >
                <Text className="text-foreground font-semibold text-center">
                  Restablecer
                </Text>
              </TouchableOpacity>
              <TouchableOpacity
                onPress={handleSaveSettings}
                className="flex-1 bg-primary px-4 py-3 rounded-xl active:opacity-80"
              >
                <Text className="text-white font-semibold text-center">
                  Guardar
                </Text>
              </TouchableOpacity>
            </View>
          </View>

          {/* Data Management */}
          <View className="bg-surface rounded-2xl p-6 border border-border">
            <Text className="text-lg font-semibold text-foreground mb-4">
              Gesti√≥n de Datos
            </Text>

            <TouchableOpacity
              onPress={() => {
                Alert.alert(
                  'Limpiar Historial',
                  '¬øEliminar todo el historial de comandos?',
                  [
                    { text: 'Cancelar', style: 'cancel' },
                    {
                      text: 'Limpiar',
                      style: 'destructive',
                      onPress: () => {
                        clearMessages();
                        Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
                        Alert.alert('√âxito', 'Historial eliminado');
                      },
                    },
                  ]
                );
              }}
              className="bg-error/10 border border-error px-4 py-3 rounded-xl active:opacity-80"
            >
              <Text className="text-error font-semibold text-center">
                Limpiar Historial de Comandos
              </Text>
            </TouchableOpacity>
          </View>

          {/* USB Debug Mode */}
          <View className="bg-surface rounded-2xl p-6 border border-border">
            <TouchableOpacity
              onPress={() => {
                setShowDebugInfo(!showDebugInfo);
                Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
              }}
              className="flex-row justify-between items-center mb-4"
            >
              <Text className="text-lg font-semibold text-foreground">
                üîß Modo Debug USB
              </Text>
              <Text className="text-2xl text-muted">
                {showDebugInfo ? '‚ñº' : '‚ñ∂'}
              </Text>
            </TouchableOpacity>

            {showDebugInfo && (
              <View className="gap-4">
                {/* Estado de Conexi√≥n */}
                <View className="bg-background rounded-xl p-4">
                  <Text className="text-sm font-semibold text-foreground mb-3">
                    üîå Estado de Conexi√≥n
                  </Text>
                  <View className="gap-2">
                    <View className="flex-row justify-between">
                      <Text className="text-xs text-muted">Estado:</Text>
                      <Text className={`text-xs font-medium ${
                        status === 'connected' ? 'text-success' :
                        status === 'detected' ? 'text-warning' :
                        'text-muted'
                      }`}>
                        {status === 'connected' ? 'CONECTADO' :
                         status === 'detected' ? 'DETECTADO' :
                         'DESCONECTADO'}
                      </Text>
                    </View>
                    <View className="flex-row justify-between">
                      <Text className="text-xs text-muted">Dispositivos detectados:</Text>
                      <Text className="text-xs text-foreground font-medium">{devices.length}</Text>
                    </View>
                  </View>
                </View>

                {/* Informaci√≥n del Dispositivo */}
                {device && (
                  <View className="bg-background rounded-xl p-4">
                    <Text className="text-sm font-semibold text-foreground mb-3">
                      üì± Dispositivo Actual
                    </Text>
                    <View className="gap-2">
                      <View className="flex-row justify-between">
                        <Text className="text-xs text-muted">Device ID:</Text>
                        <Text className="text-xs text-foreground font-mono">{device.deviceId}</Text>
                      </View>
                      <View className="flex-row justify-between">
                        <Text className="text-xs text-muted">VID:PID:</Text>
                        <Text className="text-xs text-foreground font-mono">
                          0x{device.vendorId.toString(16).toUpperCase().padStart(4, '0')}:0x{device.productId.toString(16).toUpperCase().padStart(4, '0')}
                        </Text>
                      </View>
                      <View className="flex-row justify-between">
                        <Text className="text-xs text-muted">Chipset:</Text>
                        <Text className="text-xs text-foreground font-medium">{device.chipset}</Text>
                      </View>
                      <View className="flex-row justify-between">
                        <Text className="text-xs text-muted">Fabricante:</Text>
                        <Text className="text-xs text-foreground">{device.manufacturer}</Text>
                      </View>
                      <View className="flex-row justify-between">
                        <Text className="text-xs text-muted">Producto:</Text>
                        <Text className="text-xs text-foreground">{device.product}</Text>
                      </View>
                      <View className="flex-row justify-between">
                        <Text className="text-xs text-muted">Serial:</Text>
                        <Text className="text-xs text-foreground font-mono">{device.serialNumber}</Text>
                      </View>
                    </View>
                  </View>
                )}

                {/* Informaci√≥n T√©cnica */}
                <View className="bg-background rounded-xl p-4">
                  <Text className="text-sm font-semibold text-foreground mb-3">
                    ‚öôÔ∏è Informaci√≥n T√©cnica
                  </Text>
                  <View className="gap-2">
                    <View className="flex-row justify-between">
                      <Text className="text-xs text-muted">M√≥dulo Nativo:</Text>
                      <Text className="text-xs text-success font-medium">ACTIVO</Text>
                    </View>
                    <View className="flex-row justify-between">
                      <Text className="text-xs text-muted">Magic Value:</Text>
                      <Text className="text-xs text-foreground font-mono">0xDEADBEEF</Text>
                    </View>
                    <View className="flex-row justify-between">
                      <Text className="text-xs text-muted">EEPROM Size:</Text>
                      <Text className="text-xs text-foreground font-mono">256 bytes</Text>
                    </View>
                    <View className="flex-row justify-between">
                      <Text className="text-xs text-muted">VID Offset:</Text>
                      <Text className="text-xs text-foreground font-mono">0x88</Text>
                    </View>
                    <View className="flex-row justify-between">
                      <Text className="text-xs text-muted">PID Offset:</Text>
                      <Text className="text-xs text-foreground font-mono">0x8A</Text>
                    </View>
                  </View>
                </View>

                {/* Bot√≥n Copiar Info */}
                <TouchableOpacity
                  onPress={async () => {
                    const debugInfo = `=== MIB2 Controller Debug Info ===\n\n` +
                      `Estado: ${status}\n` +
                      `Dispositivos: ${devices.length}\n\n` +
                      (device ? (
                        `Device ID: ${device.deviceId}\n` +
                        `VID:PID: 0x${device.vendorId.toString(16).toUpperCase()}:0x${device.productId.toString(16).toUpperCase()}\n` +
                        `Chipset: ${device.chipset}\n` +
                        `Fabricante: ${device.manufacturer}\n` +
                        `Producto: ${device.product}\n` +
                        `Serial: ${device.serialNumber}\n`
                      ) : 'No hay dispositivo conectado\n') +
                      `\nMagic Value: 0xDEADBEEF\n` +
                      `EEPROM Size: 256 bytes\n` +
                      `VID Offset: 0x88\n` +
                      `PID Offset: 0x8A`;
                    
                    await Clipboard.setStringAsync(debugInfo);
                    await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
                    Alert.alert('‚úÖ Copiado', 'Informaci√≥n de debug copiada al portapapeles');
                  }}
                  className="bg-primary rounded-xl p-4 active:opacity-80"
                >
                  <Text className="text-background font-semibold text-center">
                    üìã Copiar Info de Debug
                  </Text>
                </TouchableOpacity>
              </View>
            )}
          </View>

          {/* App Info */}
          <View className="bg-surface rounded-2xl p-6 border border-border">
            <Text className="text-lg font-semibold text-foreground mb-4">
              Informaci√≥n de la App
            </Text>

            <View className="gap-3">
              <View className="flex-row justify-between">
                <Text className="text-sm text-muted">Versi√≥n</Text>
                <Text className="text-sm text-foreground font-medium">1.0.0</Text>
              </View>
              <View className="flex-row justify-between">
                <Text className="text-sm text-muted">Creada por</Text>
                <Text className="text-sm text-foreground font-medium">Felipe Plazas</Text>
              </View>
              <View className="flex-row justify-between">
                <Text className="text-sm text-muted">Plataforma</Text>
                <Text className="text-sm text-foreground font-medium">Android</Text>
              </View>
              <View className="flex-row justify-between">
                <Text className="text-sm text-muted">Compatible con</Text>
                <Text className="text-sm text-foreground font-medium">MIB2 STD2</Text>
              </View>
            </View>
          </View>

          {/* Warning */}
          <View className="bg-error/10 border border-error rounded-2xl p-4">
            <Text className="text-sm text-error font-medium mb-2">
              ‚ö†Ô∏è Advertencia de Seguridad
            </Text>
            <Text className="text-xs text-muted leading-relaxed">
              Esta aplicaci√≥n permite ejecutar comandos con privilegios root en la unidad MIB2. 
              El uso incorrecto puede resultar en da√±os permanentes al sistema. 
              Usa esta herramienta bajo tu propia responsabilidad.
            </Text>
          </View>

          {/* Credits */}
          <View className="items-center py-4">
            <Text className="text-xs text-muted text-center">
              MIB2 Controller v1.0.0
            </Text>
            <Text className="text-xs text-muted text-center mt-1">
              Creada por Felipe Plazas
            </Text>
            <Text className="text-xs text-muted text-center mt-1">
              Para unidades MIB2 STD2 Technisat/Preh
            </Text>
          </View>
        </View>
      </ScrollView>
    </ScreenContainer>
  );
}

================================================================================
FILE: app/(tabs)/toolbox.tsx
================================================================================

import { useState } from "react";
import { ScrollView, Text, View, TouchableOpacity, Alert, Platform, ActivityIndicator } from "react-native";
import * as Haptics from "expo-haptics";
import * as Sharing from "expo-sharing";
import * as FileSystem from "expo-file-system/legacy";

import { ScreenContainer } from "@/components/screen-container";
import { useColors } from "@/hooks/use-colors";
import { useTelnet } from "@/lib/telnet-provider";
import { useUsbStatus } from "@/lib/usb-status-context";
import {
  TOOLBOX_INSTALLATION_STEPS,
  EMMC_ACCESS_INFO,
  DIAGNOSTIC_COMMANDS,
  generateInstallationScript,
  generateToolboxVerificationCommand,
  type InstallationStep,
} from "@/lib/toolbox-installer";
import { listBackups, restoreBackup, deleteBackup, backupCriticalBinary, type BackupInfo } from "@/lib/toolbox-backup";

type StepStatus = 'pending' | 'inProgress' | 'completed' | 'error';

export default function ToolboxScreen() {
  const colors = useColors();
  const { isConnected, sendCommand } = useTelnet();
  const { status: usbStatus } = useUsbStatus();
  const [selectedStep, setSelectedStep] = useState<InstallationStep | null>(null);
  const [showEmmcInfo, setShowEmmcInfo] = useState(false);
  const [showDiagnostics, setShowDiagnostics] = useState(false);
  const [stepStatuses, setStepStatuses] = useState<Record<number, StepStatus>>({});
  const [executing, setExecuting] = useState(false);
  const [backups, setBackups] = useState<BackupInfo[]>([]);
  const [loadingBackups, setLoadingBackups] = useState(false);
  const [showBackups, setShowBackups] = useState(false);

  const handleSelectStep = (step: InstallationStep) => {
    if (Platform.OS !== "web") {
      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    }
    setSelectedStep(step);
    setShowEmmcInfo(false);
    setShowDiagnostics(false);
  };

  const handleShowEmmcInfo = () => {
    if (Platform.OS !== "web") {
      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    }
    setShowEmmcInfo(true);
    setSelectedStep(null);
    setShowDiagnostics(false);
  };

  const handleShowDiagnostics = () => {
    if (Platform.OS !== "web") {
      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    }
    setShowDiagnostics(true);
    setSelectedStep(null);
    setShowEmmcInfo(false);
  };

  const handleShowBackups = async () => {
    if (Platform.OS !== "web") {
      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    }
    setShowBackups(true);
    setSelectedStep(null);
    setShowEmmcInfo(false);
    setShowDiagnostics(false);
    await loadBackupsList();
  };

  const loadBackupsList = async () => {
    if (!isConnected) {
      Alert.alert('Error', 'Debes estar conectado por Telnet para ver los backups');
      return;
    }

    setLoadingBackups(true);
    try {
      const backupsList = await listBackups(async (cmd: string) => {
        const result = await sendCommand(cmd);
        return { output: result, success: true };
      });
      setBackups(backupsList);
    } catch (error) {
      Alert.alert('Error', 'No se pudieron cargar los backups');
    } finally {
      setLoadingBackups(false);
    }
  };

  const handleRestoreBackup = async (backup: BackupInfo) => {
    Alert.alert(
      '‚ö†Ô∏è Restaurar Backup',
      `¬øEst√°s seguro de que deseas restaurar este backup?\n\nArchivo: ${backup.filename}\nFecha: ${backup.timestamp}\nTama√±o: ${(backup.size / 1024).toFixed(2)} KB\n\nEsto sobrescribir√° el archivo actual.`,
      [
        { text: 'Cancelar', style: 'cancel' },
        {
          text: 'Restaurar',
          style: 'destructive',
          onPress: async () => {
            try {
              const result = await restoreBackup(
                async (cmd: string) => {
                  const output = await sendCommand(cmd);
                  return { output, success: true };
                },
                backup
              );

              if (result.success) {
                Alert.alert('‚úÖ √âxito', 'Backup restaurado correctamente');
                if (Platform.OS !== "web") {
                  Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
                }
              } else {
                Alert.alert('‚ùå Error', result.error || 'No se pudo restaurar el backup');
                if (Platform.OS !== "web") {
                  Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
                }
              }
            } catch (error) {
              Alert.alert('‚ùå Error', 'Error inesperado al restaurar backup');
            }
          },
        },
      ]
    );
  };

  const handleDeleteBackup = async (backup: BackupInfo) => {
    Alert.alert(
      'Eliminar Backup',
      `¬øEst√°s seguro de que deseas eliminar este backup?\n\n${backup.filename}\n${backup.timestamp}`,
      [
        { text: 'Cancelar', style: 'cancel' },
        {
          text: 'Eliminar',
          style: 'destructive',
          onPress: async () => {
            try {
              const success = await deleteBackup(
                async (cmd: string) => {
                  const output = await sendCommand(cmd);
                  return { output, success: true };
                },
                backup.backupPath
              );

              if (success) {
                Alert.alert('‚úÖ √âxito', 'Backup eliminado');
                await loadBackupsList();
              } else {
                Alert.alert('‚ùå Error', 'No se pudo eliminar el backup');
              }
            } catch (error) {
              Alert.alert('‚ùå Error', 'Error inesperado al eliminar backup');
            }
          },
        },
      ]
    );
  };

  const handleGenerateScript = async () => {
    try {
      const script = generateInstallationScript();
      const fileUri = `${FileSystem.documentDirectory}install_toolbox.sh`;
      
      await FileSystem.writeAsStringAsync(fileUri, script);

      if (Platform.OS !== "web") {
        Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
      }

      Alert.alert(
        "Script Generado",
        "El script de instalaci√≥n ha sido creado exitosamente.",
        [
          { text: "OK" },
          {
            text: "Compartir",
            onPress: async () => {
              if (await Sharing.isAvailableAsync()) {
                await Sharing.shareAsync(fileUri);
              }
            },
          },
        ]
      );
    } catch (error) {
      Alert.alert("Error", "No se pudo generar el script de instalaci√≥n");
      console.error(error);
    }
  };

  const handleGenerateVerification = () => {
    const command = generateToolboxVerificationCommand();
    Alert.alert("Comando de Verificaci√≥n", command, [{ text: "Cerrar" }]);
  };

  const executeStepCommand = async (step: InstallationStep) => {
    if (Platform.OS !== 'web') {
      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    }
    setExecuting(true);
    setStepStatuses(prev => ({ ...prev, [step.step]: 'inProgress' }));

    try {
      sendCommand(step.command!);
      setTimeout(() => {
        setStepStatuses(prev => ({ ...prev, [step.step]: 'completed' }));
        setExecuting(false);
        if (Platform.OS !== 'web') {
          Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
        }
      }, 2000);
    } catch (error) {
      setStepStatuses(prev => ({ ...prev, [step.step]: 'error' }));
      setExecuting(false);
      if (Platform.OS !== 'web') {
        Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
      }
      Alert.alert('Error', 'Error al ejecutar comando');
    }
  };

  const handleExecuteStep = async (step: InstallationStep) => {
    if (!isConnected) {
      Alert.alert('No Conectado', 'Debes conectarte a la unidad MIB2 primero');
      return;
    }

    if (!step.command) {
      Alert.alert('Sin Comando', 'Este paso no tiene un comando asociado');
      return;
    }

    const isCriticalStep = step.step === 2 || step.title.toLowerCase().includes('patch');

    if (isCriticalStep) {
      Alert.alert(
        '‚ö†Ô∏è PASO CR√çTICO - Confirmaci√≥n 1/3',
        'Este paso modifica el binario del sistema tsd.mibstd2.system.swap.\n\nEsto altera la rutina de verificaci√≥n de firmas digitales.\n\n¬øContinuar?',
        [
          { text: 'Cancelar', style: 'cancel' },
          {
            text: 'Continuar',
            style: 'destructive',
            onPress: () => {
              Alert.alert(
                '‚ö†Ô∏è PASO CR√çTICO - Confirmaci√≥n 2/3',
                'Un error durante este proceso puede BRICKEAR la unidad MIB2.\n\nLa √∫nica forma de recuperarla ser√≠a mediante soldadura directa a la memoria eMMC.\n\n¬øEst√°s seguro?',
                [
                  { text: 'Cancelar', style: 'cancel' },
                  {
                    text: 'Estoy Seguro',
                    style: 'destructive',
                    onPress: () => {
                      Alert.alert(
                        '‚ö†Ô∏è CONFIRMACI√ìN FINAL - 3/3',
                        'Una vez iniciado el proceso, NO lo interrumpas.\n\nAseg√∫rate de que:\n‚Ä¢ La bater√≠a del veh√≠culo est√° cargada\n‚Ä¢ No apagar√°s el contacto\n‚Ä¢ La conexi√≥n Telnet es estable\n\n¬øEjecutar parcheo AHORA?',
                        [
                          { text: 'Cancelar', style: 'cancel' },
                          {
                            text: 'EJECUTAR',
                            style: 'destructive',
                            onPress: async () => {
                              // Crear backup autom√°tico antes del parcheo
                              Alert.alert(
                                'üíæ Creando Backup',
                                'Creando backup del binario cr√≠tico antes de continuar...'
                              );
                              
                              try {
                                const backupResult = await backupCriticalBinary(
                                  async (cmd: string) => {
                                    const output = await sendCommand(cmd);
                                    return { output, success: true };
                                  }
                                );

                                if (backupResult.success && backupResult.backup) {
                                  Alert.alert(
                                    '‚úÖ Backup Creado',
                                    `Backup guardado exitosamente:\n\nRuta: ${backupResult.backup.backupPath}\nTama√±o: ${(backupResult.backup.size / 1024).toFixed(2)} KB\nChecksum: ${backupResult.backup.checksum?.substring(0, 16)}...\n\nProcediendo con el parcheo...`,
                                    [
                                      {
                                        text: 'Continuar',
                                        onPress: () => executeStepCommand(step),
                                      },
                                    ]
                                  );
                                } else {
                                  Alert.alert(
                                    '‚ùå Error en Backup',
                                    `No se pudo crear el backup: ${backupResult.error}\n\n¬øDeseas continuar sin backup? (NO RECOMENDADO)`,
                                    [
                                      { text: 'Cancelar', style: 'cancel' },
                                      {
                                        text: 'Continuar Sin Backup',
                                        style: 'destructive',
                                        onPress: () => executeStepCommand(step),
                                      },
                                    ]
                                  );
                                }
                              } catch (error) {
                                Alert.alert(
                                  '‚ùå Error',
                                  'Error inesperado al crear backup. Operaci√≥n cancelada.'
                                );
                              }
                            },
                          },
                        ]
                      );
                    },
                  },
                ]
              );
            },
          },
        ]
      );
      return;
    }

    Alert.alert(
      'Ejecutar Paso',
      `¬øEjecutar: ${step.title}?`,
      [
        { text: 'Cancelar', style: 'cancel' },
        {
          text: 'Ejecutar',
          onPress: () => executeStepCommand(step),
        },
      ]
    );
  };

  const getStepIcon = (stepNumber: number): string => {
    const status = stepStatuses[stepNumber];
    if (status === 'completed') return '‚úÖ';
    if (status === 'inProgress') return '‚è≥';
    if (status === 'error') return '‚ö†Ô∏è';
    return '‚ñ´Ô∏è';
  };

  const getStepColor = (stepNumber: number): string => {
    const status = stepStatuses[stepNumber];
    if (status === 'completed') return '#22C55E';
    if (status === 'inProgress') return colors.primary;
    if (status === 'error') return '#EF4444';
    return colors.muted;
  };

  const telnetReady = isConnected;
  const usbReady = usbStatus === 'connected';
  const allReady = telnetReady && usbReady;

  return (
    <ScreenContainer className="p-4">
      <ScrollView showsVerticalScrollIndicator={false}>
        <View className="gap-6">
          <View className="gap-2">
            <Text className="text-3xl font-bold" style={{ color: colors.foreground }}>
              Instalaci√≥n del Toolbox
            </Text>
            <Text className="text-sm" style={{ color: colors.muted }}>
              Gu√≠a paso a paso para instalar el MIB2 STD2 Toolbox
            </Text>
          </View>

          {/* CRITICAL WARNING */}
          <View className="bg-error/10 rounded-xl p-4 border-2" style={{ borderColor: '#EF4444' }}>
            <View className="flex-row items-center gap-2 mb-2">
              <Text className="text-2xl">‚ö†Ô∏è</Text>
              <Text className="text-lg font-bold" style={{ color: '#EF4444' }}>
                ADVERTENCIA CR√çTICA
              </Text>
            </View>
            <Text className="text-sm leading-relaxed" style={{ color: colors.foreground }}>
              La instalaci√≥n del MIB2 Toolbox modifica archivos del sistema QNX. <Text className="font-bold" style={{ color: '#EF4444' }}>Un error puede BRICKEAR la unidad MIB2</Text> (valor: miles de d√≥lares).
            </Text>
            <Text className="text-sm leading-relaxed mt-2" style={{ color: colors.foreground }}>
              El parcheo de <Text className="font-mono text-xs">tsd.mibstd2.system.swap</Text> altera la rutina de verificaci√≥n de firmas digitales. <Text className="font-bold">No interrumpas el proceso una vez iniciado.</Text>
            </Text>
            <Text className="text-sm leading-relaxed mt-2" style={{ color: colors.foreground }}>
              Si algo falla, la √∫nica forma de recuperar la unidad es mediante acceso directo a la memoria eMMC (soldadura).
            </Text>
          </View>

          <View className="bg-surface rounded-xl p-4 border" style={{ borderColor: colors.border }}>
            <Text className="text-lg font-semibold mb-3" style={{ color: colors.foreground }}>
              Estado de Prerequisitos
            </Text>
            <View className="gap-2">
              <View className="flex-row items-center gap-2">
                <Text className="text-2xl">{telnetReady ? '‚úÖ' : '‚ùå'}</Text>
                <Text className="text-sm" style={{ color: colors.foreground }}>
                  Conexi√≥n Telnet {telnetReady ? 'Activa' : 'Inactiva'}
                </Text>
              </View>
              <View className="flex-row items-center gap-2">
                <Text className="text-2xl">{usbReady ? '‚úÖ' : '‚ùå'}</Text>
                <Text className="text-sm" style={{ color: colors.foreground }}>
                  Adaptador USB {usbReady ? 'Conectado' : 'Desconectado'}
                </Text>
              </View>
              {!allReady && (
                <Text className="text-xs mt-2" style={{ color: '#F59E0B' }}>
                  ‚ö†Ô∏è Completa los prerequisitos antes de instalar
                </Text>
              )}
            </View>
          </View>

          <View className="flex-row gap-3">
            <TouchableOpacity
              onPress={handleShowDiagnostics}
              className="flex-1 bg-primary/10 px-4 py-3 rounded-xl active:opacity-80"
            >
              <Text className="text-center font-semibold text-xs" style={{ color: colors.primary }}>
                üîç Diagn√≥sticos
              </Text>
            </TouchableOpacity>
            <TouchableOpacity
              onPress={handleShowBackups}
              className="flex-1 bg-success/10 px-4 py-3 rounded-xl active:opacity-80"
            >
              <Text className="text-center font-semibold text-xs" style={{ color: "#22C55E" }}>
                üíæ Backups
              </Text>
            </TouchableOpacity>
            <TouchableOpacity
              onPress={handleShowEmmcInfo}
              className="flex-1 bg-warning/10 px-4 py-3 rounded-xl active:opacity-80"
            >
              <Text className="text-center font-semibold text-xs" style={{ color: "#F59E0B" }}>
                ‚öôÔ∏è M√©todo eMMC
              </Text>
            </TouchableOpacity>
          </View>

          {!selectedStep && !showEmmcInfo && !showDiagnostics && !showBackups && (
            <View className="gap-3">
              <Text className="text-lg font-semibold" style={{ color: colors.foreground }}>
                Pasos de Instalaci√≥n
              </Text>
              {TOOLBOX_INSTALLATION_STEPS.map((step) => (
                <TouchableOpacity
                  key={step.step}
                  onPress={() => handleSelectStep(step)}
                  className="bg-surface rounded-xl p-4 border active:opacity-80"
                  style={{ borderColor: colors.border }}
                >
                  <View className="flex-row items-center gap-3 mb-2">
                    <View
                      className="w-8 h-8 rounded-full items-center justify-center"
                      style={{ backgroundColor: colors.primary }}
                    >
                      <Text className="text-sm font-bold" style={{ color: colors.background }}>
                        {step.step}
                      </Text>
                    </View>
                    <Text className="text-base font-semibold flex-1" style={{ color: colors.foreground }}>
                      {step.title}
                    </Text>
                    <Text className="text-2xl">{getStepIcon(step.step)}</Text>
                  </View>
                  <Text className="text-xs ml-11" style={{ color: colors.muted }}>
                    {step.description}
                  </Text>
                </TouchableOpacity>
              ))}
            </View>
          )}

          {selectedStep && (
            <View className="gap-4">
              <TouchableOpacity
                onPress={() => setSelectedStep(null)}
                className="flex-row items-center gap-2"
              >
                <Text className="text-lg" style={{ color: colors.primary }}>
                  ‚Üê
                </Text>
                <Text className="text-sm font-semibold" style={{ color: colors.primary }}>
                  Volver a la lista
                </Text>
              </TouchableOpacity>

              <View className="bg-surface rounded-xl p-4 border" style={{ borderColor: colors.border }}>
                <View className="flex-row items-center gap-3 mb-3">
                  <View
                    className="w-10 h-10 rounded-full items-center justify-center"
                    style={{ backgroundColor: colors.primary }}
                  >
                    <Text className="text-base font-bold" style={{ color: colors.background }}>
                      {selectedStep.step}
                    </Text>
                  </View>
                  <Text className="text-xl font-bold flex-1" style={{ color: colors.foreground }}>
                    {selectedStep.title}
                  </Text>
                </View>

                <Text className="text-sm leading-relaxed mb-4" style={{ color: colors.foreground }}>
                  {selectedStep.description}
                </Text>

                {selectedStep.command && (
                  <View className="bg-background rounded-lg p-3 mb-4">
                    <Text className="text-xs font-mono" style={{ color: colors.muted }}>
                      {selectedStep.command}
                    </Text>
                  </View>
                )}

                {selectedStep.warnings && selectedStep.warnings.length > 0 && (
                  <View className="bg-warning/10 rounded-lg p-3 mb-4">
                    {selectedStep.warnings.map((warning, idx) => (
                      <Text key={idx} className="text-xs leading-relaxed mb-1" style={{ color: colors.foreground }}>
                        üí° {warning}
                      </Text>
                    ))}
                  </View>
                )}

                {selectedStep.command && (
                  <TouchableOpacity
                    onPress={() => handleExecuteStep(selectedStep)}
                    disabled={!allReady || executing}
                    className="bg-primary px-6 py-3 rounded-xl active:opacity-80"
                    style={{
                      backgroundColor: !allReady || executing ? colors.muted : colors.primary,
                      opacity: !allReady || executing ? 0.5 : 1,
                    }}
                  >
                    {executing ? (
                      <View className="flex-row items-center justify-center gap-2">
                        <ActivityIndicator size="small" color={colors.background} />
                        <Text className="text-center font-semibold" style={{ color: colors.background }}>
                          Ejecutando...
                        </Text>
                      </View>
                    ) : (
                      <Text className="text-center font-semibold" style={{ color: colors.background }}>
                        ‚ñ∂Ô∏è Ejecutar Paso
                      </Text>
                    )}
                  </TouchableOpacity>
                )}
              </View>
            </View>
          )}

          {showEmmcInfo && (
            <View className="gap-4">
              <TouchableOpacity
                onPress={() => setShowEmmcInfo(false)}
                className="flex-row items-center gap-2"
              >
                <Text className="text-lg" style={{ color: colors.primary }}>
                  ‚Üê
                </Text>
                <Text className="text-sm font-semibold" style={{ color: colors.primary }}>
                  Volver a la lista
                </Text>
              </TouchableOpacity>

              <View className="bg-surface rounded-xl p-4 border" style={{ borderColor: colors.border }}>
                <Text className="text-lg font-bold mb-3" style={{ color: colors.foreground }}>
                  {EMMC_ACCESS_INFO.title}
                </Text>
                <Text className="text-sm leading-relaxed mb-4" style={{ color: colors.foreground }}>
                  {EMMC_ACCESS_INFO.description}
                </Text>

                <Text className="text-base font-semibold mb-2" style={{ color: colors.foreground }}>
                  Pasos:
                </Text>
                {EMMC_ACCESS_INFO.steps.map((step, index) => (
                  <Text key={index} className="text-sm leading-relaxed mb-2" style={{ color: colors.foreground }}>
                    {index + 1}. {step}
                  </Text>
                ))}

                <View className="bg-error/10 rounded-lg p-3 mt-4">
                  {EMMC_ACCESS_INFO.warnings.map((warning, idx) => (
                    <Text key={idx} className="text-xs leading-relaxed mb-1" style={{ color: '#EF4444' }}>
                      ‚ö†Ô∏è {warning}
                    </Text>
                  ))}
                </View>
              </View>
            </View>
          )}

          {showDiagnostics && (
            <View className="gap-4">
              <TouchableOpacity
                onPress={() => setShowDiagnostics(false)}
                className="flex-row items-center gap-2"
              >
                <Text className="text-lg" style={{ color: colors.primary }}>
                  ‚Üê
                </Text>
                <Text className="text-sm font-semibold" style={{ color: colors.primary }}>
                  Volver a la lista
                </Text>
              </TouchableOpacity>

              <View className="bg-surface rounded-xl p-4 border" style={{ borderColor: colors.border }}>
                <Text className="text-lg font-bold mb-3" style={{ color: colors.foreground }}>
                  Comandos de Diagn√≥stico
                </Text>
                {DIAGNOSTIC_COMMANDS.map((cmd, index) => (
                  <View key={index} className="mb-4">
                    <Text className="text-sm font-semibold mb-1" style={{ color: colors.foreground }}>
                      {cmd.name}
                    </Text>
                    <Text className="text-xs mb-2" style={{ color: colors.muted }}>
                      {cmd.description}
                    </Text>
                    <View className="bg-background rounded-lg p-2">
                      <Text className="text-xs font-mono" style={{ color: colors.muted }}>
                        {cmd.command}
                      </Text>
                    </View>
                  </View>
                ))}
              </View>
            </View>
          )}

          {showBackups && (
            <View className="gap-4">
              <TouchableOpacity
                onPress={() => setShowBackups(false)}
                className="flex-row items-center gap-2"
              >
                <Text className="text-lg" style={{ color: colors.primary }}>
                  ‚Üê
                </Text>
                <Text className="text-sm font-semibold" style={{ color: colors.primary }}>
                  Volver a la lista
                </Text>
              </TouchableOpacity>

              <View className="bg-surface rounded-xl p-4 border" style={{ borderColor: colors.border }}>
                <Text className="text-lg font-bold mb-3" style={{ color: colors.foreground }}>
                  üíæ Gesti√≥n de Backups
                </Text>
                <Text className="text-xs mb-4" style={{ color: colors.muted }}>
                  Los backups se crean autom√°ticamente antes de modificar archivos cr√≠ticos del sistema MIB2.
                </Text>

                {loadingBackups ? (
                  <View className="items-center py-8">
                    <ActivityIndicator size="large" color={colors.primary} />
                    <Text className="text-sm mt-2" style={{ color: colors.muted }}>
                      Cargando backups...
                    </Text>
                  </View>
                ) : backups.length === 0 ? (
                  <View className="items-center py-8">
                    <Text className="text-4xl mb-2">üìÅ</Text>
                    <Text className="text-sm" style={{ color: colors.muted }}>
                      No hay backups disponibles
                    </Text>
                  </View>
                ) : (
                  <View className="gap-3">
                    {backups.map((backup, index) => (
                      <View
                        key={index}
                        className="bg-background rounded-lg p-3 border"
                        style={{ borderColor: colors.border }}
                      >
                        <View className="flex-row items-center justify-between mb-2">
                          <Text className="text-sm font-semibold flex-1" style={{ color: colors.foreground }}>
                            {backup.filename}
                          </Text>
                          <Text className="text-xs" style={{ color: colors.muted }}>
                            {(backup.size / 1024).toFixed(2)} KB
                          </Text>
                        </View>
                        <Text className="text-xs mb-1" style={{ color: colors.muted }}>
                          üìÖ {backup.timestamp}
                        </Text>
                        {backup.checksum && (
                          <Text className="text-xs mb-2 font-mono" style={{ color: colors.muted }}>
                            MD5: {backup.checksum.substring(0, 16)}...
                          </Text>
                        )}
                        <View className="flex-row gap-2 mt-2">
                          <TouchableOpacity
                            onPress={() => handleRestoreBackup(backup)}
                            className="flex-1 bg-success/10 px-3 py-2 rounded-lg active:opacity-80"
                          >
                            <Text className="text-center text-xs font-semibold" style={{ color: "#22C55E" }}>
                              ‚Üª Restaurar
                            </Text>
                          </TouchableOpacity>
                          <TouchableOpacity
                            onPress={() => handleDeleteBackup(backup)}
                            className="flex-1 bg-error/10 px-3 py-2 rounded-lg active:opacity-80"
                          >
                            <Text className="text-center text-xs font-semibold" style={{ color: "#EF4444" }}>
                              üóëÔ∏è Eliminar
                            </Text>
                          </TouchableOpacity>
                        </View>
                      </View>
                    ))}
                  </View>
                )}
              </View>
            </View>
          )}
        </View>
      </ScrollView>
    </ScreenContainer>
  );
}

================================================================================
FILE: app/(tabs)/tools.tsx
================================================================================

import { ScrollView, Text, View, TouchableOpacity } from "react-native";
import { router } from "expo-router";
import { ScreenContainer } from "@/components/screen-container";

export default function ToolsScreen() {
  const tools = [
    { id: 'fec', title: 'Generador FEC', description: 'Generar c√≥digos FEC personalizados', icon: 'üîë' },
    { id: 'toolbox', title: 'MIB2 Toolbox', description: 'Asistente de instalaci√≥n', icon: 'üõ†Ô∏è' },
    { id: 'auto-spoof', title: 'USB Spoofing', description: 'Modificar adaptadores ASIX', icon: '‚ö°' },
    { id: 'usb-status', title: 'Estado USB', description: 'Informaci√≥n del adaptador conectado', icon: 'üîå' },
    { id: 'commands', title: 'Terminal Telnet', description: 'Consola interactiva MIB2', icon: 'üíª' },
  ];

  return (
    <ScreenContainer className="p-4">
      <ScrollView contentContainerStyle={{ flexGrow: 1 }}>
        <View className="gap-4">
          <View className="mb-4">
            <Text className="text-3xl font-bold text-foreground">Herramientas</Text>
            <Text className="text-sm text-muted mt-1">
              Utilidades avanzadas para MIB2
            </Text>
          </View>

          {tools.map((tool) => (
            <TouchableOpacity
              key={tool.id}
              onPress={() => router.push(`/(tabs)/${tool.id}` as any)}
              className="bg-surface rounded-xl p-4 border border-border active:opacity-70"
            >
              <View className="flex-row items-center gap-3">
                <Text className="text-3xl">{tool.icon}</Text>
                <View className="flex-1">
                  <Text className="text-lg font-semibold text-foreground">{tool.title}</Text>
                  <Text className="text-sm text-muted mt-1">{tool.description}</Text>
                </View>
                <Text className="text-2xl text-muted">‚Ä∫</Text>
              </View>
            </TouchableOpacity>
          ))}
        </View>
      </ScrollView>
    </ScreenContainer>
  );
}

================================================================================
FILE: app/(tabs)/usb-status.tsx
================================================================================

import { ScrollView, Text, View, TouchableOpacity, RefreshControl, Alert } from 'react-native';
import { useState, useEffect } from 'react';
import * as Haptics from 'expo-haptics';
import { ScreenContainer } from '@/components/screen-container';
import { useUsbStatus } from '@/lib/usb-status-context';
import { usbService } from '@/lib/usb-service';
import { backupService } from '@/lib/backup-service';
import { ChipsetStatusBadge } from '@/components/chipset-status-badge';
import { getChipsetCompatibility, canAttemptSpoofing } from '@/lib/chipset-compatibility';
import { ScanningIndicator } from '@/components/scanning-indicator';

export default function UsbStatusScreen() {
  const { status, device, devices, isScanning, scanDevices, connectToDevice, disconnectDevice, detectedProfile, recommendedProfile } = useUsbStatus();
  const [refreshing, setRefreshing] = useState(false);
  const [connectionTime, setConnectionTime] = useState<Date | null>(null);
  const [uptime, setUptime] = useState('00:00:00');
  const [isCreatingBackup, setIsCreatingBackup] = useState(false);
  const [isConnecting, setIsConnecting] = useState(false);
  const [isTestingEEPROM, setIsTestingEEPROM] = useState(false);
  const [isDisconnecting, setIsDisconnecting] = useState(false);

  // Actualizar tiempo de conexi√≥n cada segundo
  useEffect(() => {
    if (status === 'connected' && !connectionTime) {
      setConnectionTime(new Date());
    } else if (status !== 'connected') {
      setConnectionTime(null);
      setUptime('00:00:00');
    }
  }, [status, connectionTime]);

  useEffect(() => {
    if (!connectionTime) return;

    const interval = setInterval(() => {
      const now = new Date();
      const diff = now.getTime() - connectionTime.getTime();
      const hours = Math.floor(diff / 3600000);
      const minutes = Math.floor((diff % 3600000) / 60000);
      const seconds = Math.floor((diff % 60000) / 1000);
      setUptime(`${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`);
    }, 1000);

    return () => clearInterval(interval);
  }, [connectionTime]);

  const onRefresh = async () => {
    setRefreshing(true);
    await scanDevices();
    setRefreshing(false);
  };

  const handleCreateBackup = async () => {
    if (!device) {
      Alert.alert('Error', 'No hay dispositivo USB conectado');
      return;
    }

    Alert.alert(
      'üíæ Crear Backup Manual',
      'Se crear√° una copia de seguridad completa de la EEPROM del adaptador USB.\n\nEsto es recomendable antes de realizar cualquier modificaci√≥n.\n\n¬øDeseas continuar?',
      [
        { text: 'Cancelar', style: 'cancel' },
        {
          text: 'Crear Backup',
          onPress: async () => {
            setIsCreatingBackup(true);
            try {
              await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
              const backup = await backupService.createBackup(device);
              await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
              
              const filename = `backup_${device.vendorId.toString(16)}_${device.productId.toString(16)}_${backup.timestamp}.bin`;
              Alert.alert(
                '‚úÖ Backup Creado',
                `Backup guardado exitosamente:\n\n` +
                `üíæ Archivo: ${filename}\n` +
                `üìÖ Fecha: ${new Date(backup.timestamp).toLocaleString('es-ES')}\n` +
                `üìä Tama√±o: ${backup.size} bytes\n` +
                `üìÇ Ruta: Android/data/[app]/files/Download/mib2_backups/\n\n` +
                `Accede desde: Archivos ‚Üí Android ‚Üí data ‚Üí [nombre_app] ‚Üí files ‚Üí Download ‚Üí mib2_backups`
              );
            } catch (error: any) {
              await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
              Alert.alert(
                '‚ùå Error al Crear Backup',
                error.message || 'No se pudo crear el backup. Verifica que el dispositivo est√© conectado correctamente.'
              );
            } finally {
              setIsCreatingBackup(false);
            }
          },
        },
      ]
    );
  };

  const handleConnect = async () => {
    // Usar el primer dispositivo detectado si no hay device seleccionado
    const targetDevice = device || (devices.length > 0 ? devices[0] : null);
    
    if (!targetDevice) {
      Alert.alert('Error', 'No hay dispositivo USB detectado');
      return;
    }

    setIsConnecting(true);
    try {
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
      
      // Solicitar permisos
      const granted = await usbService.requestPermission(targetDevice.deviceId);
      if (!granted) {
        throw new Error('Permisos USB denegados');
      }

      // Abrir dispositivo
      const opened = await usbService.openDevice(targetDevice.deviceId);
      if (!opened) {
        throw new Error('No se pudo abrir el dispositivo USB');
      }

      // Actualizar estado global usando connectToDevice del contexto
      // Esto marca el dispositivo como conectado en el contexto
      await connectToDevice(targetDevice);

      await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
      Alert.alert(
        '‚úÖ Conectado',
        `Dispositivo USB conectado exitosamente:\n\n` +
        `üì± ${targetDevice.deviceName}\n` +
        `üîå VID/PID: 0x${targetDevice.vendorId.toString(16).toUpperCase().padStart(4, '0')}:0x${targetDevice.productId.toString(16).toUpperCase().padStart(4, '0')}\n` +
        `üîß Chipset: ${targetDevice.chipset}`
      );
    } catch (error: any) {
      await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
      Alert.alert(
        '‚ùå Error al Conectar',
        error.message || 'No se pudo conectar con el dispositivo USB'
      );
    } finally {
      setIsConnecting(false);
    }
  };

  const handleTestEEPROM = async () => {
    if (!device) {
      Alert.alert('Error', 'No hay dispositivo USB conectado');
      return;
    }

    setIsTestingEEPROM(true);
    try {
      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
      
      // Realizar detecci√≥n REAL de tipo de EEPROM
      const eepromType = await usbService.detectEEPROMType();
      
      // Leer EEPROM completa para verificar integridad
      const result = await usbService.readEEPROM(0, 256);
      
      // Calcular checksum simple
      let checksum = 0;
      for (let i = 0; i < result.data.length; i += 2) {
        const byte = parseInt(result.data.substr(i, 2), 16);
        checksum = (checksum + byte) & 0xFF;
      }

      // Verificar integridad (detectar si est√° corrupta)
      const isCorrupt = result.data === 'FF'.repeat(128); // 256 bytes = 128 pares FF
      
      await Haptics.notificationAsync(
        eepromType.writable ? Haptics.NotificationFeedbackType.Success : Haptics.NotificationFeedbackType.Warning
      );
      
      // Determinar icono seg√∫n tipo
      const typeIcon = eepromType.type === 'external_eeprom' ? '‚úÖ' : eepromType.type === 'efuse' ? '‚ùå' : '‚ö†Ô∏è';
      const typeLabel = eepromType.type === 'external_eeprom' ? 'EEPROM Externa' : eepromType.type === 'efuse' ? 'eFuse' : 'Desconocido';
      
      Alert.alert(
        `${typeIcon} Test EEPROM Completado`,
        `üìä Tama√±o: 256 bytes\n` +
        `üî¢ Checksum: 0x${checksum.toString(16).toUpperCase().padStart(2, '0')}\n` +
        `${isCorrupt ? '‚ùå Estado: CORRUPTA (todos los bytes son 0xFF)' : '‚úÖ Estado: OK (datos v√°lidos)'}\n\n` +
        `üîç Tipo Detectado: ${typeLabel}\n` +
        `üìù Modificable: ${eepromType.writable ? 'S√ç ‚úÖ' : 'NO ‚ùå'}\n\n` +
        `üí° ${eepromType.reason}\n\n` +
        `${eepromType.writable ? '‚úÖ Este adaptador PUEDE ser modificado de forma segura mediante spoofing.' : '‚ö†Ô∏è Este adaptador NO puede ser modificado. El spoofing est√° BLOQUEADO para prevenir bricking.'}`
      );
    } catch (error: any) {
      await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
      Alert.alert(
        '‚ùå Error al Testear EEPROM',
        error.message || 'No se pudo realizar el test. Verifica que el dispositivo est√© conectado correctamente.'
      );
    } finally {
      setIsTestingEEPROM(false);
    }
  };

  const handleDisconnect = async () => {
    Alert.alert(
      'üîå Desconectar Dispositivo',
      '¬øEst√°s seguro de que deseas desconectar el dispositivo USB?',
      [
        { text: 'Cancelar', style: 'cancel' },
        {
          text: 'Desconectar',
          style: 'destructive',
          onPress: async () => {
            setIsDisconnecting(true);
            try {
              await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
              
              // Cerrar dispositivo
              usbService.closeDevice();
              
              // Actualizar estado global usando disconnectDevice del contexto
              await disconnectDevice();
              
              await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
              Alert.alert(
                '‚úÖ Desconectado',
                'El dispositivo USB se desconect√≥ correctamente.'
              );
            } catch (error: any) {
              await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
              Alert.alert(
                '‚ùå Error al Desconectar',
                error.message || 'No se pudo desconectar el dispositivo USB'
              );
            } finally {
              setIsDisconnecting(false);
            }
          },
        },
      ]
    );
  };

  const getStatusColor = () => {
    switch (status) {
      case 'connected':
        return 'bg-green-500';
      case 'detected':
        return 'bg-yellow-500';
      default:
        return 'bg-red-500';
    }
  };

  const getStatusText = () => {
    switch (status) {
      case 'connected':
        return 'Conectado';
      case 'detected':
        return 'Detectado';
      default:
        return 'Desconectado';
    }
  };

  const getStatusIcon = () => {
    switch (status) {
      case 'connected':
        return '‚úÖ';
      case 'detected':
        return '‚ö†Ô∏è';
      default:
        return '‚ùå';
    }
  };

  return (
    <ScreenContainer className="p-4">
      <ScrollView
        contentContainerStyle={{ flexGrow: 1 }}
        refreshControl={
          <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
        }
      >
        <View className="gap-4">
          {/* Indicador de Escaneo */}
          <ScanningIndicator isScanning={isScanning} />
          {/* Header */}
          <View className="items-center mb-4">
            <Text className="text-3xl font-bold text-foreground mb-2">
              Estado de Conexi√≥n USB
            </Text>
            <Text className="text-sm text-muted text-center">
              Informaci√≥n en tiempo real de tu dispositivo USB
            </Text>
          </View>

          {/* Estado Principal */}
          <View className="bg-surface rounded-2xl p-6 border border-border">
            <View className="items-center gap-4">
              <View className={`w-24 h-24 rounded-full ${getStatusColor()} items-center justify-center`}>
                <Text className="text-5xl">{getStatusIcon()}</Text>
              </View>
              <View className="items-center">
                <Text className="text-2xl font-bold text-foreground">
                  {getStatusText()}
                </Text>
                {status === 'connected' && device && (
                  <Text className="text-sm text-muted mt-1">
                    {device.product || device.deviceName}
                  </Text>
                )}
              </View>
            </View>
          </View>

          {/* Informaci√≥n del Dispositivo Conectado */}
          {status === 'connected' && device && (
            <View className="bg-surface rounded-2xl p-6 border border-border">
              <Text className="text-lg font-bold text-foreground mb-4">
                üì± Informaci√≥n del Dispositivo
              </Text>
              
              <View className="gap-3">
                <View className="flex-row justify-between">
                  <Text className="text-sm text-muted">Nombre:</Text>
                  <Text className="text-sm text-foreground font-medium">
                    {device.deviceName}
                  </Text>
                </View>

                <View className="flex-row justify-between">
                  <Text className="text-sm text-muted">VID:PID:</Text>
                  <Text className="text-sm text-foreground font-mono">
                    {usbService.formatVIDPID(device.vendorId, device.productId)}
                  </Text>
                </View>

                {device.manufacturer && (
                  <View className="flex-row justify-between">
                    <Text className="text-sm text-muted">Fabricante:</Text>
                    <Text className="text-sm text-foreground">
                      {device.manufacturer}
                    </Text>
                  </View>
                )}

                {device.product && (
                  <View className="flex-row justify-between">
                    <Text className="text-sm text-muted">Producto:</Text>
                    <Text className="text-sm text-foreground">
                      {device.product}
                    </Text>
                  </View>
                )}

                {device.serialNumber && device.serialNumber !== 'Unknown' && (
                  <View className="flex-row justify-between">
                    <Text className="text-sm text-muted">Serial:</Text>
                    <Text className="text-sm text-foreground font-mono">
                      {device.serialNumber}
                    </Text>
                  </View>
                )}

                {device.chipset && (
                  <View className="flex-row justify-between">
                    <Text className="text-sm text-muted">Chipset:</Text>
                    <Text className="text-sm text-foreground font-medium">
                      {device.chipset}
                    </Text>
                  </View>
                )}

              </View>
            </View>
          )}

              {/* Bot√≥n Refrescar (siempre visible) */}
          <View className="mt-4">
            <TouchableOpacity
              onPress={async () => {
                await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
                await scanDevices();
                await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
              }}
              disabled={isScanning}
              className={`rounded-xl p-3 items-center border ${
                isScanning 
                  ? 'bg-muted/20 border-muted opacity-50' 
                  : 'bg-background border-primary active:opacity-80'
              }`}
            >
              <View className="flex-row items-center gap-2">
                <Text className="text-lg">üîÑ</Text>
                <Text className={`text-sm font-semibold ${
                  isScanning ? 'text-muted' : 'text-primary'
                }`}>
                  {isScanning ? 'Escaneando...' : 'Refrescar Dispositivos'}
                </Text>
              </View>
            </TouchableOpacity>
          </View>

          {/* Botones de Acci√≥n */}
          {status === 'detected' && devices.length > 0 && (
            <View className="mt-3">
              <TouchableOpacity
                onPress={handleConnect}
                disabled={isConnecting}
                className={`rounded-xl p-4 items-center border-2 ${
                  isConnecting 
                    ? 'bg-muted/20 border-muted opacity-50' 
                    : 'bg-primary border-primary active:opacity-80'
                }`}
              >
                <View className="flex-row items-center gap-2">
                  <Text className="text-xl">üîå</Text>
                  <Text className="text-base font-bold text-background">
                    {isConnecting ? 'Conectando...' : 'Conectar'}
                  </Text>
                </View>
                <Text className="text-xs text-background/80 mt-1">
                  Solicitar permisos y abrir conexi√≥n USB
                </Text>
              </TouchableOpacity>
            </View>
          )}

          {status === 'connected' && device && (
            <View className="mt-4 gap-3">
              {/* Bot√≥n Test EEPROM */}
              <TouchableOpacity
                onPress={handleTestEEPROM}
                disabled={isTestingEEPROM}
                className={`rounded-xl p-4 items-center border-2 ${
                  isTestingEEPROM 
                    ? 'bg-muted/20 border-muted opacity-50' 
                    : 'bg-green-500 border-green-500 active:opacity-80'
                }`}
              >
                <View className="flex-row items-center gap-2">
                  <Text className="text-xl">üß™</Text>
                  <Text className="text-base font-bold text-background">
                    {isTestingEEPROM ? 'Testeando...' : 'Test EEPROM'}
                  </Text>
                </View>
                <Text className="text-xs text-background/80 mt-1">
                  Leer y verificar integridad de EEPROM (256 bytes)
                </Text>
              </TouchableOpacity>

              {/* Bot√≥n Desconectar */}
              <TouchableOpacity
                onPress={handleDisconnect}
                className="rounded-xl p-4 items-center border-2 bg-background border-error active:opacity-80"
              >
                <View className="flex-row items-center gap-2">
                  <Text className="text-xl">‚ùå</Text>
                  <Text className="text-base font-bold text-error">
                    Desconectar
                  </Text>
                </View>
                <Text className="text-xs text-muted mt-1">
                  Cerrar conexi√≥n USB de forma segura
                </Text>
              </TouchableOpacity>
            </View>
          )}

          {/* Badge de Estado del Chipset */}
          {status === 'connected' && device && device.chipset && (
            <View className="mt-4 gap-3">
              <ChipsetStatusBadge
                chipset={device.chipset}
                compatibility={getChipsetCompatibility(device.chipset)}
                animated={true}
              />
              
              {/* Bot√≥n de Acceso R√°pido a Auto Spoof */}
              {(() => {
                const compat = getChipsetCompatibility(device.chipset);
                if (canAttemptSpoofing(compat)) {
                  return (
                    <TouchableOpacity
                      onPress={() => {
                        Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
                        const router = require('expo-router').router;
                        router.push('/(tabs)/auto-spoof');
                      }}
                      className="bg-primary rounded-xl p-4 items-center active:opacity-80"
                    >
                      <View className="flex-row items-center gap-2">
                        <Text className="text-xl">‚ö°</Text>
                        <Text className="text-base font-bold text-background">
                          Ir a Auto Spoof
                        </Text>
                        <Text className="text-xl">‚Ä∫</Text>
                      </View>
                      <Text className="text-xs text-background/80 mt-1">
                        {compat === 'confirmed' 
                          ? 'Chipset confirmado compatible' 
                          : 'Chipset experimental - usar con precauci√≥n'}
                      </Text>
                    </TouchableOpacity>
                  );
                }
                return null;
              })()}
              
              {/* Bot√≥n de Backup Manual */}
              <TouchableOpacity
                onPress={handleCreateBackup}
                disabled={isCreatingBackup}
                className={`rounded-xl p-4 items-center border-2 ${
                  isCreatingBackup 
                    ? 'bg-muted/20 border-muted opacity-50' 
                    : 'bg-background border-primary active:opacity-80'
                }`}
              >
                <View className="flex-row items-center gap-2">
                  <Text className="text-xl">üíæ</Text>
                  <Text className={`text-base font-bold ${
                    isCreatingBackup ? 'text-muted' : 'text-primary'
                  }`}>
                    {isCreatingBackup ? 'Creando Backup...' : 'Crear Backup Manual'}
                  </Text>
                </View>
                <Text className="text-xs text-muted mt-1">
                  Copia de seguridad preventiva de EEPROM
                </Text>
              </TouchableOpacity>
            </View>
          )}

          {/* Perfil Detectado */}
          {status === 'connected' && detectedProfile && (
            <View className={`rounded-2xl p-6 border ${
              detectedProfile.compatible 
                ? 'bg-green-500/10 border-green-500' 
                : 'bg-blue-500/10 border-blue-500'
            }`}>
              <View className="flex-row items-center gap-2 mb-3">
                <Text className="text-2xl">{detectedProfile.icon}</Text>
                <Text className="text-lg font-bold text-foreground">
                  Perfil Detectado
                </Text>
              </View>
              
              <View className="gap-2 mb-4">
                <View className="flex-row justify-between">
                  <Text className="text-sm text-muted">Adaptador:</Text>
                  <Text className="text-sm text-foreground font-bold">
                    {detectedProfile.name}
                  </Text>
                </View>
                <View className="flex-row justify-between">
                  <Text className="text-sm text-muted">Fabricante:</Text>
                  <Text className="text-sm text-foreground">
                    {detectedProfile.manufacturer}
                  </Text>
                </View>
                <View className="flex-row justify-between">
                  <Text className="text-sm text-muted">Chipset:</Text>
                  <Text className="text-sm text-foreground">
                    {detectedProfile.chipset}
                  </Text>
                </View>
                <View className="flex-row justify-between">
                  <Text className="text-sm text-muted">Compatible MIB2:</Text>
                  <Text className={`text-sm font-bold ${
                    detectedProfile.compatible ? 'text-green-500' : 'text-red-500'
                  }`}>
                    {detectedProfile.compatible ? '‚úÖ S√≠' : '‚ùå No'}
                  </Text>
                </View>
              </View>
              
              <View className="bg-background rounded-lg p-3">
                <Text className="text-xs text-muted">
                  {detectedProfile.notes}
                </Text>
              </View>
            </View>
          )}

          {/* Estad√≠sticas de Conexi√≥n */}
          {status === 'connected' && (
            <View className="bg-surface rounded-2xl p-6 border border-border">
              <Text className="text-lg font-bold text-foreground mb-4">
                üìä Estad√≠sticas
              </Text>
              
              <View className="gap-3">
                <View className="flex-row justify-between">
                  <Text className="text-sm text-muted">Tiempo Conectado:</Text>
                  <Text className="text-sm text-foreground font-mono">
                    {uptime}
                  </Text>
                </View>

                <View className="flex-row justify-between">
                  <Text className="text-sm text-muted">Dispositivos Detectados:</Text>
                  <Text className="text-sm text-foreground font-medium">
                    {devices.length}
                  </Text>
                </View>

                <View className="flex-row justify-between">
                  <Text className="text-sm text-muted">Estado del Servicio:</Text>
                  <Text className="text-sm text-green-500 font-medium">
                    ‚úÖ Activo
                  </Text>
                </View>
              </View>
            </View>
          )}

          {/* Sugerencia de Spoofing */}
          {status === 'connected' && recommendedProfile && (
            <View className="bg-yellow-500/10 rounded-2xl p-6 border border-yellow-500">
              <View className="flex-row items-center gap-2 mb-3">
                <Text className="text-2xl">‚ö°</Text>
                <Text className="text-lg font-bold text-foreground">
                  Spoofing Recomendado
                </Text>
              </View>
              
              <View className="bg-background rounded-lg p-4 mb-4">
                <Text className="text-sm text-muted mb-2">
                  Este dispositivo no es compatible con MIB2. Se recomienda aplicar el siguiente perfil:
                </Text>
                <View className="gap-2 mt-2">
                  <View className="flex-row justify-between">
                    <Text className="text-sm text-muted">Perfil Objetivo:</Text>
                    <Text className="text-sm text-foreground font-bold">
                      {recommendedProfile.name}
                    </Text>
                  </View>
                  <View className="flex-row justify-between">
                    <Text className="text-sm text-muted">VID:PID:</Text>
                    <Text className="text-sm text-foreground font-mono">
                      {recommendedProfile.vendorId.toString(16).padStart(4, '0').toUpperCase()}:
                      {recommendedProfile.productId.toString(16).padStart(4, '0').toUpperCase()}
                    </Text>
                  </View>
                </View>
              </View>

            </View>
          )}

          {/* Lista de Dispositivos Detectados */}
          {status === 'detected' && devices.length > 0 && (
            <View className="bg-surface rounded-2xl p-6 border border-border">
              <Text className="text-lg font-bold text-foreground mb-4">
                üîç Dispositivos Detectados ({devices.length})
              </Text>
              
              <View className="gap-3">
                {devices.map((dev, index) => (
                  <View key={dev.deviceId} className="bg-background rounded-lg p-4 border border-border">
                    <View className="flex-row justify-between items-center mb-2">
                      <Text className="text-sm font-bold text-foreground">
                        Dispositivo #{index + 1}
                      </Text>
                      <Text className="text-xs text-muted font-mono">
                        {usbService.formatVIDPID(dev.vendorId, dev.productId)}
                      </Text>
                    </View>
                    <Text className="text-xs text-muted">
                      {dev.product || dev.deviceName}
                    </Text>
                    {dev.chipset && (
                      <Text className="text-xs text-muted mt-1">
                        Chipset: {dev.chipset}
                      </Text>
                    )}
                  </View>
                ))}
              </View>
            </View>
          )}

          {/* Sin Dispositivos */}
          {status === 'disconnected' && (
            <View className="bg-surface rounded-2xl p-6 border border-border items-center">
              <Text className="text-6xl mb-4">üîå</Text>
              <Text className="text-lg font-bold text-foreground mb-2">
                No hay dispositivos conectados
              </Text>
              <Text className="text-sm text-muted text-center mb-4">
                Conecta un adaptador USB-Ethernet compatible para comenzar
              </Text>
              <TouchableOpacity
                onPress={onRefresh}
                className="bg-primary px-6 py-3 rounded-full"
                disabled={isScanning}
              >
                <Text className="text-background font-semibold">
                  {isScanning ? 'Escaneando...' : 'Escanear Ahora'}
                </Text>
              </TouchableOpacity>
            </View>
          )}

          {/* Informaci√≥n de Ayuda */}
          <View className="bg-surface rounded-2xl p-6 border border-border">
            <Text className="text-lg font-bold text-foreground mb-4">
              üí° Consejos
            </Text>
            <View className="gap-2">
              <Text className="text-sm text-muted">
                ‚Ä¢ Conecta el adaptador USB con un cable OTG
              </Text>
              <Text className="text-sm text-muted">
                ‚Ä¢ Aseg√∫rate de que el adaptador tenga alimentaci√≥n
              </Text>
              <Text className="text-sm text-muted">
                ‚Ä¢ Los adaptadores ASIX son los m√°s compatibles
              </Text>
              <Text className="text-sm text-muted">
                ‚Ä¢ Desliza hacia abajo para actualizar el estado
              </Text>
            </View>
          </View>
        </View>
      </ScrollView>
    </ScreenContainer>
  );
}

================================================================================
FILE: app/_layout.tsx
================================================================================

import "@/global.css";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { Stack } from "expo-router";
import { StatusBar } from "expo-status-bar";
import { useCallback, useEffect, useMemo, useState } from "react";
import { GestureHandlerRootView } from "react-native-gesture-handler";
import "react-native-reanimated";
import { Platform } from "react-native";
import "@/lib/_core/nativewind-pressable";
import { ThemeProvider } from "@/lib/theme-provider";
import { TelnetProvider } from "@/lib/telnet-provider";
import { ExpertModeProvider } from "@/lib/expert-mode-provider";
import { ProfilesProvider } from "@/lib/profiles-provider";
import { UsbStatusProvider } from "@/lib/usb-status-context";
import {
  SafeAreaFrameContext,
  SafeAreaInsetsContext,
  SafeAreaProvider,
  initialWindowMetrics,
} from "react-native-safe-area-context";
import type { EdgeInsets, Metrics, Rect } from "react-native-safe-area-context";

import { trpc, createTRPCClient } from "@/lib/trpc";
import { initManusRuntime, subscribeSafeAreaInsets } from "@/lib/_core/manus-runtime";
import { NotificationService } from "@/lib/notification-service";
import { OnboardingModal } from "@/components/onboarding-modal";
import { useOnboarding } from "@/hooks/use-onboarding";

const DEFAULT_WEB_INSETS: EdgeInsets = { top: 0, right: 0, bottom: 0, left: 0 };
const DEFAULT_WEB_FRAME: Rect = { x: 0, y: 0, width: 0, height: 0 };

export const unstable_settings = {
  anchor: "(tabs)",
};

export default function RootLayout() {
  const initialInsets = initialWindowMetrics?.insets ?? DEFAULT_WEB_INSETS;
  const initialFrame = initialWindowMetrics?.frame ?? DEFAULT_WEB_FRAME;

  const [insets, setInsets] = useState<EdgeInsets>(initialInsets);
  const [frame, setFrame] = useState<Rect>(initialFrame);
  
  // Onboarding state
  const { isFirstLaunch, isLoading, completeOnboarding } = useOnboarding();

  // Initialize Manus runtime for cookie injection from parent container
  useEffect(() => {
    initManusRuntime();
    // Solicitar permisos de notificaciones al iniciar
    NotificationService.requestPermissions();
  }, []);

  const handleSafeAreaUpdate = useCallback((metrics: Metrics) => {
    setInsets(metrics.insets);
    setFrame(metrics.frame);
  }, []);

  useEffect(() => {
    if (Platform.OS !== "web") return;
    const unsubscribe = subscribeSafeAreaInsets(handleSafeAreaUpdate);
    return () => unsubscribe();
  }, [handleSafeAreaUpdate]);

  // Create clients once and reuse them
  const [queryClient] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            // Disable automatic refetching on window focus for mobile
            refetchOnWindowFocus: false,
            // Retry failed requests once
            retry: 1,
          },
        },
      }),
  );
  const [trpcClient] = useState(() => createTRPCClient());

  // Ensure minimum 8px padding for top and bottom on mobile
  const providerInitialMetrics = useMemo(() => {
    const metrics = initialWindowMetrics ?? { insets: initialInsets, frame: initialFrame };
    return {
      ...metrics,
      insets: {
        ...metrics.insets,
        top: Math.max(metrics.insets.top, 16),
        bottom: Math.max(metrics.insets.bottom, 12),
      },
    };
  }, [initialInsets, initialFrame]);

  const content = (
    <GestureHandlerRootView style={{ flex: 1 }}>
      <trpc.Provider client={trpcClient} queryClient={queryClient}>
        <QueryClientProvider client={queryClient}>
          {/* Default to hiding native headers so raw route segments don't appear (e.g. "(tabs)", "products/[id]"). */}
          {/* If a screen needs the native header, explicitly enable it and set a human title via Stack.Screen options. */}
          <Stack screenOptions={{ headerShown: false }}>
            <Stack.Screen name="(tabs)" />
            <Stack.Screen name="oauth/callback" />
          </Stack>
          <StatusBar style="auto" />
          
          {/* Onboarding Modal */}
          {!isLoading && isFirstLaunch && (
            <OnboardingModal
              visible={true}
              onComplete={completeOnboarding}
            />
          )}
        </QueryClientProvider>
      </trpc.Provider>
    </GestureHandlerRootView>
  );

  const shouldOverrideSafeArea = Platform.OS === "web";

  if (shouldOverrideSafeArea) {
    return (
      <ThemeProvider>
        <ProfilesProvider>
          <ExpertModeProvider>
            <TelnetProvider>
              <UsbStatusProvider>
                <SafeAreaProvider initialMetrics={providerInitialMetrics}>
              <SafeAreaFrameContext.Provider value={frame}>
                <SafeAreaInsetsContext.Provider value={insets}>
                  {content}
                </SafeAreaInsetsContext.Provider>
              </SafeAreaFrameContext.Provider>
                </SafeAreaProvider>
              </UsbStatusProvider>
            </TelnetProvider>
          </ExpertModeProvider>
        </ProfilesProvider>
      </ThemeProvider>
    );
  }

  return (
    <ThemeProvider>
      <ProfilesProvider>
        <ExpertModeProvider>
          <TelnetProvider>
            <UsbStatusProvider>
              <SafeAreaProvider initialMetrics={providerInitialMetrics}>{content}</SafeAreaProvider>
            </UsbStatusProvider>
          </TelnetProvider>
        </ExpertModeProvider>
      </ProfilesProvider>
    </ThemeProvider>
  );
}

================================================================================
FILE: app/dev/theme-lab.tsx
================================================================================

import { useMemo, useState } from "react";
import { Pressable, ScrollView, StyleSheet, Text, TouchableOpacity, View } from "react-native";

import { ScreenContainer } from "@/components/screen-container";
import { ThemedView } from "@/components/themed-view";
import { IconSymbol } from "@/components/ui/icon-symbol";
import { SchemeColors, type ColorScheme } from "@/constants/theme";
import { useColors } from "@/hooks/use-colors";
import { useThemeContext } from "@/lib/theme-provider";

type PaletteName = keyof typeof SchemeColors.light;

const paletteNames: PaletteName[] = Object.keys(SchemeColors.light) as PaletteName[];

function ColorSwatch({ name, value }: { name: PaletteName; value: string }) {
  return (
    <View className="flex-row items-center justify-between rounded-xl border border-border px-3 py-2">
      <View className="flex-row items-center gap-3">
        <View className="h-6 w-6 rounded-full border border-border" style={{ backgroundColor: value }} />
        <Text className="text-sm font-semibold text-foreground">{name}</Text>
      </View>
      <Text className="text-xs font-mono text-muted">{value}</Text>
    </View>
  );
}

export default function ThemeLabScreen() {
  const [pressCount, setPressCount] = useState(0);
  const [lastAction, setLastAction] = useState<string>("None yet");
  const { colorScheme, setColorScheme } = useThemeContext();
  const colors = useColors();

  const swatches = useMemo(
    () =>
      paletteNames.map((name) => ({
        name,
        value: SchemeColors[colorScheme][name],
      })),
    [colorScheme],
  );

  const tileStyles = useMemo(() => {
    const build = (scheme: ColorScheme) => ({
      background: SchemeColors[scheme].background,
      border: SchemeColors[scheme].border,
      text: SchemeColors[scheme].foreground,
      subText: SchemeColors[scheme].muted,
      activeBackground: SchemeColors[scheme].primary,
      activeText: SchemeColors[scheme].background,
    });
    return {
      light: build("light"),
      dark: build("dark"),
    };
  }, []);

  return (
    <ScreenContainer className="p-5">
      <ScrollView className="flex-1">
        <View className="gap-4 pb-8">
          <View className="flex-row gap-2">
            {(["light", "dark"] as ColorScheme[]).map((scheme) => (
              <Pressable
                key={scheme}
                style={[
                  styles.schemeToggle,
                  {
                    backgroundColor:
                      colorScheme === scheme
                        ? tileStyles[scheme].activeBackground
                        : tileStyles[scheme].background,
                    borderColor:
                      colorScheme === scheme
                        ? tileStyles[scheme].activeBackground
                        : tileStyles[scheme].border,
                  },
                ]}
                onPress={() => {
                  setColorScheme(scheme);
                  setLastAction(`Applied ${scheme} globally`);
                }}
              >
                <Text
                  style={[
                    styles.schemeToggleTitle,
                    {
                      color:
                        colorScheme === scheme
                          ? tileStyles[scheme].activeText
                          : tileStyles[scheme].text,
                    },
                  ]}
                >
                  {scheme === "light" ? "Light preview" : "Dark preview"}
                </Text>
                <Text
                  style={[
                    styles.schemeToggleSubtitle,
                    {
                      color:
                        colorScheme === scheme
                          ? tileStyles[scheme].activeText
                          : tileStyles[scheme].subText,
                    },
                  ]}
                >
                  Global theme (NativeWind + useColors)
                </Text>
              </Pressable>
            ))}
          </View>

          <ThemedView className="rounded-2xl border border-border p-4">
            <Text className="text-lg font-bold text-foreground">
              Tailwind tokens
            </Text>
            <Text className="mt-1 text-sm text-muted">
              Buttons and badges driven by global {colorScheme} palette
            </Text>

            <View className="mt-4 flex-row flex-wrap gap-2">
              <TouchableOpacity
                className="rounded-full px-4 py-2"
                style={{ backgroundColor: SchemeColors[colorScheme].primary }}
                onPress={() => {
                  setPressCount((count) => count + 1);
                  setLastAction("Pressed Primary token");
                }}
              >
                <Text className="text-sm font-semibold text-background">Primary</Text>
              </TouchableOpacity>
              <TouchableOpacity
                className="rounded-full px-4 py-2 border border-border"
                style={{ backgroundColor: SchemeColors[colorScheme].surface }}
                onPress={() => {
                  setPressCount((count) => count + 1);
                  setLastAction("Pressed Surface token");
                }}
              >
                <Text className="text-sm font-semibold text-foreground">
                  Surface
                </Text>
              </TouchableOpacity>
              <TouchableOpacity
                className="rounded-full px-4 py-2"
                style={{ backgroundColor: SchemeColors[colorScheme].success }}
                onPress={() => {
                  setPressCount((count) => count + 1);
                  setLastAction("Pressed Success token");
                }}
              >
                <Text className="text-sm font-semibold text-background">
                  Success
                </Text>
              </TouchableOpacity>
              <TouchableOpacity
                className="rounded-full px-4 py-2"
                style={{ backgroundColor: SchemeColors[colorScheme].warning }}
                onPress={() => {
                  setPressCount((count) => count + 1);
                  setLastAction("Pressed Warning token");
                }}
              >
                <Text className="text-sm font-semibold text-background">
                  Warning
                </Text>
              </TouchableOpacity>
              <TouchableOpacity
                className="rounded-full px-4 py-2"
                style={{ backgroundColor: SchemeColors[colorScheme].error }}
                onPress={() => {
                  setPressCount((count) => count + 1);
                  setLastAction("Pressed Error token");
                }}
              >
                <Text className="text-sm font-semibold text-background">
                  Error
                </Text>
              </TouchableOpacity>
            </View>

            <View className="mt-4 rounded-xl bg-background p-4 border border-border">
              <Text className="text-base font-semibold text-foreground">
                useColors()
              </Text>
              <Text className="mt-1 text-sm text-muted">
                Background: {colors.background} ‚Ä¢ Text: {colors.text} ‚Ä¢ Tint: {colors.tint}
              </Text>
              <Text className="text-xs text-muted">
                (Pressable uses style; Tailwind on Pressable is disabled via remap)
              </Text>
              <View className="mt-3 gap-2">
                <View className="flex-row items-center gap-2">
                  <IconSymbol name="house.fill" color={colors.tint} size={20} />
                  <Text className="text-sm text-foreground">
                    Press count: {pressCount}
                  </Text>
                </View>
                <Text className="text-sm text-muted">
                  Last action: {lastAction}
                </Text>
              </View>
            </View>
          </ThemedView>

          <ThemedView className="rounded-2xl border border-border p-4">
            <Text className="text-lg font-bold text-foreground">
              Palette values
            </Text>
            <Text className="mt-1 text-sm text-muted">
              Live values for the selected scheme
            </Text>
            <View className="mt-3 gap-2">
              {swatches.map((item) => (
                <ColorSwatch key={item.name} name={item.name} value={item.value} />
              ))}
            </View>
          </ThemedView>
        </View>
      </ScrollView>
    </ScreenContainer>
  );
}

const styles = StyleSheet.create({
  schemeToggle: {
    flex: 1,
    borderWidth: 1,
    borderRadius: 16,
    paddingHorizontal: 16,
    paddingVertical: 12,
    gap: 4,
  },
  schemeToggleTitle: {
    fontSize: 16,
    fontWeight: "600",
  },
  schemeToggleSubtitle: {
    fontSize: 12,
  },
});

================================================================================
FILE: app/oauth/callback.tsx
================================================================================

import { ThemedView } from "@/components/themed-view";
import * as Api from "@/lib/_core/api";
import * as Auth from "@/lib/_core/auth";
import * as Linking from "expo-linking";
import { useLocalSearchParams, useRouter } from "expo-router";
import { useEffect, useState } from "react";
import { ActivityIndicator, Text } from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";

export default function OAuthCallback() {
  const router = useRouter();
  const params = useLocalSearchParams<{
    code?: string;
    state?: string;
    error?: string;
    sessionToken?: string;
    user?: string;
  }>();
  const [status, setStatus] = useState<"processing" | "success" | "error">("processing");
  const [errorMessage, setErrorMessage] = useState<string | null>(null);

  useEffect(() => {
    const handleCallback = async () => {
      console.log("[OAuth] Callback handler triggered");
      console.log("[OAuth] Params received:", {
        code: params.code,
        state: params.state,
        error: params.error,
        sessionToken: params.sessionToken ? "present" : "missing",
        user: params.user ? "present" : "missing",
      });
      try {
        // Check for sessionToken in params first (web OAuth callback from server redirect)
        if (params.sessionToken) {
          console.log("[OAuth] Session token found in params (web callback)");
          await Auth.setSessionToken(params.sessionToken);

          // Decode and store user info if available
          if (params.user) {
            try {
              // Use atob for base64 decoding (works in both web and React Native)
              const userJson =
                typeof atob !== "undefined"
                  ? atob(params.user)
                  : Buffer.from(params.user, "base64").toString("utf-8");
              const userData = JSON.parse(userJson);
              const userInfo: Auth.User = {
                id: userData.id,
                openId: userData.openId,
                name: userData.name,
                email: userData.email,
                loginMethod: userData.loginMethod,
                lastSignedIn: new Date(userData.lastSignedIn || Date.now()),
              };
              await Auth.setUserInfo(userInfo);
              console.log("[OAuth] User info stored:", userInfo);
            } catch (err) {
              console.error("[OAuth] Failed to parse user data:", err);
            }
          }

          setStatus("success");
          console.log("[OAuth] Web authentication successful, redirecting to home...");
          setTimeout(() => {
            router.replace("/(tabs)");
          }, 1000);
          return;
        }

        // Get URL from params or Linking
        let url: string | null = null;

        // Try to get from local search params first (works with expo-router)
        if (params.code || params.state || params.error) {
          console.log("[OAuth] Found params in route params");
          // Extract from params
          const urlParams = new URLSearchParams();
          if (params.code) urlParams.set("code", params.code);
          if (params.state) urlParams.set("state", params.state);
          if (params.error) urlParams.set("error", params.error);
          url = `?${urlParams.toString()}`;
          console.log("[OAuth] Constructed URL from params:", url);
        } else {
          console.log("[OAuth] No params found, checking Linking.getInitialURL()...");
          // Fallback: try to get from Linking
          const initialUrl = await Linking.getInitialURL();
          console.log("[OAuth] Linking.getInitialURL():", initialUrl);
          if (initialUrl) {
            url = initialUrl;
          }
        }

        // Check for error
        const error =
          params.error || (url ? new URL(url, "http://dummy").searchParams.get("error") : null);
        if (error) {
          console.error("[OAuth] Error parameter found:", error);
          setStatus("error");
          setErrorMessage(error || "OAuth error occurred");
          return;
        }

        // Check for code and state
        let code: string | null = null;
        let state: string | null = null;
        let sessionToken: string | null = null;

        // Try to get from params first
        if (params.code && params.state) {
          console.log("[OAuth] Using code and state from route params");
          code = params.code;
          state = params.state;
        } else if (url) {
          console.log("[OAuth] Parsing code and state from URL:", url);
          // Parse from URL
          try {
            const urlObj = new URL(url);
            code = urlObj.searchParams.get("code");
            state = urlObj.searchParams.get("state");
            sessionToken = urlObj.searchParams.get("sessionToken");
            console.log("[OAuth] Extracted from URL:", {
              code: code?.substring(0, 20) + "...",
              state: state?.substring(0, 20) + "...",
              sessionToken: sessionToken ? "present" : "missing",
            });
          } catch (e) {
            console.log("[OAuth] Failed to parse as full URL, trying regex:", e);
            // Try parsing as relative URL with query params
            const match = url.match(/[?&](code|state|sessionToken)=([^&]+)/g);
            if (match) {
              match.forEach((param) => {
                const [key, value] = param.substring(1).split("=");
                if (key === "code") code = decodeURIComponent(value);
                if (key === "state") state = decodeURIComponent(value);
                if (key === "sessionToken") sessionToken = decodeURIComponent(value);
              });
              console.log("[OAuth] Extracted from regex:", {
                code: code?.substring(0, 20) + "...",
                state: state?.substring(0, 20) + "...",
                sessionToken: sessionToken ? "present" : "missing",
              });
            }
          }
        }

        console.log("[OAuth] Final extracted values:", {
          hasCode: !!code,
          hasState: !!state,
          hasSessionToken: !!sessionToken,
        });

        // If we have sessionToken directly from URL, use it
        if (sessionToken) {
          console.log("[OAuth] Session token found in URL, storing...");
          await Auth.setSessionToken(sessionToken);
          console.log("[OAuth] Session token stored successfully");
          // User info is already in the OAuth callback response
          // No need to fetch from API
          setStatus("success");
          console.log("[OAuth] Redirecting to home...");
          setTimeout(() => {
            router.replace("/(tabs)");
          }, 1000);
          return;
        }

        // Otherwise, exchange code for session token
        if (!code || !state) {
          console.error("[OAuth] Missing code or state parameter", {
            hasCode: !!code,
            hasState: !!state,
          });
          setStatus("error");
          setErrorMessage("Missing code or state parameter");
          return;
        }

        // Exchange code for session token
        console.log("[OAuth] Exchanging code for session token...", {
          code: code.substring(0, 20) + "...",
          state: state.substring(0, 20) + "...",
        });
        const result = await Api.exchangeOAuthCode(code, state);
        console.log("[OAuth] Exchange result:", {
          hasSessionToken: !!result.sessionToken,
          hasUser: !!result.user,
        });

        if (result.sessionToken) {
          console.log("[OAuth] Session token received, storing...");
          // Store session token
          await Auth.setSessionToken(result.sessionToken);
          console.log("[OAuth] Session token stored successfully");

          // Store user info if available
          if (result.user) {
            console.log("[OAuth] User data received:", result.user);
            const userInfo: Auth.User = {
              id: result.user.id,
              openId: result.user.openId,
              name: result.user.name,
              email: result.user.email,
              loginMethod: result.user.loginMethod,
              lastSignedIn: new Date(result.user.lastSignedIn || Date.now()),
            };
            await Auth.setUserInfo(userInfo);
            console.log("[OAuth] User info stored:", userInfo);
          } else {
            console.log("[OAuth] No user data in result");
          }

          setStatus("success");
          console.log("[OAuth] Authentication successful, redirecting to home...");

          // Redirect to home after a short delay
          setTimeout(() => {
            console.log("[OAuth] Executing redirect...");
            router.replace("/(tabs)");
          }, 1000);
        } else {
          console.error("[OAuth] No session token in result:", result);
          setStatus("error");
          setErrorMessage("No session token received");
        }
      } catch (error) {
        console.error("[OAuth] Callback error:", error);
        setStatus("error");
        setErrorMessage(
          error instanceof Error ? error.message : "Failed to complete authentication",
        );
      }
    };

    handleCallback();
  }, [params.code, params.state, params.error, params.sessionToken, params.user, router]);

  return (
    <SafeAreaView className="flex-1" edges={["top", "bottom", "left", "right"]}>
      <ThemedView className="flex-1 items-center justify-center gap-4 p-5">
        {status === "processing" && (
          <>
            <ActivityIndicator size="large" />
            <Text className="mt-4 text-base leading-6 text-center text-foreground">
              Completing authentication...
            </Text>
          </>
        )}
        {status === "success" && (
          <>
            <Text className="text-base leading-6 text-center text-foreground">
              Authentication successful!
            </Text>
            <Text className="text-base leading-6 text-center text-foreground">
              Redirecting...
            </Text>
          </>
        )}
        {status === "error" && (
          <>
            <Text className="mb-2 text-xl font-bold leading-7 text-error">
              Authentication failed
            </Text>
            <Text className="text-base leading-6 text-center text-foreground">
              {errorMessage}
            </Text>
          </>
        )}
      </ThemedView>
    </SafeAreaView>
  );
}

================================================================================
FILE: components/chipset-status-badge.tsx
================================================================================

import { View, Text, StyleSheet } from 'react-native';
import { useEffect } from 'react';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withRepeat,
  withSequence,
  withTiming,
  Easing,
} from 'react-native-reanimated';
import { useColors } from '@/hooks/use-colors';

export type ChipsetCompatibility = 'confirmed' | 'experimental' | 'incompatible' | 'unknown';

interface ChipsetStatusBadgeProps {
  chipset: string;
  compatibility: ChipsetCompatibility;
  animated?: boolean;
}

export function ChipsetStatusBadge({ chipset, compatibility, animated = true }: ChipsetStatusBadgeProps) {
  const colors = useColors();
  const scale = useSharedValue(1);
  const opacity = useSharedValue(1);

  useEffect(() => {
    if (animated && compatibility === 'confirmed') {
      // Animaci√≥n de pulso para chipsets confirmados
      scale.value = withRepeat(
        withSequence(
          withTiming(1.05, { duration: 1000, easing: Easing.inOut(Easing.ease) }),
          withTiming(1, { duration: 1000, easing: Easing.inOut(Easing.ease) })
        ),
        -1, // Repetir infinitamente
        false
      );
    } else if (animated && compatibility === 'experimental') {
      // Animaci√≥n de fade para chipsets experimentales
      opacity.value = withRepeat(
        withSequence(
          withTiming(0.7, { duration: 1500, easing: Easing.inOut(Easing.ease) }),
          withTiming(1, { duration: 1500, easing: Easing.inOut(Easing.ease) })
        ),
        -1,
        false
      );
    }
  }, [compatibility, animated]);

  const animatedStyle = useAnimatedStyle(() => {
    return {
      transform: [{ scale: scale.value }],
      opacity: opacity.value,
    };
  });

  const getStatusConfig = () => {
    switch (compatibility) {
      case 'confirmed':
        return {
          icon: '‚úÖ',
          label: 'Confirmado Compatible',
          bgColor: 'rgba(34, 197, 94, 0.1)', // green
          borderColor: 'rgba(34, 197, 94, 0.5)',
          textColor: '#22C55E',
        };
      case 'experimental':
        return {
          icon: '‚ö†Ô∏è',
          label: 'Experimental',
          bgColor: 'rgba(251, 191, 36, 0.1)', // yellow
          borderColor: 'rgba(251, 191, 36, 0.5)',
          textColor: '#FBBF24',
        };
      case 'incompatible':
        return {
          icon: '‚ùå',
          label: 'Incompatible',
          bgColor: 'rgba(239, 68, 68, 0.1)', // red
          borderColor: 'rgba(239, 68, 68, 0.5)',
          textColor: '#EF4444',
        };
      default:
        return {
          icon: '‚ùì',
          label: 'Desconocido',
          bgColor: 'rgba(156, 163, 175, 0.1)', // gray
          borderColor: 'rgba(156, 163, 175, 0.5)',
          textColor: '#9CA3AF',
        };
    }
  };

  const config = getStatusConfig();

  return (
    <Animated.View
      style={[
        styles.container,
        {
          backgroundColor: config.bgColor,
          borderColor: config.borderColor,
        },
        animated ? animatedStyle : {},
      ]}
    >
      <Text style={styles.icon}>{config.icon}</Text>
      <View style={styles.textContainer}>
        <Text style={[styles.label, { color: config.textColor }]}>
          {config.label}
        </Text>
        <Text style={[styles.chipset, { color: colors.muted }]}>
          {chipset}
        </Text>
      </View>
    </Animated.View>
  );
}

const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderRadius: 12,
    borderWidth: 1,
    gap: 12,
  },
  icon: {
    fontSize: 24,
  },
  textContainer: {
    flex: 1,
    gap: 4,
  },
  label: {
    fontSize: 14,
    fontWeight: '600',
  },
  chipset: {
    fontSize: 12,
  },
});

================================================================================
FILE: components/eeprom-progress-indicator.tsx
================================================================================

import { View, Text } from 'react-native';
import { useEffect } from 'react';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  Easing,
} from 'react-native-reanimated';
import { useColors } from '@/hooks/use-colors';

interface EepromProgressIndicatorProps {
  progress: number; // 0-100
  bytesProcessed: number;
  totalBytes: number;
  operation: 'read' | 'write';
  estimatedTimeRemaining?: number; // segundos
}

export function EepromProgressIndicator({
  progress,
  bytesProcessed,
  totalBytes,
  operation,
  estimatedTimeRemaining,
}: EepromProgressIndicatorProps) {
  const colors = useColors();
  const progressWidth = useSharedValue(0);

  useEffect(() => {
    progressWidth.value = withTiming(progress, {
      duration: 300,
      easing: Easing.out(Easing.cubic),
    });
  }, [progress]);

  const animatedStyle = useAnimatedStyle(() => ({
    width: `${progressWidth.value}%`,
  }));

  const formatBytes = (bytes: number) => {
    if (bytes < 1024) return `${bytes} B`;
    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
    return `${(bytes / (1024 * 1024)).toFixed(2)} MB`;
  };

  const formatTime = (seconds: number) => {
    if (seconds < 60) return `${Math.ceil(seconds)}s`;
    const mins = Math.floor(seconds / 60);
    const secs = Math.ceil(seconds % 60);
    return `${mins}m ${secs}s`;
  };

  return (
    <View className="bg-surface rounded-xl p-4 border border-border">
      {/* Header */}
      <View className="flex-row items-center justify-between mb-3">
        <View className="flex-row items-center gap-2">
          <Text className="text-2xl">
            {operation === 'read' ? 'üìñ' : '‚úçÔ∏è'}
          </Text>
          <Text className="text-base font-bold text-foreground">
            {operation === 'read' ? 'Leyendo EEPROM' : 'Escribiendo EEPROM'}
          </Text>
        </View>
        <Text className="text-lg font-bold text-primary">
          {Math.round(progress)}%
        </Text>
      </View>

      {/* Barra de Progreso */}
      <View className="h-3 bg-muted/20 rounded-full overflow-hidden mb-3">
        <Animated.View
          style={[
            animatedStyle,
            {
              height: '100%',
              backgroundColor: colors.primary,
              borderRadius: 999,
            },
          ]}
        />
      </View>

      {/* Informaci√≥n Detallada */}
      <View className="gap-2">
        <View className="flex-row justify-between">
          <Text className="text-sm text-muted">Bytes procesados:</Text>
          <Text className="text-sm text-foreground font-mono">
            {formatBytes(bytesProcessed)} / {formatBytes(totalBytes)}
          </Text>
        </View>

        {estimatedTimeRemaining !== undefined && estimatedTimeRemaining > 0 && (
          <View className="flex-row justify-between">
            <Text className="text-sm text-muted">Tiempo restante:</Text>
            <Text className="text-sm text-foreground font-mono">
              ~{formatTime(estimatedTimeRemaining)}
            </Text>
          </View>
        )}

        {progress >= 100 && (
          <View className="mt-2 bg-green-500/10 rounded-lg p-2">
            <Text className="text-sm text-green-500 font-semibold text-center">
              ‚úÖ {operation === 'read' ? 'Lectura' : 'Escritura'} completada
            </Text>
          </View>
        )}
      </View>
    </View>
  );
}

================================================================================
FILE: components/external-link.tsx
================================================================================

import { Href, Link } from "expo-router";
import { openBrowserAsync, WebBrowserPresentationStyle } from "expo-web-browser";
import { type ComponentProps } from "react";

type Props = Omit<ComponentProps<typeof Link>, "href"> & { href: Href & string };

export function ExternalLink({ href, ...rest }: Props) {
  return (
    <Link
      target="_blank"
      {...rest}
      href={href}
      onPress={async (event) => {
        if (process.env.EXPO_OS !== "web") {
          // Prevent the default behavior of linking to the default browser on native.
          event.preventDefault();
          // Open the link in an in-app browser.
          await openBrowserAsync(href, {
            presentationStyle: WebBrowserPresentationStyle.AUTOMATIC,
          });
        }
      }}
    />
  );
}

================================================================================
FILE: components/haptic-tab.tsx
================================================================================

import { BottomTabBarButtonProps } from "@react-navigation/bottom-tabs";
import { PlatformPressable } from "@react-navigation/elements";
import * as Haptics from "expo-haptics";

export function HapticTab(props: BottomTabBarButtonProps) {
  return (
    <PlatformPressable
      {...props}
      onPressIn={(ev) => {
        if (process.env.EXPO_OS === "ios") {
          // Add a soft haptic feedback when pressing down on the tabs.
          Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
        }
        props.onPressIn?.(ev);
      }}
    />
  );
}

================================================================================
FILE: components/hello-wave.tsx
================================================================================

import Animated from "react-native-reanimated";

export function HelloWave() {
  return (
    <Animated.Text
      style={{
        fontSize: 28,
        lineHeight: 32,
        marginTop: -6,
        animationName: {
          "50%": { transform: [{ rotate: "25deg" }] },
        },
        animationIterationCount: 4,
        animationDuration: "300ms",
      }}
    >
      üëã
    </Animated.Text>
  );
}

================================================================================
FILE: components/onboarding-modal.tsx
================================================================================

import { useState } from 'react';
import { View, Text, Modal, TouchableOpacity, ScrollView, Dimensions } from 'react-native';
import Animated, { FadeIn, FadeOut, SlideInRight, SlideOutLeft } from 'react-native-reanimated';
import { useColors } from '@/hooks/use-colors';

const { width } = Dimensions.get('window');

interface OnboardingStep {
  id: number;
  icon: string;
  title: string;
  description: string;
  details: string[];
}

const ONBOARDING_STEPS: OnboardingStep[] = [
  {
    id: 1,
    icon: 'üîå',
    title: 'Conectar Adaptador USB',
    description: 'Conecta tu adaptador USB-Ethernet al dispositivo Android usando un cable OTG con alimentaci√≥n externa.',
    details: [
      'Usa un cable OTG con alimentaci√≥n externa (5V)',
      'Conecta el adaptador USB-Ethernet al cable OTG',
      'Espera a que el LED del adaptador se encienda',
      'La app detectar√° autom√°ticamente el dispositivo',
    ],
  },
  {
    id: 2,
    icon: 'üîç',
    title: 'Verificar Compatibilidad',
    description: 'La app detectar√° autom√°ticamente el chipset y mostrar√° si es compatible para spoofing MIB2.',
    details: [
      'Ve a la pesta√±a "Estado USB" para ver informaci√≥n del dispositivo',
      'Verifica el badge de compatibilidad:',
      '  ‚úÖ Verde = Confirmado compatible',
      '  ‚ö†Ô∏è Amarillo = Experimental (probablemente funciona)',
      '  ‚ùå Rojo = Incompatible',
      'Solo chipsets ASIX permiten spoofing',
    ],
  },
  {
    id: 3,
    icon: 'üöÄ',
    title: 'Ejecutar Spoofing',
    description: 'Usa Auto Spoof para modificar autom√°ticamente el VID/PID del adaptador a valores compatibles con MIB2.',
    details: [
      'Ve a la pesta√±a "Auto Spoof"',
      'Presiona el bot√≥n "Ejecutar Spoofing Autom√°tico"',
      'La app crear√° un backup autom√°tico antes de modificar',
      'Espera a que termine el proceso (30-60 segundos)',
      'NO desconectes el adaptador durante el proceso',
    ],
  },
  {
    id: 4,
    icon: '‚úÖ',
    title: 'Verificar Resultado',
    description: 'Despu√©s del spoofing, verifica que el VID/PID se modific√≥ correctamente y prueba la conexi√≥n con MIB2.',
    details: [
      'Verifica que el nuevo VID/PID sea 0x2001:0x3C05',
      'Desconecta y reconecta el adaptador',
      'Conecta el adaptador al puerto USB del MIB2',
      'Verifica que el MIB2 reconozca el adaptador',
      'Si falla, restaura desde backup en la pesta√±a "Backups"',
    ],
  },
];

interface OnboardingModalProps {
  visible: boolean;
  onComplete: () => void;
}

export function OnboardingModal({ visible, onComplete }: OnboardingModalProps) {
  const [currentStep, setCurrentStep] = useState(0);
  const colors = useColors();

  const handleNext = () => {
    if (currentStep < ONBOARDING_STEPS.length - 1) {
      setCurrentStep(currentStep + 1);
    } else {
      onComplete();
    }
  };

  const handlePrevious = () => {
    if (currentStep > 0) {
      setCurrentStep(currentStep - 1);
    }
  };

  const handleSkip = () => {
    onComplete();
  };

  const step = ONBOARDING_STEPS[currentStep];

  return (
    <Modal
      visible={visible}
      animationType="fade"
      transparent
      statusBarTranslucent
    >
      <View className="flex-1 bg-black/80 justify-center items-center px-6">
        <Animated.View
          key={currentStep}
          entering={SlideInRight.duration(300)}
          exiting={SlideOutLeft.duration(300)}
          className="bg-surface rounded-3xl p-8 w-full max-w-md border border-border"
          style={{ maxHeight: '80%' }}
        >
          <ScrollView showsVerticalScrollIndicator={false}>
            {/* Progress Indicator */}
            <View className="flex-row justify-center gap-2 mb-6">
              {ONBOARDING_STEPS.map((_, index) => (
                <View
                  key={index}
                  className={`h-2 rounded-full ${
                    index === currentStep
                      ? 'bg-primary w-8'
                      : index < currentStep
                      ? 'bg-primary/50 w-2'
                      : 'bg-border w-2'
                  }`}
                />
              ))}
            </View>

            {/* Icon */}
            <Text className="text-6xl text-center mb-4">{step.icon}</Text>

            {/* Title */}
            <Text className="text-2xl font-bold text-foreground text-center mb-3">
              {step.title}
            </Text>

            {/* Description */}
            <Text className="text-base text-muted text-center mb-6 leading-relaxed">
              {step.description}
            </Text>

            {/* Details */}
            <View className="bg-background rounded-2xl p-4 mb-6">
              {step.details.map((detail, index) => (
                <View key={index} className="flex-row gap-2 mb-2">
                  <Text className="text-primary">‚Ä¢</Text>
                  <Text className="text-sm text-foreground flex-1 leading-relaxed">
                    {detail}
                  </Text>
                </View>
              ))}
            </View>

            {/* Navigation Buttons */}
            <View className="gap-3">
              <TouchableOpacity
                onPress={handleNext}
                className="bg-primary px-6 py-4 rounded-xl active:opacity-80"
              >
                <Text className="text-background font-semibold text-center text-base">
                  {currentStep === ONBOARDING_STEPS.length - 1 ? '¬°Comenzar!' : 'Siguiente'}
                </Text>
              </TouchableOpacity>

              <View className="flex-row gap-3">
                {currentStep > 0 && (
                  <TouchableOpacity
                    onPress={handlePrevious}
                    className="flex-1 bg-surface px-6 py-3 rounded-xl border border-border active:opacity-80"
                  >
                    <Text className="text-foreground font-medium text-center">
                      Anterior
                    </Text>
                  </TouchableOpacity>
                )}

                <TouchableOpacity
                  onPress={handleSkip}
                  className="flex-1 px-6 py-3 rounded-xl active:opacity-80"
                >
                  <Text className="text-muted font-medium text-center">
                    Saltar Tutorial
                  </Text>
                </TouchableOpacity>
              </View>
            </View>
          </ScrollView>
        </Animated.View>
      </View>
    </Modal>
  );
}

================================================================================
FILE: components/parallax-scroll-view.tsx
================================================================================

import type { PropsWithChildren, ReactElement } from "react";
import { View } from "react-native";
import Animated, {
  interpolate,
  useAnimatedRef,
  useAnimatedStyle,
  useScrollOffset,
} from "react-native-reanimated";
import { useSafeAreaInsets } from "react-native-safe-area-context";

import { useColors } from "@/hooks/use-colors";

const HEADER_HEIGHT = 250;

type Props = PropsWithChildren<{
  headerImage: ReactElement;
  headerBackgroundColor?: string;
}>;

/**
 * A scroll view with parallax header effect.
 * Note: Animated components require style objects for dynamic animations.
 */
export default function ParallaxScrollView({
  children,
  headerImage,
  headerBackgroundColor,
}: Props) {
  const colors = useColors();
  const insets = useSafeAreaInsets();
  const scrollRef = useAnimatedRef<Animated.ScrollView>();
  const scrollOffset = useScrollOffset(scrollRef);

  const headerHeight = HEADER_HEIGHT + insets.top;

  const headerAnimatedStyle = useAnimatedStyle(() => ({
    transform: [
      {
        translateY: interpolate(
          scrollOffset.value,
          [-headerHeight, 0, headerHeight],
          [-headerHeight / 2, 0, headerHeight * 0.75],
        ),
      },
      {
        scale: interpolate(scrollOffset.value, [-headerHeight, 0, headerHeight], [2, 1, 1]),
      },
    ],
  }));

  return (
    <Animated.ScrollView
      ref={scrollRef}
      style={{ backgroundColor: colors.background, flex: 1 }}
      contentContainerStyle={{
        paddingBottom: insets.bottom,
        paddingLeft: insets.left,
        paddingRight: insets.right,
      }}
      scrollEventThrottle={16}
    >
      <Animated.View
        style={[
          {
            overflow: "hidden",
            backgroundColor: headerBackgroundColor ?? colors.primary,
            height: headerHeight,
            paddingTop: insets.top,
          },
          headerAnimatedStyle,
        ]}
      >
        {headerImage}
      </Animated.View>
      <View className="flex-1 p-8 gap-4 overflow-hidden bg-background">
        {children}
      </View>
    </Animated.ScrollView>
  );
}

================================================================================
FILE: components/scanning-indicator.tsx
================================================================================

import { View, Text, StyleSheet } from 'react-native';
import { useEffect } from 'react';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withRepeat,
  withTiming,
  withSequence,
  Easing,
} from 'react-native-reanimated';
import { useColors } from '@/hooks/use-colors';

interface ScanningIndicatorProps {
  isScanning: boolean;
  text?: string;
}

export function ScanningIndicator({ isScanning, text = 'Escaneando dispositivos USB...' }: ScanningIndicatorProps) {
  const colors = useColors();
  const rotation = useSharedValue(0);
  const opacity = useSharedValue(0);

  useEffect(() => {
    if (isScanning) {
      // Animaci√≥n de rotaci√≥n para el icono
      rotation.value = withRepeat(
        withTiming(360, { duration: 2000, easing: Easing.linear }),
        -1,
        false
      );
      
      // Fade in
      opacity.value = withTiming(1, { duration: 300 });
    } else {
      // Fade out
      opacity.value = withTiming(0, { duration: 300 });
    }
  }, [isScanning]);

  const animatedIconStyle = useAnimatedStyle(() => {
    return {
      transform: [{ rotate: `${rotation.value}deg` }],
    };
  });

  const animatedContainerStyle = useAnimatedStyle(() => {
    return {
      opacity: opacity.value,
    };
  });

  if (!isScanning) return null;

  return (
    <Animated.View style={[styles.container, animatedContainerStyle]}>
      <Animated.Text style={[styles.icon, animatedIconStyle]}>
        üîÑ
      </Animated.Text>
      <Text style={[styles.text, { color: colors.muted }]}>
        {text}
      </Text>
      <View style={styles.dotsContainer}>
        <AnimatedDot delay={0} />
        <AnimatedDot delay={200} />
        <AnimatedDot delay={400} />
      </View>
    </Animated.View>
  );
}

function AnimatedDot({ delay }: { delay: number }) {
  const colors = useColors();
  const opacity = useSharedValue(0.3);

  useEffect(() => {
    opacity.value = withRepeat(
      withSequence(
        withTiming(1, { duration: 600, easing: Easing.inOut(Easing.ease) }),
        withTiming(0.3, { duration: 600, easing: Easing.inOut(Easing.ease) })
      ),
      -1,
      false
    );
  }, []);

  const animatedStyle = useAnimatedStyle(() => {
    return {
      opacity: opacity.value,
    };
  });

  return (
    <Animated.View
      style={[
        styles.dot,
        { backgroundColor: colors.primary },
        animatedStyle,
      ]}
    />
  );
}

const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 16,
    paddingHorizontal: 20,
    gap: 12,
  },
  icon: {
    fontSize: 20,
  },
  text: {
    fontSize: 14,
    fontWeight: '500',
  },
  dotsContainer: {
    flexDirection: 'row',
    gap: 6,
  },
  dot: {
    width: 6,
    height: 6,
    borderRadius: 3,
  },
});

================================================================================
FILE: components/screen-container.tsx
================================================================================

import { View, type ViewProps } from "react-native";
import { SafeAreaView, type Edge } from "react-native-safe-area-context";

import { cn } from "@/lib/utils";

export interface ScreenContainerProps extends ViewProps {
  /**
   * SafeArea edges to apply. Defaults to ["top", "left", "right"].
   * Bottom is typically handled by Tab Bar.
   */
  edges?: Edge[];
  /**
   * Tailwind className for the content area.
   */
  className?: string;
  /**
   * Additional className for the outer container (background layer).
   */
  containerClassName?: string;
  /**
   * Additional className for the SafeAreaView (content layer).
   */
  safeAreaClassName?: string;
}

/**
 * A container component that properly handles SafeArea and background colors.
 *
 * The outer View extends to full screen (including status bar area) with the background color,
 * while the inner SafeAreaView ensures content is within safe bounds.
 *
 * Usage:
 * ```tsx
 * <ScreenContainer className="p-4">
 *   <Text className="text-2xl font-bold text-foreground">
 *     Welcome
 *   </Text>
 * </ScreenContainer>
 * ```
 */
export function ScreenContainer({
  children,
  edges = ["top", "left", "right"],
  className,
  containerClassName,
  safeAreaClassName,
  style,
  ...props
}: ScreenContainerProps) {
  return (
    <View
      className={cn(
        "flex-1",
        "bg-background",
        containerClassName
      )}
      {...props}
    >
      <SafeAreaView
        edges={edges}
        className={cn("flex-1", safeAreaClassName)}
        style={style}
      >
        <View className={cn("flex-1", className)}>{children}</View>
      </SafeAreaView>
    </View>
  );
}

================================================================================
FILE: components/success-result-modal.tsx
================================================================================

import { View, Text, Modal, TouchableOpacity, ScrollView } from 'react-native';
import Animated, { FadeIn, ZoomIn } from 'react-native-reanimated';
import { useColors } from '@/hooks/use-colors';
import * as Haptics from 'expo-haptics';

interface SpoofingResult {
  originalVID: string;
  originalPID: string;
  newVID: string;
  newPID: string;
  chipset: string;
  deviceName: string;
  timestamp: Date;
}

interface SuccessResultModalProps {
  visible: boolean;
  result: SpoofingResult | null;
  onClose: () => void;
  onShare: () => void;
}

export function SuccessResultModal({
  visible,
  result,
  onClose,
  onShare,
}: SuccessResultModalProps) {
  const colors = useColors();

  if (!result) return null;

  const handleShare = async () => {
    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    onShare();
  };

  const handleClose = async () => {
    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    onClose();
  };

  return (
    <Modal
      visible={visible}
      animationType="fade"
      transparent
      statusBarTranslucent
    >
      <View className="flex-1 bg-black/80 justify-center items-center px-6">
        <Animated.View
          entering={ZoomIn.duration(400)}
          className="bg-surface rounded-3xl p-8 w-full max-w-md border border-border"
        >
          <ScrollView showsVerticalScrollIndicator={false}>
            {/* Success Icon */}
            <Animated.View
              entering={FadeIn.delay(200).duration(400)}
              className="items-center mb-6"
            >
              <View className="bg-green-500/20 rounded-full p-6 mb-4">
                <Text className="text-6xl">‚úÖ</Text>
              </View>
              <Text className="text-2xl font-bold text-foreground text-center">
                ¬°Spoofing Exitoso!
              </Text>
              <Text className="text-base text-muted text-center mt-2">
                El VID/PID se modific√≥ correctamente
              </Text>
            </Animated.View>

            {/* Device Info */}
            <View className="bg-background rounded-2xl p-4 mb-6">
              <Text className="text-sm font-semibold text-foreground mb-3">
                Informaci√≥n del Dispositivo
              </Text>
              <View className="gap-2">
                <View className="flex-row justify-between">
                  <Text className="text-sm text-muted">Dispositivo:</Text>
                  <Text className="text-sm text-foreground font-medium">
                    {result.deviceName}
                  </Text>
                </View>
                <View className="flex-row justify-between">
                  <Text className="text-sm text-muted">Chipset:</Text>
                  <Text className="text-sm text-foreground font-medium">
                    {result.chipset}
                  </Text>
                </View>
                <View className="flex-row justify-between">
                  <Text className="text-sm text-muted">Fecha:</Text>
                  <Text className="text-sm text-foreground font-medium">
                    {result.timestamp.toLocaleString('es-ES', {
                      day: '2-digit',
                      month: '2-digit',
                      year: 'numeric',
                      hour: '2-digit',
                      minute: '2-digit',
                    })}
                  </Text>
                </View>
              </View>
            </View>

            {/* Before/After Comparison */}
            <View className="gap-4 mb-6">
              {/* Before */}
              <View className="bg-red-900/20 rounded-2xl p-4 border border-red-700">
                <Text className="text-sm font-semibold text-red-400 mb-3">
                  ‚ùå Antes (Original)
                </Text>
                <View className="gap-2">
                  <View className="flex-row justify-between">
                    <Text className="text-sm text-red-300">VID:</Text>
                    <Text className="text-sm text-red-200 font-mono font-bold">
                      {result.originalVID}
                    </Text>
                  </View>
                  <View className="flex-row justify-between">
                    <Text className="text-sm text-red-300">PID:</Text>
                    <Text className="text-sm text-red-200 font-mono font-bold">
                      {result.originalPID}
                    </Text>
                  </View>
                </View>
              </View>

              {/* Arrow */}
              <View className="items-center">
                <Text className="text-3xl text-primary">‚¨áÔ∏è</Text>
              </View>

              {/* After */}
              <View className="bg-green-900/20 rounded-2xl p-4 border border-green-700">
                <Text className="text-sm font-semibold text-green-400 mb-3">
                  ‚úÖ Despu√©s (Modificado)
                </Text>
                <View className="gap-2">
                  <View className="flex-row justify-between">
                    <Text className="text-sm text-green-300">VID:</Text>
                    <Text className="text-sm text-green-200 font-mono font-bold">
                      {result.newVID}
                    </Text>
                  </View>
                  <View className="flex-row justify-between">
                    <Text className="text-sm text-green-300">PID:</Text>
                    <Text className="text-sm text-green-200 font-mono font-bold">
                      {result.newPID}
                    </Text>
                  </View>
                </View>
              </View>
            </View>

            {/* Next Steps */}
            <View className="bg-yellow-900/20 rounded-2xl p-4 border border-yellow-700 mb-6">
              <Text className="text-sm font-semibold text-yellow-400 mb-2">
                üìù Pr√≥ximos Pasos
              </Text>
              <View className="gap-1">
                <Text className="text-sm text-yellow-300">
                  1. Desconecta y reconecta el adaptador
                </Text>
                <Text className="text-sm text-yellow-300">
                  2. Conecta al puerto USB del MIB2
                </Text>
                <Text className="text-sm text-yellow-300">
                  3. Verifica que el MIB2 lo reconozca
                </Text>
              </View>
            </View>

            {/* Action Buttons */}
            <View className="gap-3">
              <TouchableOpacity
                onPress={handleShare}
                className="bg-primary px-6 py-4 rounded-xl active:opacity-80"
              >
                <Text className="text-background font-semibold text-center text-base">
                  üì§ Compartir Resultado
                </Text>
              </TouchableOpacity>

              <TouchableOpacity
                onPress={handleClose}
                className="bg-surface px-6 py-3 rounded-xl border border-border active:opacity-80"
              >
                <Text className="text-foreground font-medium text-center">
                  Cerrar
                </Text>
              </TouchableOpacity>
            </View>
          </ScrollView>
        </Animated.View>
      </View>
    </Modal>
  );
}

================================================================================
FILE: components/themed-view.tsx
================================================================================

import { View, type ViewProps } from "react-native";

import { cn } from "@/lib/utils";

export interface ThemedViewProps extends ViewProps {
  className?: string;
}

/**
 * A View component with automatic theme-aware background.
 * Uses NativeWind for styling - pass className for additional styles.
 */
export function ThemedView({ className, ...otherProps }: ThemedViewProps) {
  return <View className={cn("bg-background", className)} {...otherProps} />;
}

================================================================================
FILE: components/ui/collapsible.tsx
================================================================================

import { PropsWithChildren, useState } from "react";
import { Text, TouchableOpacity, View } from "react-native";

import { IconSymbol } from "@/components/ui/icon-symbol";
import { useColors } from "@/hooks/use-colors";

export function Collapsible({ children, title }: PropsWithChildren & { title: string }) {
  const [isOpen, setIsOpen] = useState(false);
  const colors = useColors();

  return (
    <View className="bg-background">
      <TouchableOpacity
        className="flex-row items-center gap-1.5"
        onPress={() => setIsOpen((value) => !value)}
        activeOpacity={0.8}
      >
        <IconSymbol
          name="chevron.right"
          size={18}
          weight="medium"
          color={colors.icon}
          style={{ transform: [{ rotate: isOpen ? "90deg" : "0deg" }] }}
        />
        <Text className="text-base font-semibold text-foreground">{title}</Text>
      </TouchableOpacity>
      {isOpen && <View className="mt-1.5 ml-6">{children}</View>}
    </View>
  );
}

================================================================================
FILE: components/ui/icon-symbol.ios.tsx
================================================================================

import { SymbolView, SymbolViewProps, SymbolWeight } from "expo-symbols";
import { StyleProp, ViewStyle } from "react-native";

export function IconSymbol({
  name,
  size = 24,
  color,
  style,
  weight = "regular",
}: {
  name: SymbolViewProps["name"];
  size?: number;
  color: string;
  style?: StyleProp<ViewStyle>;
  weight?: SymbolWeight;
}) {
  return (
    <SymbolView
      weight={weight}
      tintColor={color}
      resizeMode="scaleAspectFit"
      name={name}
      style={[
        {
          width: size,
          height: size,
        },
        style,
      ]}
    />
  );
}

================================================================================
FILE: components/ui/icon-symbol.tsx
================================================================================

// Fallback for using MaterialIcons on Android and web.

import MaterialIcons from "@expo/vector-icons/MaterialIcons";
import { SymbolWeight, SymbolViewProps } from "expo-symbols";
import { ComponentProps } from "react";
import { OpaqueColorValue, type StyleProp, type TextStyle } from "react-native";

type IconMapping = Record<SymbolViewProps["name"], ComponentProps<typeof MaterialIcons>["name"]>;
type IconSymbolName = keyof typeof MAPPING;

/**
 * Add your SF Symbols to Material Icons mappings here.
 * - see Material Icons in the [Icons Directory](https://icons.expo.fyi).
 * - see SF Symbols in the [SF Symbols](https://developer.apple.com/sf-symbols/) app.
 */
const MAPPING = {
  "house.fill": "home",
  "person.2.fill": "people",
  "play.fill": "play-arrow",
  "paperplane.fill": "send",
  "chevron.left.forwardslash.chevron.right": "code",
  "chevron.right": "chevron-right",
  "gear": "settings",
  "wrench.fill": "build",
  "key.fill": "vpn-key",
  "hammer.fill": "construction",
  "bolt.fill": "flash-on",
  "folder.fill": "folder",
  "chart.bar.fill": "bar-chart",
  "list.bullet": "list",
  "arrow.clockwise": "refresh",
  "cable.connector": "usb",
  "stethoscope": "bug-report",
  "antenna.radiowaves.left.and.right": "wifi-tethering",
  "bandage.fill": "healing",
} as IconMapping;

/**
 * An icon component that uses native SF Symbols on iOS, and Material Icons on Android and web.
 * This ensures a consistent look across platforms, and optimal resource usage.
 * Icon `name`s are based on SF Symbols and require manual mapping to Material Icons.
 */
export function IconSymbol({
  name,
  size = 24,
  color,
  style,
}: {
  name: IconSymbolName;
  size?: number;
  color: string | OpaqueColorValue;
  style?: StyleProp<TextStyle>;
  weight?: SymbolWeight;
}) {
  return <MaterialIcons color={color} size={size} name={MAPPING[name]} style={style} />;
}

================================================================================
FILE: components/usb-status-indicator.tsx
================================================================================

import { View, Text, Pressable } from 'react-native';
import { useRouter } from 'expo-router';
import { cn } from '@/lib/utils';

export type UsbStatus = 'disconnected' | 'detected' | 'connected';

interface UsbStatusIndicatorProps {
  status: UsbStatus;
  deviceName?: string;
  onPress?: () => void;
}

/**
 * Indicador Visual de Estado USB
 * 
 * Muestra el estado actual de la conexi√≥n USB con colores:
 * - üî¥ Rojo: Desconectado (sin dispositivos)
 * - üü° Amarillo: Detectado (dispositivo encontrado, sin permisos)
 * - üü¢ Verde: Conectado (dispositivo conectado y listo)
 */
export function UsbStatusIndicator({ status, deviceName, onPress }: UsbStatusIndicatorProps) {
  const router = useRouter();

  const handlePress = () => {
    if (onPress) {
      onPress();
    } else {
      // Por defecto, navegar a la pantalla USB Status
      router.push('/(tabs)/usb-status');
    }
  };

  const statusConfig = {
    disconnected: {
      color: 'bg-red-500',
      icon: 'üî¥',
      text: 'Sin Dispositivo USB',
      description: 'Conecta un adaptador USB-Ethernet',
    },
    detected: {
      color: 'bg-yellow-500',
      icon: 'üü°',
      text: 'Dispositivo Detectado',
      description: deviceName || 'Toca para solicitar permisos',
    },
    connected: {
      color: 'bg-green-500',
      icon: 'üü¢',
      text: 'USB Conectado',
      description: deviceName || 'Dispositivo listo',
    },
  };

  const config = statusConfig[status];

  return (
    <Pressable
      onPress={handlePress}
      style={({ pressed }) => [
        { opacity: pressed ? 0.7 : 1 },
      ]}
      className="w-full"
    >
      <View className="bg-surface border border-border rounded-xl p-4 flex-row items-center gap-3">
        {/* Indicador de color */}
        <View className={cn('w-3 h-3 rounded-full', config.color)} />
        
        {/* Icono de estado */}
        <Text className="text-2xl">{config.icon}</Text>
        
        {/* Informaci√≥n de estado */}
        <View className="flex-1">
          <Text className="text-base font-semibold text-foreground">
            {config.text}
          </Text>
          <Text className="text-sm text-muted mt-0.5">
            {config.description}
          </Text>
        </View>
        
        {/* Flecha para indicar que es clickeable */}
        <Text className="text-muted text-xl">‚Ä∫</Text>
      </View>
    </Pressable>
  );
}

================================================================================
FILE: hooks/use-auth.ts
================================================================================

import * as Api from "@/lib/_core/api";
import * as Auth from "@/lib/_core/auth";
import { useCallback, useEffect, useMemo, useState } from "react";
import { Platform } from "react-native";

type UseAuthOptions = {
  autoFetch?: boolean;
};

export function useAuth(options?: UseAuthOptions) {
  const { autoFetch = true } = options ?? {};
  const [user, setUser] = useState<Auth.User | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  const fetchUser = useCallback(async () => {
    console.log("[useAuth] fetchUser called");
    try {
      setLoading(true);
      setError(null);

      // Web platform: use cookie-based auth, fetch user from API
      if (Platform.OS === "web") {
        console.log("[useAuth] Web platform: fetching user from API...");
        const apiUser = await Api.getMe();
        console.log("[useAuth] API user response:", apiUser);

        if (apiUser) {
          const userInfo: Auth.User = {
            id: apiUser.id,
            openId: apiUser.openId,
            name: apiUser.name,
            email: apiUser.email,
            loginMethod: apiUser.loginMethod,
            lastSignedIn: new Date(apiUser.lastSignedIn),
          };
          setUser(userInfo);
          // Cache user info in localStorage for faster subsequent loads
          await Auth.setUserInfo(userInfo);
          console.log("[useAuth] Web user set from API:", userInfo);
        } else {
          console.log("[useAuth] Web: No authenticated user from API");
          setUser(null);
          await Auth.clearUserInfo();
        }
        return;
      }

      // Native platform: use token-based auth
      console.log("[useAuth] Native platform: checking for session token...");
      const sessionToken = await Auth.getSessionToken();
      console.log(
        "[useAuth] Session token:",
        sessionToken ? `present (${sessionToken.substring(0, 20)}...)` : "missing",
      );
      if (!sessionToken) {
        console.log("[useAuth] No session token, setting user to null");
        setUser(null);
        return;
      }

      // Use cached user info for native (token validates the session)
      const cachedUser = await Auth.getUserInfo();
      console.log("[useAuth] Cached user:", cachedUser);
      if (cachedUser) {
        console.log("[useAuth] Using cached user info");
        setUser(cachedUser);
      } else {
        console.log("[useAuth] No cached user, setting user to null");
        setUser(null);
      }
    } catch (err) {
      const error = err instanceof Error ? err : new Error("Failed to fetch user");
      console.error("[useAuth] fetchUser error:", error);
      setError(error);
      setUser(null);
    } finally {
      setLoading(false);
      console.log("[useAuth] fetchUser completed, loading:", false);
    }
  }, []);

  const logout = useCallback(async () => {
    try {
      await Api.logout();
    } catch (err) {
      console.error("[Auth] Logout API call failed:", err);
      // Continue with logout even if API call fails
    } finally {
      await Auth.removeSessionToken();
      await Auth.clearUserInfo();
      setUser(null);
      setError(null);
    }
  }, []);

  const isAuthenticated = useMemo(() => Boolean(user), [user]);

  useEffect(() => {
    console.log("[useAuth] useEffect triggered, autoFetch:", autoFetch, "platform:", Platform.OS);
    if (autoFetch) {
      if (Platform.OS === "web") {
        // Web: fetch user from API directly (user will login manually if needed)
        console.log("[useAuth] Web: fetching user from API...");
        fetchUser();
      } else {
        // Native: check for cached user info first for faster initial load
        Auth.getUserInfo().then((cachedUser) => {
          console.log("[useAuth] Native cached user check:", cachedUser);
          if (cachedUser) {
            console.log("[useAuth] Native: setting cached user immediately");
            setUser(cachedUser);
            setLoading(false);
          } else {
            // No cached user, check session token
            fetchUser();
          }
        });
      }
    } else {
      console.log("[useAuth] autoFetch disabled, setting loading to false");
      setLoading(false);
    }
  }, [autoFetch, fetchUser]);

  useEffect(() => {
    console.log("[useAuth] State updated:", {
      hasUser: !!user,
      loading,
      isAuthenticated,
      error: error?.message,
    });
  }, [user, loading, isAuthenticated, error]);

  return {
    user,
    loading,
    error,
    isAuthenticated,
    refresh: fetchUser,
    logout,
  };
}

================================================================================
FILE: hooks/use-color-scheme.ts
================================================================================

import { useThemeContext } from "@/lib/theme-provider";

export function useColorScheme() {
  return useThemeContext().colorScheme;
}

================================================================================
FILE: hooks/use-color-scheme.web.ts
================================================================================

import { useEffect, useState } from "react";
import { useColorScheme as useRNColorScheme } from "react-native";

/**
 * To support static rendering, this value needs to be re-calculated on the client side for web
 */
export function useColorScheme() {
  const [hasHydrated, setHasHydrated] = useState(false);

  useEffect(() => {
    setHasHydrated(true);
  }, []);

  const colorScheme = useRNColorScheme();

  if (hasHydrated) {
    return colorScheme;
  }

  return "light";
}

================================================================================
FILE: hooks/use-colors.ts
================================================================================

import { Colors, type ColorScheme, type ThemeColorPalette } from "@/constants/theme";
import { useColorScheme } from "./use-color-scheme";

/**
 * Returns the current theme's color palette.
 * Usage: const colors = useColors(); then colors.text, colors.background, etc.
 */
export function useColors(colorSchemeOverride?: ColorScheme): ThemeColorPalette {
  const colorSchema = useColorScheme();
  const scheme = (colorSchemeOverride ?? colorSchema ?? "light") as ColorScheme;
  return Colors[scheme];
}

================================================================================
FILE: hooks/use-onboarding.ts
================================================================================

import { useState, useEffect } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';

const ONBOARDING_KEY = '@mib2_controller:onboarding_completed';

export function useOnboarding() {
  const [isFirstLaunch, setIsFirstLaunch] = useState<boolean | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    checkOnboardingStatus();
  }, []);

  const checkOnboardingStatus = async () => {
    try {
      const value = await AsyncStorage.getItem(ONBOARDING_KEY);
      setIsFirstLaunch(value === null);
    } catch (error) {
      console.error('Error checking onboarding status:', error);
      setIsFirstLaunch(true);
    } finally {
      setIsLoading(false);
    }
  };

  const completeOnboarding = async () => {
    try {
      await AsyncStorage.setItem(ONBOARDING_KEY, 'true');
      setIsFirstLaunch(false);
    } catch (error) {
      console.error('Error completing onboarding:', error);
    }
  };

  const resetOnboarding = async () => {
    try {
      await AsyncStorage.removeItem(ONBOARDING_KEY);
      setIsFirstLaunch(true);
    } catch (error) {
      console.error('Error resetting onboarding:', error);
    }
  };

  return {
    isFirstLaunch,
    isLoading,
    completeOnboarding,
    resetOnboarding,
  };
}

================================================================================
FILE: lib/_core/api.ts
================================================================================

import { Platform } from "react-native";
import { getApiBaseUrl } from "@/constants/oauth";
import * as Auth from "./auth";

type ApiResponse<T> = {
  data?: T;
  error?: string;
};

export async function apiCall<T>(endpoint: string, options: RequestInit = {}): Promise<T> {
  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...((options.headers as Record<string, string>) || {}),
  };

  // Determine the auth method:
  // - Native platform: use stored session token as Bearer auth
  // - Web (including iframe): use cookie-based auth (browser handles automatically)
  //   Cookie is set on backend domain via POST /api/auth/session after receiving token via postMessage
  if (Platform.OS !== "web") {
    const sessionToken = await Auth.getSessionToken();
    console.log("[API] apiCall:", {
      endpoint,
      hasToken: !!sessionToken,
      method: options.method || "GET",
    });
    if (sessionToken) {
      headers["Authorization"] = `Bearer ${sessionToken}`;
      console.log("[API] Authorization header added");
    }
  } else {
    console.log("[API] apiCall:", { endpoint, platform: "web", method: options.method || "GET" });
  }

  const baseUrl = getApiBaseUrl();
  // Ensure no double slashes between baseUrl and endpoint
  const cleanBaseUrl = baseUrl.endsWith("/") ? baseUrl.slice(0, -1) : baseUrl;
  const cleanEndpoint = endpoint.startsWith("/") ? endpoint : `/${endpoint}`;
  const url = baseUrl ? `${cleanBaseUrl}${cleanEndpoint}` : endpoint;
  console.log("[API] Full URL:", url);

  try {
    console.log("[API] Making request...");
    const response = await fetch(url, {
      ...options,
      headers,
      credentials: "include",
    });

    console.log("[API] Response status:", response.status, response.statusText);
    const responseHeaders = Object.fromEntries(response.headers.entries());
    console.log("[API] Response headers:", responseHeaders);

    // Check if Set-Cookie header is present (cookies are automatically handled in React Native)
    const setCookie = response.headers.get("Set-Cookie");
    if (setCookie) {
      console.log("[API] Set-Cookie header received:", setCookie);
    }

    if (!response.ok) {
      const errorText = await response.text();
      console.error("[API] Error response:", errorText);
      let errorMessage = errorText;
      try {
        const errorJson = JSON.parse(errorText);
        errorMessage = errorJson.error || errorJson.message || errorText;
      } catch {
        // Not JSON, use text as is
      }
      throw new Error(errorMessage || `API call failed: ${response.statusText}`);
    }

    const contentType = response.headers.get("content-type");
    if (contentType && contentType.includes("application/json")) {
      const data = await response.json();
      console.log("[API] JSON response received");
      return data as T;
    }

    const text = await response.text();
    console.log("[API] Text response received");
    return (text ? JSON.parse(text) : {}) as T;
  } catch (error) {
    console.error("[API] Request failed:", error);
    if (error instanceof Error) {
      throw error;
    }
    throw new Error("Unknown error occurred");
  }
}

// OAuth callback handler - exchange code for session token
// Calls /api/oauth/mobile endpoint which returns JSON with app_session_id and user
export async function exchangeOAuthCode(
  code: string,
  state: string,
): Promise<{ sessionToken: string; user: any }> {
  console.log("[API] exchangeOAuthCode called");
  // Use GET with query params
  const params = new URLSearchParams({ code, state });
  const endpoint = `/api/oauth/mobile?${params.toString()}`;
  console.log("[API] Calling OAuth mobile endpoint:", endpoint);
  const result = await apiCall<{ app_session_id: string; user: any }>(endpoint);

  // Convert app_session_id to sessionToken for compatibility
  const sessionToken = result.app_session_id;
  console.log("[API] OAuth exchange result:", {
    hasSessionToken: !!sessionToken,
    hasUser: !!result.user,
    sessionToken: sessionToken ? `${sessionToken.substring(0, 50)}...` : null,
  });

  return {
    sessionToken,
    user: result.user,
  };
}

// Logout
export async function logout(): Promise<void> {
  await apiCall<void>("/api/auth/logout", {
    method: "POST",
  });
}

// Get current authenticated user (web uses cookie-based auth)
export async function getMe(): Promise<{
  id: number;
  openId: string;
  name: string | null;
  email: string | null;
  loginMethod: string | null;
  lastSignedIn: string;
} | null> {
  try {
    const result = await apiCall<{ user: any }>("/api/auth/me");
    return result.user || null;
  } catch (error) {
    console.error("[API] getMe failed:", error);
    return null;
  }
}

// Establish session cookie on the backend (3000-xxx domain)
// Called after receiving token via postMessage to get a proper Set-Cookie from the backend
export async function establishSession(token: string): Promise<boolean> {
  try {
    console.log("[API] establishSession: setting cookie on backend...");
    const baseUrl = getApiBaseUrl();
    const url = `${baseUrl}/api/auth/session`;

    const response = await fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      },
      credentials: "include", // Important: allows Set-Cookie to be stored
    });

    if (!response.ok) {
      console.error("[API] establishSession failed:", response.status);
      return false;
    }

    console.log("[API] establishSession: cookie set successfully");
    return true;
  } catch (error) {
    console.error("[API] establishSession error:", error);
    return false;
  }
}

================================================================================
FILE: lib/_core/auth.ts
================================================================================

import * as SecureStore from "expo-secure-store";
import { Platform } from "react-native";
import { SESSION_TOKEN_KEY, USER_INFO_KEY } from "@/constants/oauth";

export type User = {
  id: number;
  openId: string;
  name: string | null;
  email: string | null;
  loginMethod: string | null;
  lastSignedIn: Date;
};

export async function getSessionToken(): Promise<string | null> {
  try {
    // Web platform uses cookie-based auth, no manual token management needed
    if (Platform.OS === "web") {
      console.log("[Auth] Web platform uses cookie-based auth, skipping token retrieval");
      return null;
    }

    // Use SecureStore for native
    console.log("[Auth] Getting session token...");
    const token = await SecureStore.getItemAsync(SESSION_TOKEN_KEY);
    console.log(
      "[Auth] Session token retrieved from SecureStore:",
      token ? `present (${token.substring(0, 20)}...)` : "missing",
    );
    return token;
  } catch (error) {
    console.error("[Auth] Failed to get session token:", error);
    return null;
  }
}

export async function setSessionToken(token: string): Promise<void> {
  try {
    // Web platform uses cookie-based auth, no manual token management needed
    if (Platform.OS === "web") {
      console.log("[Auth] Web platform uses cookie-based auth, skipping token storage");
      return;
    }

    // Use SecureStore for native
    console.log("[Auth] Setting session token...", token.substring(0, 20) + "...");
    await SecureStore.setItemAsync(SESSION_TOKEN_KEY, token);
    console.log("[Auth] Session token stored in SecureStore successfully");
  } catch (error) {
    console.error("[Auth] Failed to set session token:", error);
    throw error;
  }
}

export async function removeSessionToken(): Promise<void> {
  try {
    // Web platform uses cookie-based auth, logout is handled by server clearing cookie
    if (Platform.OS === "web") {
      console.log("[Auth] Web platform uses cookie-based auth, skipping token removal");
      return;
    }

    // Use SecureStore for native
    console.log("[Auth] Removing session token...");
    await SecureStore.deleteItemAsync(SESSION_TOKEN_KEY);
    console.log("[Auth] Session token removed from SecureStore successfully");
  } catch (error) {
    console.error("[Auth] Failed to remove session token:", error);
  }
}

export async function getUserInfo(): Promise<User | null> {
  try {
    console.log("[Auth] Getting user info...");

    let info: string | null = null;
    if (Platform.OS === "web") {
      // Use localStorage for web
      info = window.localStorage.getItem(USER_INFO_KEY);
    } else {
      // Use SecureStore for native
      info = await SecureStore.getItemAsync(USER_INFO_KEY);
    }

    if (!info) {
      console.log("[Auth] No user info found");
      return null;
    }
    const user = JSON.parse(info);
    console.log("[Auth] User info retrieved:", user);
    return user;
  } catch (error) {
    console.error("[Auth] Failed to get user info:", error);
    return null;
  }
}

export async function setUserInfo(user: User): Promise<void> {
  try {
    console.log("[Auth] Setting user info...", user);

    if (Platform.OS === "web") {
      // Use localStorage for web
      window.localStorage.setItem(USER_INFO_KEY, JSON.stringify(user));
      console.log("[Auth] User info stored in localStorage successfully");
      return;
    }

    // Use SecureStore for native
    await SecureStore.setItemAsync(USER_INFO_KEY, JSON.stringify(user));
    console.log("[Auth] User info stored in SecureStore successfully");
  } catch (error) {
    console.error("[Auth] Failed to set user info:", error);
  }
}

export async function clearUserInfo(): Promise<void> {
  try {
    if (Platform.OS === "web") {
      // Use localStorage for web
      window.localStorage.removeItem(USER_INFO_KEY);
      return;
    }

    // Use SecureStore for native
    await SecureStore.deleteItemAsync(USER_INFO_KEY);
  } catch (error) {
    console.error("[Auth] Failed to clear user info:", error);
  }
}

================================================================================
FILE: lib/_core/manus-runtime.ts
================================================================================

/**
 * Manus Runtime - Communication layer between Expo web app and parent container (next-agent-webapp)
 *
 * Simplified flow:
 * 1. initManusRuntime() called
 * 2. Send 'appDevServerReady' to parent to signal app is ready
 *
 * User will manually login via the app's login page - no automatic cookie injection.
 */

import { Platform } from "react-native";
import type { Metrics } from "react-native-safe-area-context";

// Debug logging with timestamps
const DEBUG = true;
const log = (msg: string) => {
  if (!DEBUG) return;
  const ts = new Date().toISOString();
  console.log(`[ManusRuntime ${ts}] ${msg}`);
};

type MessageType = "appDevServerReady";
type SafeAreaInsets = { top: number; right: number; bottom: number; left: number };
type SafeAreaCallback = (metrics: Metrics) => void;

interface SpacePreviewerMessage {
  type: "SpacePreviewerChannel";
  payload: {
    type: string;
    from: "container" | "content";
    to: "container" | "content";
    payload: Record<string, unknown>;
  };
}

function isInIframe(): boolean {
  if (Platform.OS !== "web") return false;
  try {
    return window.self !== window.top;
  } catch {
    return true;
  }
}

function isWeb(): boolean {
  return Platform.OS === "web";
}

function sendToParent(type: MessageType, payload: Record<string, unknown> = {}): void {
  // NOTE: Validate parent origin if we need to transfer sensitive data
  if (!isWeb() || !isInIframe()) return;

  const message: SpacePreviewerMessage = {
    type: "SpacePreviewerChannel",
    payload: { type, from: "content", to: "container", payload },
  };
  window.parent.postMessage(message, "*");
  log(`Sent to parent: ${type}`);
}

let initialized = false;
let safeAreaCallback: SafeAreaCallback | null = null;

function isValidInsets(payload: Record<string, unknown>): payload is SafeAreaInsets {
  return (
    typeof payload.top === "number" &&
    typeof payload.bottom === "number" &&
    typeof payload.left === "number" &&
    typeof payload.right === "number"
  );
}

function handleMessage(event: MessageEvent<unknown>): void {
  // NOTE: Validate event.origin if we need to transfer sensitive data
  const data = event.data as SpacePreviewerMessage | undefined;
  if (!data || data.type !== "SpacePreviewerChannel") return;

  const { payload } = data;
  if (!payload || payload.to !== "content") return;

  if (payload.type === "setSafeAreaInsets" && isValidInsets(payload.payload) && safeAreaCallback) {
    const insets = payload.payload;
    const frame = { x: 0, y: 0, width: window.innerWidth, height: window.innerHeight };
    safeAreaCallback({ insets, frame });
    log(
      `Received safe area insets from parent: top=${insets.top}, bottom=${insets.bottom}, left=${insets.left}, right=${insets.right}`,
    );
  }
}

/**
 * Subscribe to safe area updates from the parent container.
 */
export function subscribeSafeAreaInsets(callback: SafeAreaCallback): () => void {
  safeAreaCallback = callback;
  return () => {
    if (safeAreaCallback === callback) {
      safeAreaCallback = null;
    }
  };
}

/**
 * Initialize Manus Runtime - just notifies parent that app is ready
 */
export function initManusRuntime(): void {
  if (!isWeb() || !isInIframe()) return;
  if (initialized) return;
  initialized = true;

  log("initManusRuntime called");
  window.addEventListener("message", handleMessage);
  sendToParent("appDevServerReady", {});
}

/**
 * Check if running inside preview iframe
 */
export function isRunningInPreviewIframe(): boolean {
  return isWeb() && isInIframe();
}

================================================================================
FILE: lib/_core/nativewind-pressable.ts
================================================================================

// NativeWind + Pressable: className can swallow onPress. Disable className mapping globally.
import { Pressable } from "react-native";
import { remapProps } from "nativewind";

remapProps(Pressable, { className: false });

================================================================================
FILE: lib/_core/theme.ts
================================================================================

import { Platform } from "react-native";

import themeConfig from "@/theme.config";

export type ColorScheme = "light" | "dark";

export const ThemeColors = themeConfig.themeColors;

type ThemeColorTokens = typeof ThemeColors;
type ThemeColorName = keyof ThemeColorTokens;
type SchemePalette = Record<ColorScheme, Record<ThemeColorName, string>>;
type SchemePaletteItem = SchemePalette[ColorScheme];

function buildSchemePalette(colors: ThemeColorTokens): SchemePalette {
  const palette: SchemePalette = {
    light: {} as SchemePalette["light"],
    dark: {} as SchemePalette["dark"],
  };

  (Object.keys(colors) as ThemeColorName[]).forEach((name) => {
    const swatch = colors[name];
    palette.light[name] = swatch.light;
    palette.dark[name] = swatch.dark;
  });

  return palette;
}

export const SchemeColors = buildSchemePalette(ThemeColors);

type RuntimePalette = SchemePaletteItem & {
  text: string;
  background: string;
  tint: string;
  icon: string;
  tabIconDefault: string;
  tabIconSelected: string;
  border: string;
};

function buildRuntimePalette(scheme: ColorScheme): RuntimePalette {
  const base = SchemeColors[scheme];
  return {
    ...base,
    text: base.foreground,
    background: base.background,
    tint: base.primary,
    icon: base.muted,
    tabIconDefault: base.muted,
    tabIconSelected: base.primary,
    border: base.border,
  };
}

export const Colors = {
  light: buildRuntimePalette("light"),
  dark: buildRuntimePalette("dark"),
} satisfies Record<ColorScheme, RuntimePalette>;

export type ThemeColorPalette = (typeof Colors)[ColorScheme];

export const Fonts = Platform.select({
  ios: {
    /** iOS `UIFontDescriptorSystemDesignDefault` */
    sans: "system-ui",
    /** iOS `UIFontDescriptorSystemDesignSerif` */
    serif: "ui-serif",
    /** iOS `UIFontDescriptorSystemDesignRounded` */
    rounded: "ui-rounded",
    /** iOS `UIFontDescriptorSystemDesignMonospaced` */
    mono: "ui-monospace",
  },
  default: {
    sans: "normal",
    serif: "serif",
    rounded: "normal",
    mono: "monospace",
  },
  web: {
    sans: "system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif",
    serif: "Georgia, 'Times New Roman', serif",
    rounded: "'SF Pro Rounded', 'Hiragino Maru Gothic ProN', Meiryo, 'MS PGothic', sans-serif",
    mono: "SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace",
  },
});

================================================================================
FILE: lib/adapter-database.ts
================================================================================

/**
 * Base de Datos de Adaptadores USB-Ethernet Conocidos
 * Contiene especificaciones t√©cnicas, offsets de EEPROM y nivel de compatibilidad
 */

export type EepromType = '93C46' | '93C56' | '93C66' | 'eFuse' | 'Unknown';
export type CompatibilityLevel = 'high' | 'medium' | 'low' | 'incompatible';
export type ChipsetFamily = 'ASIX' | 'Realtek' | 'Microchip' | 'Other';

export interface EepromOffsets {
  vidLow: number;
  vidHigh: number;
  pidLow: number;
  pidHigh: number;
  checksum?: number;
  macAddress?: number;
  serialNumber?: number;
}

export interface AdapterSpec {
  // Identificaci√≥n
  vendorId: number;
  productId: number;
  vendorName: string;
  productName: string;
  revision?: string;
  
  // Chipset
  chipset: string;
  chipsetFamily: ChipsetFamily;
  chipsetVersion?: string;
  
  // EEPROM
  eepromType: EepromType;
  eepromSize: number; // en bytes
  eepromOffsets: EepromOffsets;
  
  // Compatibilidad
  spoofingCompatibility: CompatibilityLevel;
  mib2Whitelisted: boolean;
  
  // Notas t√©cnicas
  notes?: string;
  quirks?: string[];
  recoveryMethods?: string[];
}

/**
 * Base de datos de adaptadores conocidos
 */
export const ADAPTER_DATABASE: AdapterSpec[] = [
  // ========== ASIX Electronics ==========
  {
    vendorId: 0x0B95,
    productId: 0x7720,
    vendorName: 'ASIX Electronics',
    productName: 'AX88772 USB 2.0 to Fast Ethernet Adapter',
    chipset: 'AX88772',
    chipsetFamily: 'ASIX',
    eepromType: '93C56',
    eepromSize: 256,
    eepromOffsets: {
      vidLow: 0x88,
      vidHigh: 0x89,
      pidLow: 0x8A,
      pidHigh: 0x8B,
      checksum: 0xFE,
      macAddress: 0x04,
    },
    spoofingCompatibility: 'high',
    mib2Whitelisted: false,
    notes: 'Generic ASIX AX88772 adapter. Most common chipset for USB-Ethernet adapters.',
    quirks: [
      'EEPROM offsets may vary by manufacturer',
      'Some clones use different memory maps',
    ],
    recoveryMethods: [
      'SDA/SCL short circuit during power-on',
      'Vendor command 0x20 for EEPROM reset',
    ],
  },
  {
    vendorId: 0x0B95,
    productId: 0x772A,
    vendorName: 'ASIX Electronics',
    productName: 'AX88772A USB 2.0 to Fast Ethernet Adapter',
    chipset: 'AX88772A',
    chipsetFamily: 'ASIX',
    chipsetVersion: 'A',
    eepromType: '93C56',
    eepromSize: 256,
    eepromOffsets: {
      vidLow: 0x88,
      vidHigh: 0x89,
      pidLow: 0x8A,
      pidHigh: 0x8B,
      checksum: 0xFE,
      macAddress: 0x04,
    },
    spoofingCompatibility: 'high',
    mib2Whitelisted: false,
    notes: 'Improved version with better power management. Fully compatible with spoofing.',
    recoveryMethods: [
      'SDA/SCL short circuit during power-on',
      'Vendor command 0x20 for EEPROM reset',
    ],
  },
  {
    vendorId: 0x0B95,
    productId: 0x772B,
    vendorName: 'ASIX Electronics',
    productName: 'AX88772B USB 2.0 to Fast Ethernet Adapter',
    chipset: 'AX88772B',
    chipsetFamily: 'ASIX',
    chipsetVersion: 'B',
    eepromType: '93C66',
    eepromSize: 512,
    eepromOffsets: {
      vidLow: 0x88,
      vidHigh: 0x89,
      pidLow: 0x8A,
      pidHigh: 0x8B,
      checksum: 0x1FE,
      macAddress: 0x04,
    },
    spoofingCompatibility: 'high',
    mib2Whitelisted: false,
    notes: 'Larger EEPROM (512 bytes). Fully compatible with spoofing.',
    quirks: [
      'Checksum offset at 0x1FE instead of 0xFE',
    ],
    recoveryMethods: [
      'SDA/SCL short circuit during power-on',
      'Vendor command 0x20 for EEPROM reset',
    ],
  },
  {
    vendorId: 0x0B95,
    productId: 0x772C,
    vendorName: 'ASIX Electronics',
    productName: 'AX88772C USB 2.0 to Fast Ethernet Adapter',
    chipset: 'AX88772C',
    chipsetFamily: 'ASIX',
    chipsetVersion: 'C',
    eepromType: 'eFuse',
    eepromSize: 0,
    eepromOffsets: {
      vidLow: 0,
      vidHigh: 0,
      pidLow: 0,
      pidHigh: 0,
    },
    spoofingCompatibility: 'incompatible',
    mib2Whitelisted: false,
    notes: 'Uses eFuse technology instead of external EEPROM. CANNOT be reprogrammed.',
    quirks: [
      'VID/PID burned into internal eFuse',
      'No external EEPROM present',
      'Impossible to spoof',
    ],
    recoveryMethods: [],
  },

  // ========== D-Link ==========
  {
    vendorId: 0x2001,
    productId: 0x3C05,
    vendorName: 'D-Link Corp.',
    productName: 'DUB-E100 Fast Ethernet Adapter (Rev B1)',
    revision: 'B1',
    chipset: 'AX88772',
    chipsetFamily: 'ASIX',
    eepromType: '93C56',
    eepromSize: 256,
    eepromOffsets: {
      vidLow: 0x88,
      vidHigh: 0x89,
      pidLow: 0x8A,
      pidHigh: 0x8B,
      checksum: 0xFE,
      macAddress: 0x04,
    },
    spoofingCompatibility: 'medium',
    mib2Whitelisted: true,
    notes: 'Target VID/PID for spoofing. This adapter is whitelisted by MIB2.',
    quirks: [
      'Original D-Link adapters are expensive',
      'Can be emulated by spoofing ASIX adapters',
    ],
  },
  {
    vendorId: 0x2001,
    productId: 0x1A02,
    vendorName: 'D-Link Corp.',
    productName: 'DUB-E100 Fast Ethernet Adapter (Rev C1)',
    revision: 'C1',
    chipset: 'AX88772',
    chipsetFamily: 'ASIX',
    eepromType: '93C56',
    eepromSize: 256,
    eepromOffsets: {
      vidLow: 0x88,
      vidHigh: 0x89,
      pidLow: 0x8A,
      pidHigh: 0x8B,
      checksum: 0xFE,
      macAddress: 0x04,
    },
    spoofingCompatibility: 'medium',
    mib2Whitelisted: true,
    notes: 'Newer revision. Also whitelisted by MIB2 (firmware T490+).',
  },

  // ========== Otros Fabricantes ==========
  {
    vendorId: 0x0B95,
    productId: 0x1780,
    vendorName: 'ASIX Electronics',
    productName: 'AX88178 USB 2.0 to Gigabit Ethernet Adapter',
    chipset: 'AX88178',
    chipsetFamily: 'ASIX',
    eepromType: '93C66',
    eepromSize: 512,
    eepromOffsets: {
      vidLow: 0x88,
      vidHigh: 0x89,
      pidLow: 0x8A,
      pidHigh: 0x8B,
      checksum: 0x1FE,
      macAddress: 0x04,
    },
    spoofingCompatibility: 'low',
    mib2Whitelisted: false,
    notes: 'Gigabit adapter. Not recommended for MIB2 (requires Fast Ethernet 100Mbps).',
    quirks: [
      'Gigabit chipset may not be compatible with MIB2',
      'Larger EEPROM size',
    ],
  },
  {
    vendorId: 0x0B95,
    productId: 0x1790,
    vendorName: 'ASIX Electronics',
    productName: 'AX88179 USB 3.0 to Gigabit Ethernet Adapter',
    chipset: 'AX88179',
    chipsetFamily: 'ASIX',
    eepromType: '93C66',
    eepromSize: 512,
    eepromOffsets: {
      vidLow: 0x88,
      vidHigh: 0x89,
      pidLow: 0x8A,
      pidHigh: 0x8B,
      checksum: 0x1FE,
      macAddress: 0x04,
    },
    spoofingCompatibility: 'low',
    mib2Whitelisted: false,
    notes: 'USB 3.0 Gigabit adapter. Not recommended for MIB2.',
    quirks: [
      'USB 3.0 may cause compatibility issues',
      'Gigabit chipset not needed for MIB2',
    ],
  },
];

/**
 * Clase para consultar la base de datos de adaptadores
 */
export class AdapterDatabase {
  /**
   * Buscar adaptador por VID/PID
   */
  static findByVidPid(vendorId: number, productId: number): AdapterSpec | undefined {
    return ADAPTER_DATABASE.find(
      (adapter) => adapter.vendorId === vendorId && adapter.productId === productId
    );
  }

  /**
   * Buscar todos los adaptadores de un fabricante
   */
  static findByVendor(vendorId: number): AdapterSpec[] {
    return ADAPTER_DATABASE.filter((adapter) => adapter.vendorId === vendorId);
  }

  /**
   * Buscar adaptadores por familia de chipset
   */
  static findByChipsetFamily(family: ChipsetFamily): AdapterSpec[] {
    return ADAPTER_DATABASE.filter((adapter) => adapter.chipsetFamily === family);
  }

  /**
   * Buscar adaptadores compatibles para spoofing
   */
  static findSpoofingCompatible(): AdapterSpec[] {
    return ADAPTER_DATABASE.filter(
      (adapter) => adapter.spoofingCompatibility === 'high' || adapter.spoofingCompatibility === 'medium'
    );
  }

  /**
   * Buscar adaptadores en lista blanca de MIB2
   */
  static findMib2Whitelisted(): AdapterSpec[] {
    return ADAPTER_DATABASE.filter((adapter) => adapter.mib2Whitelisted);
  }

  /**
   * Obtener informaci√≥n detallada de un adaptador
   */
  static getAdapterInfo(vendorId: number, productId: number): string {
    const adapter = this.findByVidPid(vendorId, productId);
    if (!adapter) {
      return 'Unknown adapter';
    }

    let info = `${adapter.vendorName} ${adapter.productName}\n`;
    if (adapter.revision) {
      info += `Revision: ${adapter.revision}\n`;
    }
    info += `Chipset: ${adapter.chipset}\n`;
    info += `EEPROM: ${adapter.eepromType} (${adapter.eepromSize} bytes)\n`;
    info += `Spoofing Compatibility: ${adapter.spoofingCompatibility}\n`;
    info += `MIB2 Whitelisted: ${adapter.mib2Whitelisted ? 'Yes' : 'No'}\n`;
    
    if (adapter.notes) {
      info += `\nNotes: ${adapter.notes}\n`;
    }

    if (adapter.quirks && adapter.quirks.length > 0) {
      info += `\nQuirks:\n`;
      adapter.quirks.forEach((quirk) => {
        info += `- ${quirk}\n`;
      });
    }

    if (adapter.recoveryMethods && adapter.recoveryMethods.length > 0) {
      info += `\nRecovery Methods:\n`;
      adapter.recoveryMethods.forEach((method) => {
        info += `- ${method}\n`;
      });
    }

    return info;
  }

  /**
   * Verificar si un adaptador es compatible para spoofing
   */
  static isSpoofingCompatible(vendorId: number, productId: number): boolean {
    const adapter = this.findByVidPid(vendorId, productId);
    if (!adapter) {
      return false;
    }
    return adapter.spoofingCompatibility === 'high' || adapter.spoofingCompatibility === 'medium';
  }

  /**
   * Obtener offsets de EEPROM sugeridos
   */
  static getSuggestedOffsets(vendorId: number, productId: number): EepromOffsets | null {
    const adapter = this.findByVidPid(vendorId, productId);
    if (!adapter) {
      return null;
    }
    return adapter.eepromOffsets;
  }

  /**
   * Obtener adaptador objetivo para spoofing (D-Link DUB-E100 B1)
   */
  static getTargetAdapter(): AdapterSpec {
    const target = this.findByVidPid(0x2001, 0x3C05);
    if (!target) {
      throw new Error('Target adapter not found in database');
    }
    return target;
  }

  /**
   * Generar reporte de compatibilidad
   */
  static generateCompatibilityReport(vendorId: number, productId: number): {
    compatible: boolean;
    level: CompatibilityLevel;
    reason: string;
    warnings: string[];
    recommendations: string[];
  } {
    const adapter = this.findByVidPid(vendorId, productId);
    
    if (!adapter) {
      return {
        compatible: false,
        level: 'incompatible',
        reason: 'Adapter not found in database. Unknown compatibility.',
        warnings: ['This adapter has not been tested'],
        recommendations: ['Use a known compatible adapter like ASIX AX88772A/B'],
      };
    }

    const warnings: string[] = [];
    const recommendations: string[] = [];

    // Verificar eFuse
    if (adapter.eepromType === 'eFuse') {
      return {
        compatible: false,
        level: 'incompatible',
        reason: 'This adapter uses eFuse technology which cannot be reprogrammed.',
        warnings: ['VID/PID is burned into internal eFuse', 'Spoofing is impossible'],
        recommendations: ['Purchase an AX88772A or AX88772B adapter instead'],
      };
    }

    // Agregar quirks como warnings
    if (adapter.quirks) {
      warnings.push(...adapter.quirks);
    }

    // Generar recomendaciones
    if (adapter.spoofingCompatibility === 'high') {
      recommendations.push('This adapter is highly compatible with spoofing');
      recommendations.push('Follow the standard spoofing procedure');
    } else if (adapter.spoofingCompatibility === 'medium') {
      recommendations.push('This adapter may work but has some quirks');
      recommendations.push('Proceed with caution and make sure to backup');
    } else if (adapter.spoofingCompatibility === 'low') {
      recommendations.push('This adapter is not recommended for spoofing');
      recommendations.push('Consider using a different model');
    }

    return {
      compatible: adapter.spoofingCompatibility !== 'incompatible',
      level: adapter.spoofingCompatibility,
      reason: adapter.notes || 'See adapter specifications',
      warnings,
      recommendations,
    };
  }

  /**
   * Obtener estad√≠sticas de la base de datos
   */
  static getStatistics(): {
    totalAdapters: number;
    byCompatibility: Record<CompatibilityLevel, number>;
    byChipsetFamily: Record<ChipsetFamily, number>;
    whitelistedCount: number;
  } {
    const byCompatibility: Record<CompatibilityLevel, number> = {
      high: 0,
      medium: 0,
      low: 0,
      incompatible: 0,
    };

    const byChipsetFamily: Record<ChipsetFamily, number> = {
      ASIX: 0,
      Realtek: 0,
      Microchip: 0,
      Other: 0,
    };

    let whitelistedCount = 0;

    ADAPTER_DATABASE.forEach((adapter) => {
      byCompatibility[adapter.spoofingCompatibility]++;
      byChipsetFamily[adapter.chipsetFamily]++;
      if (adapter.mib2Whitelisted) {
        whitelistedCount++;
      }
    });

    return {
      totalAdapters: ADAPTER_DATABASE.length,
      byCompatibility,
      byChipsetFamily,
      whitelistedCount,
    };
  }
}

================================================================================
FILE: lib/backup-service.ts
================================================================================

import AsyncStorage from '@react-native-async-storage/async-storage';
import * as FileSystem from 'expo-file-system/legacy';
import * as Sharing from 'expo-sharing';
import { usbService } from './usb-service';
import type { UsbDevice } from './usb-service';
import CryptoJS from 'crypto-js';

const BACKUP_STORAGE_KEY = '@mib2_eeprom_backups';
// Use SAF (Storage Access Framework) directory for Android - accessible from file manager
// On Android, this maps to /storage/emulated/0/Android/data/[package]/files/Download/mib2_backups/
const BACKUP_DIR = `${FileSystem.documentDirectory}Download/mib2_backups/`;

export interface EEPROMBackup {
  id: string;
  timestamp: number;
  deviceName: string;
  vendorId: number;
  productId: number;
  chipset: string;
  serialNumber: string;
  data: string; // Hex string of complete EEPROM dump (256 bytes)
  size: number;
  checksum: string; // MD5 hash of data for integrity verification
  notes?: string;
  filepath?: string; // Ruta del archivo de backup en FileSystem
}

/**
 * Backup Service - Gesti√≥n de backups de EEPROM
 */
class BackupService {
  /**
   * Crear backup de EEPROM del dispositivo actual
   */
  async createBackup(device: UsbDevice, notes?: string): Promise<EEPROMBackup> {
    try {
      console.log('[BackupService] Creating EEPROM backup...');
      
      // Volcar EEPROM completa (256 bytes)
      const dump = await usbService.dumpEEPROM();
      
      // Calcular checksum MD5 de los datos
      const checksum = CryptoJS.MD5(dump.data).toString();
      
      // Crear objeto de backup
      const backup: EEPROMBackup = {
        id: `backup_${Date.now()}_${device.vendorId}_${device.productId}`,
        timestamp: Date.now(),
        deviceName: device.deviceName,
        vendorId: device.vendorId,
        productId: device.productId,
        chipset: device.chipset || 'Unknown',
        serialNumber: device.serialNumber || 'N/A',
        data: dump.data,
        size: dump.size,
        checksum,
        notes: notes || `Backup autom√°tico antes de spoofing`,
      };
      
      // Guardar backup
      await this.saveBackup(backup);
      
      console.log(`[BackupService] Backup created successfully: ${backup.id}`);
      return backup;
    } catch (error) {
      console.error('[BackupService] Error creating backup:', error);
      throw new Error(`No se pudo crear el backup: ${error}`);
    }
  }

  /**
   * Guardar backup en FileSystem accesible y AsyncStorage
   */
  private async saveBackup(backup: EEPROMBackup): Promise<void> {
    try {
      // Crear directorio de backups si no existe
      const dirInfo = await FileSystem.getInfoAsync(BACKUP_DIR);
      if (!dirInfo.exists) {
        await FileSystem.makeDirectoryAsync(BACKUP_DIR, { intermediates: true });
        console.log(`[BackupService] Created backup directory: ${BACKUP_DIR}`);
      }
      
      // Guardar archivo binario en FileSystem
      const filename = `backup_${backup.vendorId.toString(16)}_${backup.productId.toString(16)}_${backup.timestamp}.bin`;
      const filepath = `${BACKUP_DIR}${filename}`;
      
      // Convertir hex string a base64 para FileSystem
      const bytes = backup.data.match(/.{1,2}/g)!.map(byte => parseInt(byte, 16));
      const base64 = btoa(String.fromCharCode(...bytes));
      await FileSystem.writeAsStringAsync(filepath, base64, { encoding: FileSystem.EncodingType.Base64 });
      
      console.log(`[BackupService] Backup file saved: ${filepath}`);
      
      // Guardar metadata en AsyncStorage
      const backups = await this.loadBackups();
      backups.push({ ...backup, filepath }); // Agregar ruta del archivo
      await AsyncStorage.setItem(BACKUP_STORAGE_KEY, JSON.stringify(backups));
      
      console.log(`[BackupService] Backup metadata saved: ${backup.id}`);
    } catch (error) {
      console.error('[BackupService] Error saving backup:', error);
      throw error;
    }
  }

  /**
   * Cargar todos los backups guardados
   */
  async loadBackups(): Promise<EEPROMBackup[]> {
    try {
      const data = await AsyncStorage.getItem(BACKUP_STORAGE_KEY);
      if (!data) {
        return [];
      }
      
      const backups: EEPROMBackup[] = JSON.parse(data);
      
      // Ordenar por timestamp descendente (m√°s reciente primero)
      backups.sort((a, b) => b.timestamp - a.timestamp);
      
      console.log(`[BackupService] Loaded ${backups.length} backups`);
      return backups;
    } catch (error) {
      console.error('[BackupService] Error loading backups:', error);
      return [];
    }
  }

  /**
   * Obtener backup por ID
   */
  async getBackup(id: string): Promise<EEPROMBackup | null> {
    try {
      const backups = await this.loadBackups();
      return backups.find(b => b.id === id) || null;
    } catch (error) {
      console.error('[BackupService] Error getting backup:', error);
      return null;
    }
  }

  /**
   * Eliminar backup por ID
   */
  async deleteBackup(id: string): Promise<boolean> {
    try {
      const backups = await this.loadBackups();
      const filtered = backups.filter(b => b.id !== id);
      
      if (filtered.length === backups.length) {
        console.warn(`[BackupService] Backup not found: ${id}`);
        return false;
      }
      
      await AsyncStorage.setItem(BACKUP_STORAGE_KEY, JSON.stringify(filtered));
      console.log(`[BackupService] Backup deleted: ${id}`);
      return true;
    } catch (error) {
      console.error('[BackupService] Error deleting backup:', error);
      return false;
    }
  }

  /**
   * Restaurar EEPROM desde backup
   */
  async restoreBackup(backupId: string): Promise<{ success: boolean; bytesWritten: number }> {
    try {
      console.log(`[BackupService] Restoring backup: ${backupId}`);
      
      // Cargar backup
      const backup = await this.getBackup(backupId);
      if (!backup) {
        throw new Error('Backup no encontrado');
      }
      
      // Validar tama√±o de datos
      if (backup.size !== 256) {
        throw new Error(`Tama√±o de backup inv√°lido: ${backup.size} bytes (esperado: 256)`);
      }
      
      // Validar formato hexadecimal
      if (!/^[0-9A-Fa-f]+$/.test(backup.data)) {
        throw new Error('Formato de datos inv√°lido (no es hexadecimal)');
      }
      
      // Validar integridad con checksum MD5
      const calculatedChecksum = CryptoJS.MD5(backup.data).toString();
      if (backup.checksum && calculatedChecksum !== backup.checksum) {
        throw new Error(`Checksum inv√°lido: datos corruptos detectados\nEsperado: ${backup.checksum}\nCalculado: ${calculatedChecksum}`);
      }
      console.log(`[BackupService] Checksum validated: ${calculatedChecksum}`);
      
      // Restaurar byte por byte en offsets cr√≠ticos (0x88-0x8B para VID/PID)
      let bytesWritten = 0;
      
      // Escribir VID (offsets 0x88-0x89)
      const vidLow = backup.data.substring(0x88 * 2, 0x88 * 2 + 2);
      const vidHigh = backup.data.substring(0x89 * 2, 0x89 * 2 + 2);
      await usbService.writeEEPROM(0x88, vidLow);
      await new Promise(resolve => setTimeout(resolve, 100));
      await usbService.writeEEPROM(0x89, vidHigh);
      await new Promise(resolve => setTimeout(resolve, 100));
      bytesWritten += 2;
      
      // Escribir PID (offsets 0x8A-0x8B)
      const pidLow = backup.data.substring(0x8A * 2, 0x8A * 2 + 2);
      const pidHigh = backup.data.substring(0x8B * 2, 0x8B * 2 + 2);
      await usbService.writeEEPROM(0x8A, pidLow);
      await new Promise(resolve => setTimeout(resolve, 100));
      await usbService.writeEEPROM(0x8B, pidHigh);
      await new Promise(resolve => setTimeout(resolve, 100));
      bytesWritten += 2;
      
      console.log(`[BackupService] Backup restored successfully: ${bytesWritten} bytes written`);
      console.log(`[BackupService] Checksum verified: ${backup.checksum}`);
      return { success: true, bytesWritten };
    } catch (error) {
      console.error('[BackupService] Error restoring backup:', error);
      throw new Error(`No se pudo restaurar el backup: ${error}`);
    }
  }

  /**
   * Exportar backup como JSON string
   */
  async exportBackup(backupId: string): Promise<string> {
    try {
      const backup = await this.getBackup(backupId);
      if (!backup) {
        throw new Error('Backup no encontrado');
      }
      
      return JSON.stringify(backup, null, 2);
    } catch (error) {
      console.error('[BackupService] Error exporting backup:', error);
      throw error;
    }
  }

  /**
   * Importar backup desde JSON string
   */
  async importBackup(jsonString: string): Promise<EEPROMBackup> {
    try {
      const backup: EEPROMBackup = JSON.parse(jsonString);
      
      // Validar estructura
      if (!backup.id || !backup.data || !backup.size) {
        throw new Error('Formato de backup inv√°lido');
      }
      
      // Guardar backup importado
      await this.saveBackup(backup);
      
      console.log(`[BackupService] Backup imported: ${backup.id}`);
      return backup;
    } catch (error) {
      console.error('[BackupService] Error importing backup:', error);
      throw new Error(`No se pudo importar el backup: ${error}`);
    }
  }

  /**
   * Limpiar todos los backups
   */
  async clearAllBackups(): Promise<boolean> {
    try {
      await AsyncStorage.removeItem(BACKUP_STORAGE_KEY);
      console.log('[BackupService] All backups cleared');
      return true;
    } catch (error) {
      console.error('[BackupService] Error clearing backups:', error);
      return false;
    }
  }

  /**
   * Obtener estad√≠sticas de backups
   */
  async getStats(): Promise<{ total: number; totalSize: number; oldestDate: number | null; newestDate: number | null }> {
    try {
      const backups = await this.loadBackups();
      
      if (backups.length === 0) {
        return { total: 0, totalSize: 0, oldestDate: null, newestDate: null };
      }
      
      const totalSize = backups.reduce((sum, b) => sum + b.size, 0);
      const timestamps = backups.map(b => b.timestamp);
      
      return {
        total: backups.length,
        totalSize,
        oldestDate: Math.min(...timestamps),
        newestDate: Math.max(...timestamps),
      };
    } catch (error) {
      console.error('[BackupService] Error getting stats:', error);
      return { total: 0, totalSize: 0, oldestDate: null, newestDate: null };
    }
  }
}

export const backupService = new BackupService();

================================================================================
FILE: lib/chipset-compatibility.ts
================================================================================

import type { ChipsetCompatibility } from '@/components/chipset-status-badge';

/**
 * Determinar compatibilidad de chipset para spoofing MIB2
 */
export function getChipsetCompatibility(chipset: string): ChipsetCompatibility {
  const chipsetLower = chipset.toLowerCase();
  
  // Chipsets ASIX confirmados (probados y funcionando)
  const confirmedASIX = ['ax88772', 'ax88772a', 'ax88772b'];
  if (confirmedASIX.some(model => chipsetLower.includes(model))) {
    return 'confirmed';
  }
  
  // Otros chipsets ASIX (experimentales pero probablemente compatibles)
  // Comparten arquitectura de EEPROM similar
  const experimentalASIX = ['ax88172', 'ax88178', 'ax88179', 'ax88772c'];
  if (experimentalASIX.some(model => chipsetLower.includes(model))) {
    return 'experimental';
  }
  
  // Cualquier otro ASIX gen√©rico
  if (chipsetLower.includes('asix')) {
    return 'experimental';
  }
  
  // Chipsets incompatibles conocidos
  const incompatible = ['realtek', 'microchip', 'broadcom', 'davicom', 'lan'];
  if (incompatible.some(vendor => chipsetLower.includes(vendor))) {
    return 'incompatible';
  }
  
  // Desconocido
  return 'unknown';
}

/**
 * Obtener mensaje descriptivo de compatibilidad
 */
export function getCompatibilityMessage(compatibility: ChipsetCompatibility, chipset: string): string {
  switch (compatibility) {
    case 'confirmed':
      return `${chipset} est√° confirmado como compatible para spoofing MIB2. Probado y funcionando correctamente.`;
    case 'experimental':
      return `${chipset} es experimental. Comparte arquitectura ASIX similar y deber√≠a funcionar, pero no est√° 100% confirmado.`;
    case 'incompatible':
      return `${chipset} NO es compatible con spoofing en Android. Requiere herramientas espec√≠ficas o no soporta modificaci√≥n de VID/PID.`;
    default:
      return `${chipset} es desconocido. No hay informaci√≥n sobre compatibilidad para spoofing MIB2.`;
  }
}

/**
 * Verificar si chipset puede intentar spoofing
 */
export function canAttemptSpoofing(compatibility: ChipsetCompatibility): boolean {
  return compatibility === 'confirmed' || compatibility === 'experimental';
}

================================================================================
FILE: lib/command-queue.ts
================================================================================

/**
 * Sistema de Cola de Comandos Offline
 * Permite encolar comandos cuando no hay conexi√≥n y ejecutarlos autom√°ticamente al reconectar
 */

import AsyncStorage from '@react-native-async-storage/async-storage';

export interface QueuedCommand {
  id: string;
  command: string;
  description: string;
  timestamp: number;
  priority: 'low' | 'normal' | 'high';
  retries: number;
  maxRetries: number;
  status: 'pending' | 'executing' | 'completed' | 'failed';
  error?: string;
}

const QUEUE_STORAGE_KEY = '@mib2_command_queue';
const MAX_QUEUE_SIZE = 100;

export class CommandQueue {
  private static queue: QueuedCommand[] = [];
  private static listeners: ((queue: QueuedCommand[]) => void)[] = [];
  private static isExecuting = false;

  /**
   * Inicializar la cola desde AsyncStorage
   */
  static async initialize(): Promise<void> {
    try {
      const queueJson = await AsyncStorage.getItem(QUEUE_STORAGE_KEY);
      if (queueJson) {
        this.queue = JSON.parse(queueJson);
        console.log(`[CommandQueue] Loaded ${this.queue.length} commands from storage`);
        this.notifyListeners();
      }
    } catch (error) {
      console.error('[CommandQueue] Failed to load queue:', error);
    }
  }

  /**
   * Agregar comando a la cola
   */
  static async enqueue(
    command: string,
    description: string,
    priority: 'low' | 'normal' | 'high' = 'normal'
  ): Promise<{ success: boolean; id?: string; error?: string }> {
    try {
      if (this.queue.length >= MAX_QUEUE_SIZE) {
        return {
          success: false,
          error: `Queue is full (max ${MAX_QUEUE_SIZE} commands)`,
        };
      }

      const queuedCommand: QueuedCommand = {
        id: `cmd_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        command,
        description,
        timestamp: Date.now(),
        priority,
        retries: 0,
        maxRetries: 3,
        status: 'pending',
      };

      // Insertar seg√∫n prioridad
      if (priority === 'high') {
        this.queue.unshift(queuedCommand);
      } else {
        this.queue.push(queuedCommand);
      }

      await this.saveQueue();
      this.notifyListeners();

      console.log(`[CommandQueue] Enqueued command: ${description}`);

      return {
        success: true,
        id: queuedCommand.id,
      };
    } catch (error) {
      console.error('[CommandQueue] Failed to enqueue command:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }

  /**
   * Obtener todos los comandos en cola
   */
  static getQueue(): QueuedCommand[] {
    return [...this.queue];
  }

  /**
   * Obtener comandos pendientes
   */
  static getPendingCommands(): QueuedCommand[] {
    return this.queue.filter((cmd) => cmd.status === 'pending');
  }

  /**
   * Obtener comando por ID
   */
  static getCommand(id: string): QueuedCommand | undefined {
    return this.queue.find((cmd) => cmd.id === id);
  }

  /**
   * Eliminar comando de la cola
   */
  static async removeCommand(id: string): Promise<boolean> {
    try {
      const index = this.queue.findIndex((cmd) => cmd.id === id);
      if (index === -1) {
        return false;
      }

      this.queue.splice(index, 1);
      await this.saveQueue();
      this.notifyListeners();

      console.log(`[CommandQueue] Removed command: ${id}`);
      return true;
    } catch (error) {
      console.error('[CommandQueue] Failed to remove command:', error);
      return false;
    }
  }

  /**
   * Limpiar comandos completados
   */
  static async clearCompleted(): Promise<number> {
    try {
      const beforeCount = this.queue.length;
      this.queue = this.queue.filter((cmd) => cmd.status !== 'completed');
      const removedCount = beforeCount - this.queue.length;

      if (removedCount > 0) {
        await this.saveQueue();
        this.notifyListeners();
        console.log(`[CommandQueue] Cleared ${removedCount} completed commands`);
      }

      return removedCount;
    } catch (error) {
      console.error('[CommandQueue] Failed to clear completed:', error);
      return 0;
    }
  }

  /**
   * Limpiar toda la cola
   */
  static async clearAll(): Promise<void> {
    try {
      this.queue = [];
      await this.saveQueue();
      this.notifyListeners();
      console.log('[CommandQueue] Cleared all commands');
    } catch (error) {
      console.error('[CommandQueue] Failed to clear queue:', error);
    }
  }

  /**
   * Ejecutar cola de comandos
   */
  static async executeQueue(
    executor: (command: string) => Promise<{ success: boolean; output?: string; error?: string }>
  ): Promise<{ executed: number; failed: number }> {
    if (this.isExecuting) {
      console.log('[CommandQueue] Already executing queue');
      return { executed: 0, failed: 0 };
    }

    this.isExecuting = true;
    let executed = 0;
    let failed = 0;

    try {
      const pendingCommands = this.getPendingCommands();
      console.log(`[CommandQueue] Executing ${pendingCommands.length} pending commands`);

      for (const cmd of pendingCommands) {
        try {
          // Actualizar estado
          cmd.status = 'executing';
          await this.saveQueue();
          this.notifyListeners();

          // Ejecutar comando
          const result = await executor(cmd.command);

          if (result.success) {
            cmd.status = 'completed';
            executed++;
            console.log(`[CommandQueue] Executed: ${cmd.description}`);
          } else {
            cmd.retries++;
            if (cmd.retries >= cmd.maxRetries) {
              cmd.status = 'failed';
              cmd.error = result.error || 'Max retries exceeded';
              failed++;
              console.error(`[CommandQueue] Failed: ${cmd.description} - ${cmd.error}`);
            } else {
              cmd.status = 'pending';
              console.warn(`[CommandQueue] Retry ${cmd.retries}/${cmd.maxRetries}: ${cmd.description}`);
            }
          }

          await this.saveQueue();
          this.notifyListeners();

          // Peque√±a pausa entre comandos
          await new Promise((resolve) => setTimeout(resolve, 500));
        } catch (error) {
          cmd.retries++;
          if (cmd.retries >= cmd.maxRetries) {
            cmd.status = 'failed';
            cmd.error = error instanceof Error ? error.message : String(error);
            failed++;
          } else {
            cmd.status = 'pending';
          }

          await this.saveQueue();
          this.notifyListeners();
        }
      }

      console.log(`[CommandQueue] Execution complete: ${executed} executed, ${failed} failed`);
    } finally {
      this.isExecuting = false;
    }

    return { executed, failed };
  }

  /**
   * Verificar si hay comandos pendientes
   */
  static hasPendingCommands(): boolean {
    return this.queue.some((cmd) => cmd.status === 'pending');
  }

  /**
   * Obtener estad√≠sticas de la cola
   */
  static getStats(): {
    total: number;
    pending: number;
    executing: number;
    completed: number;
    failed: number;
  } {
    return {
      total: this.queue.length,
      pending: this.queue.filter((cmd) => cmd.status === 'pending').length,
      executing: this.queue.filter((cmd) => cmd.status === 'executing').length,
      completed: this.queue.filter((cmd) => cmd.status === 'completed').length,
      failed: this.queue.filter((cmd) => cmd.status === 'failed').length,
    };
  }

  /**
   * Suscribirse a cambios en la cola
   */
  static subscribe(listener: (queue: QueuedCommand[]) => void): () => void {
    this.listeners.push(listener);
    return () => {
      const index = this.listeners.indexOf(listener);
      if (index > -1) {
        this.listeners.splice(index, 1);
      }
    };
  }

  /**
   * Guardar cola en AsyncStorage
   */
  private static async saveQueue(): Promise<void> {
    try {
      const queueJson = JSON.stringify(this.queue);
      await AsyncStorage.setItem(QUEUE_STORAGE_KEY, queueJson);
    } catch (error) {
      console.error('[CommandQueue] Failed to save queue:', error);
    }
  }

  /**
   * Notificar a los listeners
   */
  private static notifyListeners(): void {
    const queueCopy = [...this.queue];
    this.listeners.forEach((listener) => {
      try {
        listener(queueCopy);
      } catch (error) {
        console.error('[CommandQueue] Listener error:', error);
      }
    });
  }
}

================================================================================
FILE: lib/config-manager.ts
================================================================================

/**
 * Gestor de Exportaci√≥n/Importaci√≥n de Configuraci√≥n
 * Permite migrar toda la configuraci√≥n de la app entre dispositivos
 */

import AsyncStorage from '@react-native-async-storage/async-storage';
import * as FileSystem from 'expo-file-system/legacy';
import * as Sharing from 'expo-sharing';
import { Platform } from 'react-native';

export interface AppConfiguration {
  version: string;
  exportDate: string;
  profiles: any[];
  macros: any[];
  settings: {
    telnetConfig: any;
    expertMode: {
      enabled: boolean;
      pinHash?: string;
    };
    theme: string;
    notificationsEnabled: boolean;
  };
  metadata: {
    deviceInfo: string;
    appVersion: string;
  };
}

const CONFIG_VERSION = '1.0.0';
const STORAGE_KEYS = {
  PROFILES: '@mib2_profiles',
  ACTIVE_PROFILE: '@mib2_active_profile',
  TELNET_CONFIG: '@mib2_telnet_config',
  EXPERT_MODE: '@mib2_expert_mode',
  EXPERT_PIN: '@mib2_expert_pin',
  THEME: '@mib2_theme',
  NOTIFICATIONS: '@mib2_notifications_enabled',
};

export class ConfigManager {
  /**
   * Exportar toda la configuraci√≥n de la app
   */
  static async exportConfiguration(): Promise<{
    success: boolean;
    filePath?: string;
    error?: string;
  }> {
    try {
      console.log('[ConfigManager] Starting configuration export...');

      // Recopilar toda la configuraci√≥n
      const config: AppConfiguration = {
        version: CONFIG_VERSION,
        exportDate: new Date().toISOString(),
        profiles: [],
        macros: [],
        settings: {
          telnetConfig: null,
          expertMode: {
            enabled: false,
          },
          theme: 'light',
          notificationsEnabled: true,
        },
        metadata: {
          deviceInfo: Platform.OS + ' ' + Platform.Version,
          appVersion: '3.3.0',
        },
      };

      // Cargar perfiles
      try {
        const profilesJson = await AsyncStorage.getItem(STORAGE_KEYS.PROFILES);
        if (profilesJson) {
          config.profiles = JSON.parse(profilesJson);
        }
      } catch (error) {
        console.warn('[ConfigManager] Error loading profiles:', error);
      }

      // Cargar configuraci√≥n de Telnet
      try {
        const telnetConfigJson = await AsyncStorage.getItem(STORAGE_KEYS.TELNET_CONFIG);
        if (telnetConfigJson) {
          config.settings.telnetConfig = JSON.parse(telnetConfigJson);
        }
      } catch (error) {
        console.warn('[ConfigManager] Error loading telnet config:', error);
      }

      // Cargar configuraci√≥n de Modo Experto
      try {
        const expertModeJson = await AsyncStorage.getItem(STORAGE_KEYS.EXPERT_MODE);
        if (expertModeJson) {
          const expertMode = JSON.parse(expertModeJson);
          config.settings.expertMode.enabled = expertMode.enabled || false;
        }

        const pinHash = await AsyncStorage.getItem(STORAGE_KEYS.EXPERT_PIN);
        if (pinHash) {
          config.settings.expertMode.pinHash = pinHash;
        }
      } catch (error) {
        console.warn('[ConfigManager] Error loading expert mode:', error);
      }

      // Cargar tema
      try {
        const theme = await AsyncStorage.getItem(STORAGE_KEYS.THEME);
        if (theme) {
          config.settings.theme = theme;
        }
      } catch (error) {
        console.warn('[ConfigManager] Error loading theme:', error);
      }

      // Cargar configuraci√≥n de notificaciones
      try {
        const notificationsEnabled = await AsyncStorage.getItem(STORAGE_KEYS.NOTIFICATIONS);
        if (notificationsEnabled !== null) {
          config.settings.notificationsEnabled = notificationsEnabled === 'true';
        }
      } catch (error) {
        console.warn('[ConfigManager] Error loading notifications setting:', error);
      }

      // Generar nombre de archivo
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
      const fileName = `mib2_config_${timestamp}.json`;
      const filePath = `${FileSystem.documentDirectory}${fileName}`;

      // Escribir archivo JSON
      const configJson = JSON.stringify(config, null, 2);
      await FileSystem.writeAsStringAsync(filePath, configJson, {
        encoding: FileSystem.EncodingType.UTF8,
      });

      console.log('[ConfigManager] Configuration exported to:', filePath);

      // Compartir archivo si est√° disponible
      if (await Sharing.isAvailableAsync()) {
        await Sharing.shareAsync(filePath, {
          mimeType: 'application/json',
          dialogTitle: 'Exportar Configuraci√≥n MIB2',
          UTI: 'public.json',
        });
      }

      return {
        success: true,
        filePath,
      };
    } catch (error) {
      console.error('[ConfigManager] Export failed:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }

  /**
   * Importar configuraci√≥n desde archivo JSON
   */
  static async importConfiguration(fileUri: string): Promise<{
    success: boolean;
    message?: string;
    error?: string;
  }> {
    try {
      console.log('[ConfigManager] Starting configuration import from:', fileUri);

      // Leer archivo
      const configJson = await FileSystem.readAsStringAsync(fileUri, {
        encoding: FileSystem.EncodingType.UTF8,
      });

      const config: AppConfiguration = JSON.parse(configJson);

      // Validar versi√≥n
      if (!config.version || config.version !== CONFIG_VERSION) {
        return {
          success: false,
          error: `Incompatible configuration version. Expected ${CONFIG_VERSION}, got ${config.version || 'unknown'}`,
        };
      }

      // Validar estructura
      if (!config.settings || !config.exportDate) {
        return {
          success: false,
          error: 'Invalid configuration file structure',
        };
      }

      // Importar perfiles
      if (config.profiles && Array.isArray(config.profiles)) {
        await AsyncStorage.setItem(STORAGE_KEYS.PROFILES, JSON.stringify(config.profiles));
        console.log(`[ConfigManager] Imported ${config.profiles.length} profiles`);
      }

      // Importar configuraci√≥n de Telnet
      if (config.settings.telnetConfig) {
        await AsyncStorage.setItem(
          STORAGE_KEYS.TELNET_CONFIG,
          JSON.stringify(config.settings.telnetConfig)
        );
        console.log('[ConfigManager] Imported Telnet configuration');
      }

      // Importar configuraci√≥n de Modo Experto
      if (config.settings.expertMode) {
        await AsyncStorage.setItem(
          STORAGE_KEYS.EXPERT_MODE,
          JSON.stringify({ enabled: config.settings.expertMode.enabled })
        );

        if (config.settings.expertMode.pinHash) {
          await AsyncStorage.setItem(STORAGE_KEYS.EXPERT_PIN, config.settings.expertMode.pinHash);
        }
        console.log('[ConfigManager] Imported Expert Mode configuration');
      }

      // Importar tema
      if (config.settings.theme) {
        await AsyncStorage.setItem(STORAGE_KEYS.THEME, config.settings.theme);
        console.log('[ConfigManager] Imported theme:', config.settings.theme);
      }

      // Importar configuraci√≥n de notificaciones
      if (config.settings.notificationsEnabled !== undefined) {
        await AsyncStorage.setItem(
          STORAGE_KEYS.NOTIFICATIONS,
          config.settings.notificationsEnabled.toString()
        );
        console.log('[ConfigManager] Imported notifications setting');
      }

      return {
        success: true,
        message: `Configuration imported successfully from ${new Date(config.exportDate).toLocaleDateString()}`,
      };
    } catch (error) {
      console.error('[ConfigManager] Import failed:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }

  /**
   * Obtener informaci√≥n de un archivo de configuraci√≥n sin importarlo
   */
  static async getConfigurationInfo(fileUri: string): Promise<{
    success: boolean;
    info?: {
      version: string;
      exportDate: string;
      profileCount: number;
      deviceInfo: string;
    };
    error?: string;
  }> {
    try {
      const configJson = await FileSystem.readAsStringAsync(fileUri, {
        encoding: FileSystem.EncodingType.UTF8,
      });

      const config: AppConfiguration = JSON.parse(configJson);

      return {
        success: true,
        info: {
          version: config.version,
          exportDate: config.exportDate,
          profileCount: config.profiles?.length || 0,
          deviceInfo: config.metadata?.deviceInfo || 'Unknown',
        },
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }

  /**
   * Limpiar toda la configuraci√≥n (reset de f√°brica)
   */
  static async clearAllConfiguration(): Promise<{
    success: boolean;
    error?: string;
  }> {
    try {
      console.log('[ConfigManager] Clearing all configuration...');

      const keys = Object.values(STORAGE_KEYS);
      await AsyncStorage.multiRemove(keys);

      console.log('[ConfigManager] All configuration cleared');

      return {
        success: true,
      };
    } catch (error) {
      console.error('[ConfigManager] Clear failed:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }
}

================================================================================
FILE: lib/expert-mode-provider.tsx
================================================================================

/**
 * Expert Mode Provider
 * 
 * Manages expert mode state and PIN authentication
 */

import React, { createContext, useContext, useState, useEffect } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';

interface ExpertModeContextType {
  isExpertMode: boolean;
  isPinSet: boolean;
  enableExpertMode: (pin: string) => Promise<boolean>;
  disableExpertMode: () => Promise<void>;
  setPin: (newPin: string) => Promise<void>;
  verifyPin: (pin: string) => Promise<boolean>;
  changePin: (oldPin: string, newPin: string) => Promise<boolean>;
  resetPin: () => Promise<void>;
}

const ExpertModeContext = createContext<ExpertModeContextType | undefined>(undefined);

const STORAGE_KEYS = {
  EXPERT_MODE: '@mib2_expert_mode',
  PIN_HASH: '@mib2_pin_hash',
};

/**
 * Simple hash function for PIN storage
 * In production, use a proper cryptographic hash like bcrypt
 */
function hashPin(pin: string): string {
  let hash = 0;
  for (let i = 0; i < pin.length; i++) {
    const char = pin.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  return hash.toString(36);
}

export function ExpertModeProvider({ children }: { children: React.ReactNode }) {
  const [isExpertMode, setIsExpertMode] = useState(false);
  const [isPinSet, setIsPinSet] = useState(false);

  // Load expert mode state on mount
  useEffect(() => {
    loadExpertModeState();
  }, []);

  const loadExpertModeState = async () => {
    try {
      const [expertModeValue, pinHashValue] = await Promise.all([
        AsyncStorage.getItem(STORAGE_KEYS.EXPERT_MODE),
        AsyncStorage.getItem(STORAGE_KEYS.PIN_HASH),
      ]);

      setIsExpertMode(expertModeValue === 'true');
      setIsPinSet(pinHashValue !== null);
    } catch (error) {
      console.error('Error loading expert mode state:', error);
    }
  };

  const setPin = async (newPin: string): Promise<void> => {
    if (newPin.length < 4) {
      throw new Error('PIN debe tener al menos 4 d√≠gitos');
    }

    const hashed = hashPin(newPin);
    await AsyncStorage.setItem(STORAGE_KEYS.PIN_HASH, hashed);
    setIsPinSet(true);
  };

  const verifyPin = async (pin: string): Promise<boolean> => {
    try {
      const storedHash = await AsyncStorage.getItem(STORAGE_KEYS.PIN_HASH);
      if (!storedHash) {
        return false;
      }

      const inputHash = hashPin(pin);
      return inputHash === storedHash;
    } catch (error) {
      console.error('Error verifying PIN:', error);
      return false;
    }
  };

  const enableExpertMode = async (pin: string): Promise<boolean> => {
    const isValid = await verifyPin(pin);
    if (isValid) {
      await AsyncStorage.setItem(STORAGE_KEYS.EXPERT_MODE, 'true');
      setIsExpertMode(true);
      return true;
    }
    return false;
  };

  const disableExpertMode = async (): Promise<void> => {
    await AsyncStorage.setItem(STORAGE_KEYS.EXPERT_MODE, 'false');
    setIsExpertMode(false);
  };

  const changePin = async (oldPin: string, newPin: string): Promise<boolean> => {
    const isOldPinValid = await verifyPin(oldPin);
    if (!isOldPinValid) {
      return false;
    }

    await setPin(newPin);
    return true;
  };

  const resetPin = async (): Promise<void> => {
    await AsyncStorage.multiRemove([STORAGE_KEYS.PIN_HASH, STORAGE_KEYS.EXPERT_MODE]);
    setIsPinSet(false);
    setIsExpertMode(false);
  };

  const value: ExpertModeContextType = {
    isExpertMode,
    isPinSet,
    enableExpertMode,
    disableExpertMode,
    setPin,
    verifyPin,
    changePin,
    resetPin,
  };

  return (
    <ExpertModeContext.Provider value={value}>
      {children}
    </ExpertModeContext.Provider>
  );
}

export function useExpertMode(): ExpertModeContextType {
  const context = useContext(ExpertModeContext);
  if (context === undefined) {
    throw new Error('useExpertMode must be used within ExpertModeProvider');
  }
  return context;
}

================================================================================
FILE: lib/fec-codes.ts
================================================================================

/**
 * FEC (Feature Enablement Code) Library
 * C√≥digos FEC conocidos y documentados para MIB2 STD2
 */

export interface FecCode {
  code: string;
  name: string;
  description: string;
  category: 'connectivity' | 'navigation' | 'display' | 'performance' | 'other';
  tested: boolean;
  notes?: string;
}

export const FEC_CODES: FecCode[] = [
  // Connectivity
  {
    code: '00010001',
    name: 'Apple CarPlay',
    description: 'Activa Apple CarPlay para iPhone',
    category: 'connectivity',
    tested: true,
  },
  {
    code: '00010002',
    name: 'Android Auto',
    description: 'Activa Android Auto para dispositivos Android',
    category: 'connectivity',
    tested: true,
  },
  {
    code: '00010004',
    name: 'MirrorLink',
    description: 'Activa MirrorLink para dispositivos compatibles',
    category: 'connectivity',
    tested: true,
  },
  {
    code: '00010008',
    name: 'App-Connect (Full-Link)',
    description: 'Activa todas las funciones de App-Connect',
    category: 'connectivity',
    tested: true,
  },
  
  // Navigation
  {
    code: '09400008',
    name: 'Mapas Europa',
    description: 'Activa regi√≥n de mapas Europa (EU)',
    category: 'navigation',
    tested: true,
  },
  {
    code: '09410008',
    name: 'Mapas Norteam√©rica',
    description: 'Activa regi√≥n de mapas Norteam√©rica (NAR)',
    category: 'navigation',
    tested: true,
  },
  {
    code: '09420008',
    name: 'Mapas China',
    description: 'Activa regi√≥n de mapas China (CN)',
    category: 'navigation',
    tested: false,
  },
  {
    code: '09430008',
    name: 'Mapas Resto del Mundo',
    description: 'Activa regi√≥n de mapas ROW (Rest of World)',
    category: 'navigation',
    tested: false,
  },
  
  // Performance & Diagnostics
  {
    code: '00060001',
    name: 'Performance Monitor',
    description: 'Activa monitor de rendimiento del veh√≠culo',
    category: 'performance',
    tested: true,
  },
  {
    code: '00060100',
    name: 'Vehicle Data Interface',
    description: 'Interfaz de datos del veh√≠culo',
    category: 'performance',
    tested: false,
  },
  
  // Display
  {
    code: '00050001',
    name: 'Ambient Light Control',
    description: 'Control de iluminaci√≥n ambiental',
    category: 'display',
    tested: false,
  },
  {
    code: '00050002',
    name: 'Digital Cockpit',
    description: 'Activa funciones del cockpit digital',
    category: 'display',
    tested: false,
  },
  
  // Other
  {
    code: '00070001',
    name: 'Voice Control',
    description: 'Control por voz avanzado',
    category: 'other',
    tested: false,
  },
  {
    code: '00080001',
    name: 'Gesture Control',
    description: 'Control por gestos',
    category: 'other',
    tested: false,
  },
];

export const FEC_CATEGORIES = {
  connectivity: 'Conectividad',
  navigation: 'Navegaci√≥n',
  display: 'Pantalla',
  performance: 'Rendimiento',
  other: 'Otros',
} as const;

export function getFecCodesByCategory(category: FecCode['category']): FecCode[] {
  return FEC_CODES.filter((code) => code.category === category);
}

export function searchFecCodes(query: string): FecCode[] {
  const lowerQuery = query.toLowerCase();
  return FEC_CODES.filter(
    (code) =>
      code.name.toLowerCase().includes(lowerQuery) ||
      code.description.toLowerCase().includes(lowerQuery) ||
      code.code.includes(query)
  );
}

/**
 * Comandos Telnet para inyectar c√≥digos FEC
 */
export function generateFecInjectionCommands(codes: string[]): string[] {
  return [
    '# Montar sistema de archivos',
    'mount -uw /net/rcc/dev/shmem',
    '',
    '# Inyectar c√≥digos FEC',
    ...codes.map((code) => `echo "${code}" >> /net/rcc/dev/shmem/addfec.txt`),
    '',
    '# Reiniciar unidad para aplicar cambios',
    'reboot',
  ];
}

/**
 * URL del generador FEC online
 */
export const FEC_GENERATOR_URL = 'https://vwcoding.ru/en/utils/fec/';

/**
 * Validar formato de c√≥digo FEC (8 caracteres hexadecimales)
 */
export function isValidFecCode(code: string): boolean {
  return /^[0-9A-Fa-f]{8}$/.test(code);
}

/**
 * Formatear c√≥digo FEC (agregar ceros si es necesario)
 */
export function formatFecCode(code: string): string {
  const cleaned = code.replace(/[^0-9A-Fa-f]/g, '').toUpperCase();
  return cleaned.padStart(8, '0');
}

================================================================================
FILE: lib/fec-generator.ts
================================================================================

/**
 * Generador de C√≥digos FEC (Feature Enable Codes)
 * Para activaci√≥n de funciones SWaP en unidades MIB2
 * 
 * Basado en el documento t√©cnico MIB2Acceso.pdf
 */

export interface FECCode {
  code: string;
  name: string;
  description: string;
  category: 'connectivity' | 'performance' | 'multimedia';
}

/**
 * C√≥digos FEC predefinidos para funciones comunes
 */
export const PREDEFINED_FEC_CODES: FECCode[] = [
  {
    code: '00010001',
    name: 'Apple CarPlay',
    description: 'Habilita integraci√≥n de Apple CarPlay en el sistema de infotainment',
    category: 'connectivity',
  },
  {
    code: '00010002',
    name: 'Android Auto',
    description: 'Habilita integraci√≥n de Android Auto en el sistema de infotainment',
    category: 'connectivity',
  },
  {
    code: '00010004',
    name: 'MirrorLink',
    description: 'Habilita MirrorLink para dispositivos compatibles',
    category: 'connectivity',
  },
  {
    code: '00010008',
    name: 'App-Connect (Full-Link)',
    description: 'Habilita todas las funciones de App-Connect',
    category: 'connectivity',
  },
  {
    code: '00060001',
    name: 'Performance Monitor',
    description: 'Habilita el monitor de rendimiento en el cuadro digital',
    category: 'performance',
  },
  {
    code: '09400008',
    name: 'Mapas Europa',
    description: 'Activa regi√≥n de mapas Europa (EU)',
    category: 'multimedia',
  },
  {
    code: '09410008',
    name: 'Mapas Norteam√©rica',
    description: 'Activa regi√≥n de mapas Norteam√©rica (NAR)',
    category: 'multimedia',
  },
];

/**
 * URL del generador FEC online
 */
export const FEC_GENERATOR_URL = 'https://vwcoding.ru/en/utils/fec/';

/**
 * Generar comandos Telnet para inyectar c√≥digos FEC
 */
export function generateFecInjectionCommands(codes: string[]): string[] {
  return [
    '# Montar sistema de archivos',
    'mount -uw /net/rcc/dev/shmem',
    '',
    '# Inyectar c√≥digos FEC',
    ...codes.map((code) => `echo "${code}" >> /net/rcc/dev/shmem/addfec.txt`),
    '',
    '# Reiniciar unidad para aplicar cambios',
    'reboot',
  ];
}

/**
 * Interfaz para datos del veh√≠culo
 */
export interface VehicleData {
  vin: string;  // Vehicle Identification Number
  vcrn: string; // Vehicle Component Registration Number
}

/**
 * Validar formato de VIN (17 caracteres alfanum√©ricos)
 */
export function validateVIN(vin: string): boolean {
  const vinRegex = /^[A-HJ-NPR-Z0-9]{17}$/;
  return vinRegex.test(vin.toUpperCase());
}

/**
 * Validar formato de VCRN
 */
export function validateVCRN(vcrn: string): boolean {
  // VCRN t√≠picamente es un n√∫mero de serie de la unidad
  return vcrn.length >= 8 && vcrn.length <= 20;
}

/**
 * Generar c√≥digo FEC basado en VIN y VCRN
 * 
 * NOTA: Este es un algoritmo simplificado para demostraci√≥n.
 * El algoritmo real de VW es propietario y m√°s complejo.
 * Para uso en producci√≥n, se requiere acceso a la base de datos oficial de VW
 * o uso de herramientas como OBDeleven que tienen acceso a los algoritmos reales.
 */
export function generateFECCode(vehicleData: VehicleData, featureCode: string): string {
  const { vin, vcrn } = vehicleData;
  
  // Validar inputs
  if (!validateVIN(vin)) {
    throw new Error('VIN inv√°lido. Debe tener 17 caracteres alfanum√©ricos.');
  }
  
  if (!validateVCRN(vcrn)) {
    throw new Error('VCRN inv√°lido. Debe tener entre 8 y 20 caracteres.');
  }
  
  // Algoritmo simplificado (placeholder)
  // En la realidad, esto requiere la clave privada de VW
  const vinHash = simpleHash(vin);
  const vcrnHash = simpleHash(vcrn);
  const featureHash = simpleHash(featureCode);
  
  const combinedHash = (vinHash + vcrnHash + featureHash) % 0xFFFFFFFF;
  const fecCode = combinedHash.toString(16).toUpperCase().padStart(8, '0');
  
  return fecCode;
}

/**
 * Funci√≥n hash simple para demostraci√≥n
 * (NO usar en producci√≥n - solo para prop√≥sitos educativos)
 */
function simpleHash(str: string): number {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  return Math.abs(hash);
}

/**
 * Generar contenido del archivo ExceptionList.txt
 */
export function generateExceptionList(fecCodes: string[]): string {
  const header = `# ExceptionList.txt
# Generated by MIB2 Controller
# Date: ${new Date().toISOString()}
# 
# Este archivo contiene c√≥digos FEC que ser√°n aceptados por el sistema
# independientemente de la validaci√≥n criptogr√°fica.
# 
# IMPORTANTE: Este m√©todo "parchea" el sistema para aceptar c√≥digos sin
# verificaci√≥n de firma digital de VW AG.
#
# Instrucciones:
# 1. Copiar este archivo a la tarjeta SD de la unidad MIB2
# 2. Ejecutar el MIB2 Toolbox para aplicar el parcheo
# 3. Los c√≥digos listados ser√°n aceptados como v√°lidos
#
# C√≥digos FEC:
`;

  const codes = fecCodes.map(code => `${code}`).join('\n');
  
  return header + codes + '\n';
}

/**
 * Obtener c√≥digo FEC predefinido por nombre
 */
export function getPredefinedFECCode(name: string): FECCode | undefined {
  return PREDEFINED_FEC_CODES.find(
    code => code.name.toLowerCase() === name.toLowerCase()
  );
}

/**
 * Obtener todos los c√≥digos FEC por categor√≠a
 */
export function getFECCodesByCategory(category: FECCode['category']): FECCode[] {
  return PREDEFINED_FEC_CODES.filter(code => code.category === category);
}

/**
 * Validar formato de c√≥digo FEC (8 d√≠gitos hexadecimales)
 */
export function validateFECCode(code: string): boolean {
  const fecRegex = /^[0-9A-F]{8}$/i;
  return fecRegex.test(code);
}

/**
 * Informaci√≥n sobre el proceso de inyecci√≥n de c√≥digos FEC
 */
export const FEC_INJECTION_INFO = {
  title: 'Proceso de Inyecci√≥n de C√≥digos FEC',
  steps: [
    {
      step: 1,
      title: 'Generar C√≥digos',
      description: 'Utilizar el generador de FEC basado en VIN y VCRN, o usar c√≥digos predefinidos.',
    },
    {
      step: 2,
      title: 'Crear ExceptionList.txt',
      description: 'Generar el archivo ExceptionList.txt con los c√≥digos FEC deseados.',
    },
    {
      step: 3,
      title: 'Instalar MIB2 Toolbox',
      description: 'Asegurarse de que el MIB2 STD2 Toolbox est√© instalado en la unidad.',
    },
    {
      step: 4,
      title: 'Aplicar Parcheo',
      description: 'Ejecutar la funci√≥n "Patch tsd.mibstd2.system.swap" desde el men√∫ verde (GEM) del Toolbox.',
    },
    {
      step: 5,
      title: 'Inyectar C√≥digos',
      description: 'Una vez parcheado el sistema, consultar la ExceptionList.txt generada. Los c√≥digos ser√°n aceptados como "Legal" independientemente de la firma criptogr√°fica.',
    },
  ],
  warnings: [
    '‚ö†Ô∏è Este m√©todo sortea la validaci√≥n de firmware digital de VW AG',
    '‚ö†Ô∏è Solo funciona en unidades 1-SD que carecen de las rutinas de validaci√≥n necesarias',
    '‚ö†Ô∏è El parcheo modifica el binario del sistema (tsd.mibstd2.system.swap)',
    '‚ö†Ô∏è Realizar backup antes de aplicar cualquier modificaci√≥n',
  ],
  technicalNote: 'El MIB STD2 Toolbox automatiza el proceso de "parcheo". En lugar de intentar crackear la clave privada de VW (computacionalmente inviable), el Toolbox modifica el binario del sistema para alterar la rutina de verificaci√≥n de firmas. Una vez parcheado, el sistema se instruye para consultar una "Lista de Excepciones" (ExceptionList.txt) generada por el usuario.',
};

/**
 * Generar comando para inyecci√≥n v√≠a Toolbox
 */
export function generateToolboxInjectionCommand(fecCodes: string[]): string {
  return `# Comandos para inyecci√≥n de c√≥digos FEC v√≠a MIB2 Toolbox
# Ejecutar desde Telnet (root@192.168.1.4)

# 1. Verificar que el Toolbox est√© instalado
ls -la /net/mmx/mnt/app/eso/hmi/lsd/jars/

# 2. Crear ExceptionList.txt en la tarjeta SD
cat > /media/mp000/ExceptionList.txt << EOF
${fecCodes.join('\n')}
EOF

# 3. Aplicar parcheo (desde el men√∫ verde GEM del Toolbox)
# Seleccionar: "Patch tsd.mibstd2.system.swap"

# 4. Verificar c√≥digos inyectados
# Los c√≥digos FEC ahora ser√°n aceptados como v√°lidos

echo "C√≥digos FEC inyectados exitosamente"
`;
}

================================================================================
FILE: lib/macros.ts
================================================================================

/**
 * Command Macros System
 * 
 * Predefined sequences of commands for common MIB2 operations
 */

export interface MacroStep {
  command: string;
  description: string;
  delay?: number; // Delay in milliseconds before next command
  optional?: boolean; // If true, failure won't stop the macro
}

export interface CommandMacro {
  id: string;
  name: string;
  description: string;
  category: 'backup' | 'adaptation' | 'diagnostic' | 'maintenance' | 'custom';
  steps: MacroStep[];
  estimatedDuration: number; // in seconds
  riskLevel: 'safe' | 'moderate' | 'high';
  requiresExpertMode: boolean;
}

export const PREDEFINED_MACROS: CommandMacro[] = [
  // ========== BACKUP MACROS ==========
  {
    id: 'full_backup',
    name: 'Backup Completo',
    description: 'Crea un backup completo de adaptaciones y configuraci√≥n',
    category: 'backup',
    estimatedDuration: 30,
    riskLevel: 'safe',
    requiresExpertMode: false,
    steps: [
      {
        command: 'date',
        description: 'Obtener fecha actual',
      },
      {
        command: 'mkdir -p /net/rcc/mnt/efs-persist/backups',
        description: 'Crear directorio de backups',
        optional: true,
      },
      {
        command: 'cp -r /net/rcc/mnt/efs-persist/Adaptation /net/rcc/mnt/efs-persist/backups/Adaptation_$(date +%Y%m%d_%H%M%S)',
        description: 'Backup de adaptaciones',
        delay: 2000,
      },
      {
        command: 'cp /net/rcc/mnt/efs-persist/skin.cfg /net/rcc/mnt/efs-persist/backups/skin_$(date +%Y%m%d_%H%M%S).cfg',
        description: 'Backup de configuraci√≥n de skin',
        delay: 1000,
        optional: true,
      },
      {
        command: 'ls -lh /net/rcc/mnt/efs-persist/backups/',
        description: 'Verificar backups creados',
        delay: 1000,
      },
    ],
  },
  {
    id: 'backup_adaptations',
    name: 'Backup de Adaptaciones',
    description: 'Crea un backup solo de las adaptaciones',
    category: 'backup',
    estimatedDuration: 10,
    riskLevel: 'safe',
    requiresExpertMode: false,
    steps: [
      {
        command: 'mkdir -p /net/rcc/mnt/efs-persist/backups',
        description: 'Crear directorio de backups',
        optional: true,
      },
      {
        command: 'cp -r /net/rcc/mnt/efs-persist/Adaptation /net/rcc/mnt/efs-persist/backups/Adaptation_backup_$(date +%Y%m%d)',
        description: 'Copiar adaptaciones',
        delay: 2000,
      },
      {
        command: 'ls -la /net/rcc/mnt/efs-persist/backups/',
        description: 'Listar backups',
        delay: 1000,
      },
    ],
  },

  // ========== ADAPTATION MACROS ==========
  {
    id: 'enable_all_features',
    name: 'Activar Todas las Caracter√≠sticas',
    description: 'Activa Green Menu, Video en Movimiento y l√≠neas gu√≠a de c√°mara',
    category: 'adaptation',
    estimatedDuration: 15,
    riskLevel: 'high',
    requiresExpertMode: true,
    steps: [
      {
        command: 'cp -r /net/rcc/mnt/efs-persist/Adaptation /net/rcc/mnt/efs-persist/Adaptation_backup_pre_activation',
        description: 'Backup de seguridad',
        delay: 2000,
      },
      {
        command: 'echo "1" > /net/rcc/mnt/efs-persist/Adaptation/GreenMenu',
        description: 'Activar Green Menu',
        delay: 1000,
      },
      {
        command: 'echo "1" > /net/rcc/mnt/efs-persist/Adaptation/VideoInMotion',
        description: 'Activar Video en Movimiento',
        delay: 1000,
      },
      {
        command: 'echo "1" > /net/rcc/mnt/efs-persist/Adaptation/CameraGuidelines',
        description: 'Activar l√≠neas gu√≠a de c√°mara',
        delay: 1000,
      },
      {
        command: 'ls -la /net/rcc/mnt/efs-persist/Adaptation/',
        description: 'Verificar adaptaciones',
        delay: 1000,
      },
    ],
  },
  {
    id: 'safe_adaptations',
    name: 'Adaptaciones Seguras',
    description: 'Activa solo adaptaciones seguras (Green Menu y l√≠neas gu√≠a)',
    category: 'adaptation',
    estimatedDuration: 10,
    riskLevel: 'moderate',
    requiresExpertMode: false,
    steps: [
      {
        command: 'cp -r /net/rcc/mnt/efs-persist/Adaptation /net/rcc/mnt/efs-persist/Adaptation_backup_safe',
        description: 'Backup de seguridad',
        delay: 2000,
      },
      {
        command: 'echo "1" > /net/rcc/mnt/efs-persist/Adaptation/GreenMenu',
        description: 'Activar Green Menu',
        delay: 1000,
      },
      {
        command: 'echo "1" > /net/rcc/mnt/efs-persist/Adaptation/CameraGuidelines',
        description: 'Activar l√≠neas gu√≠a de c√°mara',
        delay: 1000,
      },
      {
        command: 'cat /net/rcc/mnt/efs-persist/Adaptation/GreenMenu',
        description: 'Verificar Green Menu',
        delay: 500,
      },
    ],
  },

  // ========== DIAGNOSTIC MACROS ==========
  {
    id: 'system_health_check',
    name: 'Chequeo de Salud del Sistema',
    description: 'Verifica memoria, disco, temperatura y procesos',
    category: 'diagnostic',
    estimatedDuration: 20,
    riskLevel: 'safe',
    requiresExpertMode: false,
    steps: [
      {
        command: 'free',
        description: 'Verificar uso de memoria',
        delay: 1000,
      },
      {
        command: 'df -h',
        description: 'Verificar espacio en disco',
        delay: 1000,
      },
      {
        command: 'cat /sys/class/thermal/thermal_zone0/temp',
        description: 'Verificar temperatura',
        delay: 1000,
        optional: true,
      },
      {
        command: 'ps aux | head -20',
        description: 'Listar procesos principales',
        delay: 1000,
      },
      {
        command: 'uptime',
        description: 'Verificar tiempo de actividad',
        delay: 500,
      },
    ],
  },
  {
    id: 'network_diagnostic',
    name: 'Diagn√≥stico de Red',
    description: 'Verifica configuraci√≥n de red y conectividad',
    category: 'diagnostic',
    estimatedDuration: 15,
    riskLevel: 'safe',
    requiresExpertMode: false,
    steps: [
      {
        command: 'ifconfig',
        description: 'Mostrar interfaces de red',
        delay: 1000,
      },
      {
        command: 'route -n',
        description: 'Mostrar tabla de rutas',
        delay: 1000,
      },
      {
        command: 'cat /etc/resolv.conf',
        description: 'Mostrar servidores DNS',
        delay: 500,
      },
      {
        command: 'ping -c 4 192.168.1.1',
        description: 'Probar conectividad con gateway',
        delay: 5000,
        optional: true,
      },
    ],
  },
  {
    id: 'firmware_info',
    name: 'Informaci√≥n de Firmware',
    description: 'Obtiene informaci√≥n detallada del firmware y hardware',
    category: 'diagnostic',
    estimatedDuration: 10,
    riskLevel: 'safe',
    requiresExpertMode: false,
    steps: [
      {
        command: 'cat /net/rcc/mnt/efs-persist/FW/version.txt',
        description: 'Versi√≥n de firmware',
        delay: 500,
      },
      {
        command: 'cat /net/rcc/mnt/efs-persist/HWVersion',
        description: 'Versi√≥n de hardware',
        delay: 500,
      },
      {
        command: 'cat /net/rcc/mnt/efs-persist/serialnumber',
        description: 'N√∫mero de serie',
        delay: 500,
      },
      {
        command: 'uname -a',
        description: 'Informaci√≥n del sistema',
        delay: 500,
      },
    ],
  },

  // ========== MAINTENANCE MACROS ==========
  {
    id: 'cleanup_system',
    name: 'Limpieza del Sistema',
    description: 'Limpia archivos temporales y logs antiguos',
    category: 'maintenance',
    estimatedDuration: 15,
    riskLevel: 'moderate',
    requiresExpertMode: true,
    steps: [
      {
        command: 'df -h',
        description: 'Verificar espacio antes de limpiar',
        delay: 1000,
      },
      {
        command: 'rm -f /tmp/*',
        description: 'Limpiar archivos temporales',
        delay: 2000,
        optional: true,
      },
      {
        command: 'find /var/log -name "*.log" -type f -mtime +7 -delete',
        description: 'Eliminar logs antiguos (>7 d√≠as)',
        delay: 2000,
        optional: true,
      },
      {
        command: 'df -h',
        description: 'Verificar espacio despu√©s de limpiar',
        delay: 1000,
      },
    ],
  },
];

/**
 * Get macros by category
 */
export function getMacrosByCategory(category: CommandMacro['category']): CommandMacro[] {
  return PREDEFINED_MACROS.filter(macro => macro.category === category);
}

/**
 * Get macro by ID
 */
export function getMacroById(id: string): CommandMacro | undefined {
  return PREDEFINED_MACROS.find(macro => macro.id === id);
}

/**
 * Get safe macros (non-expert)
 */
export function getSafeMacros(): CommandMacro[] {
  return PREDEFINED_MACROS.filter(macro => !macro.requiresExpertMode);
}

/**
 * Get expert macros
 */
export function getExpertMacros(): CommandMacro[] {
  return PREDEFINED_MACROS.filter(macro => macro.requiresExpertMode);
}

/**
 * Calculate total steps in a macro
 */
export function getMacroStepCount(macro: CommandMacro): number {
  return macro.steps.length;
}

/**
 * Get category label
 */
export function getCategoryLabel(category: CommandMacro['category']): string {
  const labels: Record<CommandMacro['category'], string> = {
    backup: 'Backup',
    adaptation: 'Adaptaciones',
    diagnostic: 'Diagn√≥stico',
    maintenance: 'Mantenimiento',
    custom: 'Personalizado',
  };
  return labels[category];
}

/**
 * Get category color
 */
export function getCategoryColor(category: CommandMacro['category']): string {
  const colors: Record<CommandMacro['category'], string> = {
    backup: 'primary',
    adaptation: 'warning',
    diagnostic: 'success',
    maintenance: 'muted',
    custom: 'foreground',
  };
  return colors[category];
}

================================================================================
FILE: lib/mib2-commands.ts
================================================================================

/**
 * MIB2 Command Library
 * 
 * Comprehensive library of commands for MIB2 STD2 Technisat/Preh
 * Firmware T480 and variants
 */

export type CommandCategory = 
  | 'information' 
  | 'diagnostic' 
  | 'configuration'
  | 'adaptation'
  | 'skin'
  | 'network'
  | 'filesystem'
  | 'advanced';

export type RiskLevel = 'safe' | 'moderate' | 'high' | 'critical';

export interface MIB2Command {
  id: string;
  name: string;
  category: CommandCategory;
  riskLevel: RiskLevel;
  description: string;
  command: string;
  requiresConfirmation: boolean;
  expertOnly: boolean;
  firmwareVersion?: string;
  notes?: string;
}

export const MIB2_COMMANDS: MIB2Command[] = [
  // ========== INFORMATION COMMANDS ==========
  {
    id: 'firmware_version',
    name: 'Versi√≥n de Firmware',
    category: 'information',
    riskLevel: 'safe',
    description: 'Obtiene la versi√≥n actual del firmware instalado',
    command: 'cat /net/rcc/mnt/efs-persist/FW/version.txt',
    requiresConfirmation: false,
    expertOnly: false,
  },
  {
    id: 'system_info',
    name: 'Informaci√≥n del Sistema',
    category: 'information',
    riskLevel: 'safe',
    description: 'Muestra informaci√≥n del sistema operativo QNX',
    command: 'uname -a',
    requiresConfirmation: false,
    expertOnly: false,
  },
  {
    id: 'cpu_info',
    name: 'Informaci√≥n de CPU',
    category: 'information',
    riskLevel: 'safe',
    description: 'Muestra informaci√≥n del procesador',
    command: 'cat /proc/cpuinfo',
    requiresConfirmation: false,
    expertOnly: false,
  },
  {
    id: 'serial_number',
    name: 'N√∫mero de Serie',
    category: 'information',
    riskLevel: 'safe',
    description: 'Obtiene el n√∫mero de serie de la unidad',
    command: 'cat /net/rcc/mnt/efs-persist/serialnumber',
    requiresConfirmation: false,
    expertOnly: false,
  },
  {
    id: 'hardware_version',
    name: 'Versi√≥n de Hardware',
    category: 'information',
    riskLevel: 'safe',
    description: 'Muestra la versi√≥n de hardware de la unidad',
    command: 'cat /net/rcc/mnt/efs-persist/HWVersion',
    requiresConfirmation: false,
    expertOnly: false,
  },

  // ========== DIAGNOSTIC COMMANDS ==========
  {
    id: 'memory_info',
    name: 'Uso de Memoria',
    category: 'diagnostic',
    riskLevel: 'safe',
    description: 'Muestra el uso actual de memoria',
    command: 'free',
    requiresConfirmation: false,
    expertOnly: false,
  },
  {
    id: 'mounted_devices',
    name: 'Dispositivos Montados',
    category: 'diagnostic',
    riskLevel: 'safe',
    description: 'Lista todos los dispositivos y puntos de montaje',
    command: 'mount',
    requiresConfirmation: false,
    expertOnly: false,
  },
  {
    id: 'network_interfaces',
    name: 'Interfaces de Red',
    category: 'diagnostic',
    riskLevel: 'safe',
    description: 'Muestra configuraci√≥n de interfaces de red',
    command: 'ifconfig',
    requiresConfirmation: false,
    expertOnly: false,
  },
  {
    id: 'running_processes',
    name: 'Procesos en Ejecuci√≥n',
    category: 'diagnostic',
    riskLevel: 'safe',
    description: 'Lista todos los procesos activos',
    command: 'ps aux',
    requiresConfirmation: false,
    expertOnly: false,
  },
  {
    id: 'disk_usage',
    name: 'Uso de Disco',
    category: 'diagnostic',
    riskLevel: 'safe',
    description: 'Muestra el uso de espacio en disco',
    command: 'df -h',
    requiresConfirmation: false,
    expertOnly: false,
  },
  {
    id: 'temperature',
    name: 'Temperatura del Sistema',
    category: 'diagnostic',
    riskLevel: 'safe',
    description: 'Muestra la temperatura actual del sistema',
    command: 'cat /sys/class/thermal/thermal_zone0/temp',
    requiresConfirmation: false,
    expertOnly: false,
  },

  // ========== ADAPTATION COMMANDS ==========
  {
    id: 'list_adaptations',
    name: 'Listar Adaptaciones',
    category: 'adaptation',
    riskLevel: 'safe',
    description: 'Lista todas las adaptaciones disponibles',
    command: 'ls -la /net/rcc/mnt/efs-persist/Adaptation/',
    requiresConfirmation: false,
    expertOnly: false,
  },
  {
    id: 'backup_adaptations',
    name: 'Backup de Adaptaciones',
    category: 'adaptation',
    riskLevel: 'moderate',
    description: 'Crea un backup de las adaptaciones actuales',
    command: 'cp -r /net/rcc/mnt/efs-persist/Adaptation /net/rcc/mnt/efs-persist/Adaptation_backup_$(date +%Y%m%d)',
    requiresConfirmation: true,
    expertOnly: false,
    notes: 'Recomendado antes de modificar adaptaciones',
  },
  {
    id: 'enable_green_menu',
    name: 'Habilitar Men√∫ Verde',
    category: 'adaptation',
    riskLevel: 'moderate',
    description: 'Activa el men√∫ de ingenier√≠a (Green Menu)',
    command: 'echo "1" > /net/rcc/mnt/efs-persist/Adaptation/GreenMenu',
    requiresConfirmation: true,
    expertOnly: true,
    notes: 'Permite acceso a funciones de diagn√≥stico avanzadas',
  },
  {
    id: 'disable_green_menu',
    name: 'Deshabilitar Men√∫ Verde',
    category: 'adaptation',
    riskLevel: 'moderate',
    description: 'Desactiva el men√∫ de ingenier√≠a (Green Menu)',
    command: 'echo "0" > /net/rcc/mnt/efs-persist/Adaptation/GreenMenu',
    requiresConfirmation: true,
    expertOnly: true,
  },
  {
    id: 'enable_video_in_motion',
    name: 'Video en Movimiento',
    category: 'adaptation',
    riskLevel: 'high',
    description: 'Permite reproducir video mientras el veh√≠culo est√° en movimiento',
    command: 'echo "1" > /net/rcc/mnt/efs-persist/Adaptation/VideoInMotion',
    requiresConfirmation: true,
    expertOnly: true,
    notes: '‚ö†Ô∏è ADVERTENCIA: Puede ser ilegal en tu jurisdicci√≥n',
  },
  {
    id: 'enable_camera_guidelines',
    name: 'L√≠neas Gu√≠a de C√°mara',
    category: 'adaptation',
    riskLevel: 'moderate',
    description: 'Activa las l√≠neas gu√≠a en la c√°mara de reversa',
    command: 'echo "1" > /net/rcc/mnt/efs-persist/Adaptation/CameraGuidelines',
    requiresConfirmation: true,
    expertOnly: false,
  },

  // ========== SKIN COMMANDS ==========
  {
    id: 'list_skins',
    name: 'Listar Skins Disponibles',
    category: 'skin',
    riskLevel: 'safe',
    description: 'Lista todos los skins instalados',
    command: 'ls -la /net/rcc/mnt/efs-system/etc/skins/',
    requiresConfirmation: false,
    expertOnly: false,
  },
  {
    id: 'current_skin',
    name: 'Skin Actual',
    category: 'skin',
    riskLevel: 'safe',
    description: 'Muestra el skin actualmente activo',
    command: 'cat /net/rcc/mnt/efs-persist/skin.cfg',
    requiresConfirmation: false,
    expertOnly: false,
  },
  {
    id: 'backup_skin',
    name: 'Backup de Skin',
    category: 'skin',
    riskLevel: 'moderate',
    description: 'Crea un backup del skin actual',
    command: 'cp /net/rcc/mnt/efs-persist/skin.cfg /net/rcc/mnt/efs-persist/skin.cfg.backup',
    requiresConfirmation: true,
    expertOnly: false,
  },
  {
    id: 'set_skin_default',
    name: 'Restaurar Skin por Defecto',
    category: 'skin',
    riskLevel: 'moderate',
    description: 'Restaura el skin de f√°brica',
    command: 'echo "default" > /net/rcc/mnt/efs-persist/skin.cfg',
    requiresConfirmation: true,
    expertOnly: false,
  },

  // ========== NETWORK COMMANDS ==========
  {
    id: 'wifi_status',
    name: 'Estado de WiFi',
    category: 'network',
    riskLevel: 'safe',
    description: 'Muestra el estado de la conexi√≥n WiFi',
    command: 'wpa_cli status',
    requiresConfirmation: false,
    expertOnly: false,
  },
  {
    id: 'network_routes',
    name: 'Rutas de Red',
    category: 'network',
    riskLevel: 'safe',
    description: 'Muestra la tabla de rutas de red',
    command: 'route -n',
    requiresConfirmation: false,
    expertOnly: false,
  },
  {
    id: 'ping_gateway',
    name: 'Ping a Gateway',
    category: 'network',
    riskLevel: 'safe',
    description: 'Prueba conectividad con el gateway',
    command: 'ping -c 4 192.168.1.1',
    requiresConfirmation: false,
    expertOnly: false,
  },
  {
    id: 'dns_servers',
    name: 'Servidores DNS',
    category: 'network',
    riskLevel: 'safe',
    description: 'Muestra los servidores DNS configurados',
    command: 'cat /etc/resolv.conf',
    requiresConfirmation: false,
    expertOnly: false,
  },

  // ========== FILESYSTEM COMMANDS ==========
  {
    id: 'list_root',
    name: 'Listar Directorio Ra√≠z',
    category: 'filesystem',
    riskLevel: 'safe',
    description: 'Lista el contenido del directorio ra√≠z',
    command: 'ls -la /',
    requiresConfirmation: false,
    expertOnly: false,
  },
  {
    id: 'list_persist',
    name: 'Listar Partici√≥n Persist',
    category: 'filesystem',
    riskLevel: 'safe',
    description: 'Lista archivos en la partici√≥n de persistencia',
    command: 'ls -la /net/rcc/mnt/efs-persist/',
    requiresConfirmation: false,
    expertOnly: false,
  },
  {
    id: 'list_system',
    name: 'Listar Partici√≥n System',
    category: 'filesystem',
    riskLevel: 'safe',
    description: 'Lista archivos en la partici√≥n del sistema',
    command: 'ls -la /net/rcc/mnt/efs-system/',
    requiresConfirmation: false,
    expertOnly: false,
  },
  {
    id: 'disk_partitions',
    name: 'Particiones de Disco',
    category: 'filesystem',
    riskLevel: 'safe',
    description: 'Muestra informaci√≥n de particiones',
    command: 'fdisk -l',
    requiresConfirmation: false,
    expertOnly: true,
  },

  // ========== ADVANCED COMMANDS ==========
  {
    id: 'reboot_system',
    name: 'Reiniciar Sistema',
    category: 'advanced',
    riskLevel: 'high',
    description: 'Reinicia la unidad MIB2',
    command: 'reboot',
    requiresConfirmation: true,
    expertOnly: true,
    notes: 'El sistema se reiniciar√° inmediatamente',
  },
  {
    id: 'kill_process',
    name: 'Terminar Proceso',
    category: 'advanced',
    riskLevel: 'high',
    description: 'Termina un proceso espec√≠fico (requiere PID)',
    command: 'kill -9 <PID>',
    requiresConfirmation: true,
    expertOnly: true,
    notes: 'Reemplaza <PID> con el ID del proceso',
  },
  {
    id: 'clear_logs',
    name: 'Limpiar Logs del Sistema',
    category: 'advanced',
    riskLevel: 'moderate',
    description: 'Elimina los archivos de log del sistema',
    command: 'rm -f /var/log/*.log',
    requiresConfirmation: true,
    expertOnly: true,
  },
  {
    id: 'factory_reset_adaptations',
    name: 'Reset de F√°brica (Adaptaciones)',
    category: 'advanced',
    riskLevel: 'critical',
    description: 'Restaura todas las adaptaciones a valores de f√°brica',
    command: 'rm -rf /net/rcc/mnt/efs-persist/Adaptation/* && reboot',
    requiresConfirmation: true,
    expertOnly: true,
    notes: '‚ö†Ô∏è CR√çTICO: Esto eliminar√° todas las adaptaciones personalizadas',
  },
];

/**
 * Get commands by category
 */
export function getCommandsByCategory(category: CommandCategory): MIB2Command[] {
  return MIB2_COMMANDS.filter(cmd => cmd.category === category);
}

/**
 * Get commands by risk level
 */
export function getCommandsByRisk(riskLevel: RiskLevel): MIB2Command[] {
  return MIB2_COMMANDS.filter(cmd => cmd.riskLevel === riskLevel);
}

/**
 * Get expert-only commands
 */
export function getExpertCommands(): MIB2Command[] {
  return MIB2_COMMANDS.filter(cmd => cmd.expertOnly);
}

/**
 * Get safe commands (non-expert)
 */
export function getSafeCommands(): MIB2Command[] {
  return MIB2_COMMANDS.filter(cmd => !cmd.expertOnly);
}

/**
 * Get command by ID
 */
export function getCommandById(id: string): MIB2Command | undefined {
  return MIB2_COMMANDS.find(cmd => cmd.id === id);
}

/**
 * Get risk level color
 */
export function getRiskLevelColor(riskLevel: RiskLevel): string {
  switch (riskLevel) {
    case 'safe':
      return 'success';
    case 'moderate':
      return 'warning';
    case 'high':
      return 'error';
    case 'critical':
      return 'error';
    default:
      return 'muted';
  }
}

/**
 * Get risk level label
 */
export function getRiskLevelLabel(riskLevel: RiskLevel): string {
  switch (riskLevel) {
    case 'safe':
      return 'Seguro';
    case 'moderate':
      return 'Moderado';
    case 'high':
      return 'Alto';
    case 'critical':
      return 'Cr√≠tico';
    default:
      return 'Desconocido';
  }
}

================================================================================
FILE: lib/network-scanner.ts
================================================================================

/**
 * Network Scanner for MIB2 Discovery
 * Escanea red local usando TCP directo (sin backend)
 */

import TcpSocket from 'react-native-tcp-socket';
import AsyncStorage from '@react-native-async-storage/async-storage';

export interface ScanResult {
  host: string;
  port: number;
  responding: boolean;
  responseTime?: number;
  deviceInfo?: string;
  isMIB2?: boolean;
}

export interface ScanProgress {
  current: number;
  total: number;
  percentage: number;
  currentHost: string;
}

/**
 * Escanear una IP espec√≠fica en busca de puerto Telnet abierto
 */
async function scanIP(ip: string, port: number = 23, timeout: number = 500): Promise<ScanResult> {
  return new Promise((resolve) => {
    const startTime = Date.now();
    let resolved = false;

    const socket = TcpSocket.createConnection(
      {
        host: ip,
        port,
      },
      () => {
        // Conexi√≥n exitosa
        if (!resolved) {
          resolved = true;
          const responseTime = Date.now() - startTime;
          socket.destroy();
          resolve({
            host: ip,
            port,
            responding: true,
            responseTime,
          });
        }
      }
    );

    socket.on('error', () => {
      if (!resolved) {
        resolved = true;
        socket.destroy();
        resolve({
          host: ip,
          port,
          responding: false,
          responseTime: Date.now() - startTime,
        });
      }
    });

    socket.on('timeout', () => {
      if (!resolved) {
        resolved = true;
        socket.destroy();
        resolve({
          host: ip,
          port,
          responding: false,
          responseTime: timeout,
        });
      }
    });

    // Timeout de seguridad
    setTimeout(() => {
      if (!resolved) {
        resolved = true;
        socket.destroy();
        resolve({
          host: ip,
          port,
          responding: false,
          responseTime: timeout,
        });
      }
    }, timeout + 100);
  });
}

/**
 * Scan a range of IP addresses for MIB2 units
 */
export async function scanNetwork(
  baseIP: string = '192.168.1',
  startRange: number = 1,
  endRange: number = 255,
  port: number = 23,
  onProgress?: (progress: ScanProgress) => void
): Promise<ScanResult[]> {
  const results: ScanResult[] = [];
  const total = endRange - startRange + 1;

  // Escanear en lotes de 10 para no saturar la red
  const batchSize = 10;
  for (let i = startRange; i <= endRange; i += batchSize) {
    const batchEnd = Math.min(i + batchSize - 1, endRange);
    const batchPromises: Promise<ScanResult>[] = [];

    for (let j = i; j <= batchEnd; j++) {
      const host = `${baseIP}.${j}`;
      batchPromises.push(scanIP(host, port, 500));
    }

    const batchResults = await Promise.all(batchPromises);
    
    // Agregar solo IPs que responden
    for (const result of batchResults) {
      if (result.responding) {
        results.push(result);
      }
    }

    if (onProgress) {
      const current = Math.min(batchEnd, endRange) - startRange + 1;
      onProgress({
        current,
        total,
        percentage: Math.round((current / total) * 100),
        currentHost: `${baseIP}.${batchEnd}`,
      });
    }
  }

  return results;
}

/**
 * Quick scan for common MIB2 IP addresses
 */
export async function quickScan(
  onProgress?: (progress: ScanProgress) => void
): Promise<ScanResult[]> {
  // Common IP addresses for MIB2 units
  const commonIPs = [
    '192.168.1.4',
    '192.168.0.4',
    '192.168.1.1',
    '192.168.0.1',
    '10.0.0.4',
    '172.16.0.4',
  ];

  const results: ScanResult[] = [];
  const total = commonIPs.length;

  for (let i = 0; i < commonIPs.length; i++) {
    const host = commonIPs[i];
    
    if (onProgress) {
      onProgress({
        current: i + 1,
        total,
        percentage: Math.round(((i + 1) / total) * 100),
        currentHost: host,
      });
    }

    const result = await scanIP(host, 23, 1000);
    if (result.responding) {
      results.push(result);
    }
  }

  return results;
}

/**
 * Verificar si una IP es una unidad MIB2
 * Intenta conectar y buscar banner caracter√≠stico
 */
export async function verifyMIB2(ip: string, timeout: number = 3000): Promise<boolean> {
  return new Promise((resolve) => {
    let resolved = false;
    let buffer = '';

    const socket = TcpSocket.createConnection(
      {
        host: ip,
        port: 23,
      },
      () => {
        // Conexi√≥n exitosa, esperar banner
      }
    );

    socket.on('data', (data) => {
      buffer += data.toString();
      
      // Buscar indicadores de QNX/MIB2
      if (
        buffer.includes('QNX') ||
        buffer.includes('login:') ||
        buffer.includes('MIB') ||
        buffer.includes('rcc') ||
        buffer.includes('mmx')
      ) {
        if (!resolved) {
          resolved = true;
          socket.destroy();
          resolve(true);
        }
      }
    });

    socket.on('error', () => {
      if (!resolved) {
        resolved = true;
        socket.destroy();
        resolve(false);
      }
    });

    socket.on('timeout', () => {
      if (!resolved) {
        resolved = true;
        socket.destroy();
        resolve(false);
      }
    });

    // Timeout de seguridad
    setTimeout(() => {
      if (!resolved) {
        resolved = true;
        socket.destroy();
        resolve(false);
      }
    }, timeout + 100);
  });
}

/**
 * Parse subnet from IP address
 */
export function parseSubnet(ip: string): string {
  const parts = ip.split('.');
  if (parts.length !== 4) {
    return '192.168.1';
  }
  return `${parts[0]}.${parts[1]}.${parts[2]}`;
}

/**
 * Validate IP address format
 */
export function isValidIP(ip: string): boolean {
  const ipRegex = /^(\d{1,3}\.){3}\d{1,3}$/;
  if (!ipRegex.test(ip)) {
    return false;
  }

  const parts = ip.split('.').map(Number);
  return parts.every(part => part >= 0 && part <= 255);
}

/**
 * Obtener IP guardada de AsyncStorage
 */
export async function getSavedMIB2IP(): Promise<string | null> {
  try {
    return await AsyncStorage.getItem('mib2_ip');
  } catch {
    return null;
  }
}

/**
 * Guardar IP de MIB2 en AsyncStorage
 */
export async function saveMIB2IP(ip: string): Promise<void> {
  try {
    await AsyncStorage.setItem('mib2_ip', ip);
  } catch (error) {
    console.error('Error saving MIB2 IP:', error);
  }
}

================================================================================
FILE: lib/notification-service.ts
================================================================================

/**
 * Servicio de Notificaciones Push
 * Maneja notificaciones locales para operaciones de larga duraci√≥n
 */

import * as Notifications from 'expo-notifications';
import { Platform } from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';

const NOTIFICATIONS_ENABLED_KEY = '@mib2_notifications_enabled';

// Configurar comportamiento de notificaciones cuando la app est√° en primer plano
Notifications.setNotificationHandler({
  handleNotification: async () => ({
    shouldShowAlert: true,
    shouldPlaySound: true,
    shouldSetBadge: false,
    shouldShowBanner: true,
    shouldShowList: true,
  }),
});

export type NotificationType = 'spoofing' | 'recovery' | 'restore' | 'general';

export interface NotificationOptions {
  title: string;
  body: string;
  data?: Record<string, any>;
  type?: NotificationType;
}

export class NotificationService {
  private static permissionGranted: boolean = false;

  /**
   * Solicitar permisos de notificaciones
   */
  static async requestPermissions(): Promise<boolean> {
    if (Platform.OS === 'web') {
      console.log('[Notifications] Web platform does not support push notifications');
      return false;
    }

    try {
      const { status: existingStatus } = await Notifications.getPermissionsAsync();
      let finalStatus = existingStatus;

      if (existingStatus !== 'granted') {
        const { status } = await Notifications.requestPermissionsAsync();
        finalStatus = status;
      }

      this.permissionGranted = finalStatus === 'granted';

      if (!this.permissionGranted) {
        console.log('[Notifications] Permission not granted');
        return false;
      }

      // Configurar canal de notificaciones en Android
      if (Platform.OS === 'android') {
        await Notifications.setNotificationChannelAsync('default', {
          name: 'MIB2 Operations',
          importance: Notifications.AndroidImportance.HIGH,
          vibrationPattern: [0, 250, 250, 250],
          lightColor: '#0a7ea4',
          sound: 'default',
        });
      }

      console.log('[Notifications] Permissions granted');
      return true;
    } catch (error) {
      console.error('[Notifications] Error requesting permissions:', error);
      return false;
    }
  }

  /**
   * Verificar si las notificaciones est√°n habilitadas
   */
  static async areNotificationsEnabled(): Promise<boolean> {
    try {
      const enabled = await AsyncStorage.getItem(NOTIFICATIONS_ENABLED_KEY);
      return enabled === 'true';
    } catch {
      return true; // Por defecto habilitadas
    }
  }

  /**
   * Habilitar/deshabilitar notificaciones
   */
  static async setNotificationsEnabled(enabled: boolean): Promise<void> {
    try {
      await AsyncStorage.setItem(NOTIFICATIONS_ENABLED_KEY, enabled.toString());
    } catch (error) {
      console.error('[Notifications] Error saving preference:', error);
    }
  }

  /**
   * Enviar notificaci√≥n local inmediata
   */
  static async sendNotification(options: NotificationOptions): Promise<void> {
    if (Platform.OS === 'web') {
      console.log('[Notifications] Skipping notification on web:', options.title);
      return;
    }

    const enabled = await this.areNotificationsEnabled();
    if (!enabled) {
      console.log('[Notifications] Notifications disabled by user');
      return;
    }

    if (!this.permissionGranted) {
      const granted = await this.requestPermissions();
      if (!granted) {
        return;
      }
    }

    try {
      await Notifications.scheduleNotificationAsync({
        content: {
          title: options.title,
          body: options.body,
          data: {
            ...options.data,
            type: options.type || 'general',
          },
          sound: 'default',
        },
        trigger: null, // Inmediata
      });

      console.log('[Notifications] Notification sent:', options.title);
    } catch (error) {
      console.error('[Notifications] Error sending notification:', error);
    }
  }

  /**
   * Notificaci√≥n de operaci√≥n de spoofing completada
   */
  static async notifySpoofingComplete(success: boolean, deviceName?: string): Promise<void> {
    const title = success ? '‚úÖ Spoofing Completed' : '‚ùå Spoofing Failed';
    const body = success
      ? `The adapter ${deviceName || 'device'} has been successfully spoofed.`
      : `Spoofing operation failed. Check the logs for details.`;

    await this.sendNotification({
      title,
      body,
      type: 'spoofing',
      data: {
        success,
        deviceName,
        timestamp: new Date().toISOString(),
      },
    });
  }

  /**
   * Notificaci√≥n de operaci√≥n de recuperaci√≥n completada
   */
  static async notifyRecoveryComplete(success: boolean, method?: string): Promise<void> {
    const title = success ? '‚úÖ Recovery Completed' : '‚ùå Recovery Failed';
    const body = success
      ? `Device recovery using ${method || 'unknown method'} was successful.`
      : `Recovery operation failed. The device may require manual intervention.`;

    await this.sendNotification({
      title,
      body,
      type: 'recovery',
      data: {
        success,
        method,
        timestamp: new Date().toISOString(),
      },
    });
  }

  /**
   * Notificaci√≥n de restauraci√≥n de backup completada
   */
  static async notifyRestoreComplete(success: boolean, backupName?: string): Promise<void> {
    const title = success ? '‚úÖ Restore Completed' : '‚ùå Restore Failed';
    const body = success
      ? `EEPROM backup "${backupName || 'Unknown'}" has been restored successfully.`
      : `Failed to restore backup. The device may be in an inconsistent state.`;

    await this.sendNotification({
      title,
      body,
      type: 'restore',
      data: {
        success,
        backupName,
        timestamp: new Date().toISOString(),
      },
    });
  }

  /**
   * Notificaci√≥n de progreso de operaci√≥n larga
   */
  static async notifyOperationProgress(
    operationType: string,
    progress: number,
    message: string
  ): Promise<void> {
    // Solo notificar en hitos importantes (25%, 50%, 75%)
    if (progress !== 25 && progress !== 50 && progress !== 75) {
      return;
    }

    await this.sendNotification({
      title: `${operationType} - ${progress}%`,
      body: message,
      type: 'general',
      data: {
        operationType,
        progress,
        timestamp: new Date().toISOString(),
      },
    });
  }

  /**
   * Cancelar todas las notificaciones pendientes
   */
  static async cancelAllNotifications(): Promise<void> {
    try {
      await Notifications.cancelAllScheduledNotificationsAsync();
      console.log('[Notifications] All notifications cancelled');
    } catch (error) {
      console.error('[Notifications] Error cancelling notifications:', error);
    }
  }

  /**
   * Obtener badge count actual
   */
  static async getBadgeCount(): Promise<number> {
    try {
      return await Notifications.getBadgeCountAsync();
    } catch {
      return 0;
    }
  }

  /**
   * Establecer badge count
   */
  static async setBadgeCount(count: number): Promise<void> {
    try {
      await Notifications.setBadgeCountAsync(count);
    } catch (error) {
      console.error('[Notifications] Error setting badge count:', error);
    }
  }

  /**
   * Limpiar badge
   */
  static async clearBadge(): Promise<void> {
    await this.setBadgeCount(0);
  }
}

================================================================================
FILE: lib/operation-history.ts
================================================================================

/**
 * Gesti√≥n de Historial de Operaciones
 * Registra todas las operaciones de spoofing y recuperaci√≥n
 */

export interface OperationRecord {
  operationType: 'spoofing' | 'recovery' | 'restore';
  deviceVid: string;
  devicePid: string;
  deviceChipset?: string;
  result: 'success' | 'failed';
  dryRun?: boolean;
  executionTimeMs?: number;
  errorMessage?: string;
  backupId?: string;
  metadata?: Record<string, any>;
}

export interface OperationStats {
  totalOperations: number;
  successfulOperations: number;
  failedOperations: number;
  dryRunOperations: number;
  averageExecutionTime: number;
  operationsByType: {
    spoofing: number;
    recovery: number;
    restore: number;
  };
}

/**
 * Gestor de Historial de Operaciones
 */
export class OperationHistoryManager {
  /**
   * Registrar una nueva operaci√≥n
   */
  static async recordOperation(operation: OperationRecord): Promise<boolean> {
    try {
      const response = await fetch('/api/operations/record', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(operation),
      });

      if (!response.ok) {
        console.error('[OperationHistory] Failed to record operation:', response.statusText);
        return false;
      }

      console.log(`[OperationHistory] Operation recorded: ${operation.operationType} - ${operation.result}`);
      return true;
    } catch (error) {
      console.error('[OperationHistory] Error recording operation:', error);
      return false;
    }
  }

  /**
   * Obtener estad√≠sticas de operaciones
   */
  static async getStatistics(): Promise<OperationStats | null> {
    try {
      const response = await fetch('/api/operations/stats');

      if (!response.ok) {
        console.error('[OperationHistory] Failed to fetch statistics:', response.statusText);
        return null;
      }

      const stats = await response.json();
      return stats;
    } catch (error) {
      console.error('[OperationHistory] Error fetching statistics:', error);
      return null;
    }
  }

  /**
   * Obtener historial reciente
   */
  static async getRecentOperations(limit: number = 10): Promise<any[]> {
    try {
      const response = await fetch(`/api/operations/recent?limit=${limit}`);

      if (!response.ok) {
        console.error('[OperationHistory] Failed to fetch recent operations:', response.statusText);
        return [];
      }

      const operations = await response.json();
      return operations;
    } catch (error) {
      console.error('[OperationHistory] Error fetching recent operations:', error);
      return [];
    }
  }

  /**
   * Obtener historial filtrado por tipo
   */
  static async getOperationsByType(type: 'spoofing' | 'recovery' | 'restore', limit: number = 20): Promise<any[]> {
    try {
      const response = await fetch(`/api/operations/by-type?type=${type}&limit=${limit}`);

      if (!response.ok) {
        console.error('[OperationHistory] Failed to fetch operations by type:', response.statusText);
        return [];
      }

      const operations = await response.json();
      return operations;
    } catch (error) {
      console.error('[OperationHistory] Error fetching operations by type:', error);
      return [];
    }
  }

  /**
   * Obtener historial por dispositivo
   */
  static async getOperationsByDevice(vid: string, pid: string): Promise<any[]> {
    try {
      const response = await fetch(`/api/operations/by-device?vid=${vid}&pid=${pid}`);

      if (!response.ok) {
        console.error('[OperationHistory] Failed to fetch operations by device:', response.statusText);
        return [];
      }

      const operations = await response.json();
      return operations;
    } catch (error) {
      console.error('[OperationHistory] Error fetching operations by device:', error);
      return [];
    }
  }

  /**
   * Limpiar historial antiguo (mantener solo √∫ltimos N d√≠as)
   */
  static async cleanOldHistory(daysToKeep: number = 30): Promise<number> {
    try {
      const response = await fetch('/api/operations/clean', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ daysToKeep }),
      });

      if (!response.ok) {
        console.error('[OperationHistory] Failed to clean old history:', response.statusText);
        return 0;
      }

      const result = await response.json();
      return result.deletedCount || 0;
    } catch (error) {
      console.error('[OperationHistory] Error cleaning old history:', error);
      return 0;
    }
  }
}

================================================================================
FILE: lib/profiles-provider.tsx
================================================================================

/**
 * Profiles Provider
 * 
 * Manages multiple configuration profiles for different MIB2 units
 */

import React, { createContext, useContext, useState, useEffect } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';

export interface ConnectionProfile {
  id: string;
  name: string;
  host: string;
  port: number;
  username: string;
  password: string;
  description?: string;
  color?: string;
  createdAt: number;
  lastUsed?: number;
}

interface ProfilesContextType {
  profiles: ConnectionProfile[];
  activeProfile: ConnectionProfile | null;
  createProfile: (profile: Omit<ConnectionProfile, 'id' | 'createdAt'>) => Promise<void>;
  updateProfile: (id: string, updates: Partial<ConnectionProfile>) => Promise<void>;
  deleteProfile: (id: string) => Promise<void>;
  setActiveProfile: (id: string) => Promise<void>;
  getProfile: (id: string) => ConnectionProfile | undefined;
  duplicateProfile: (id: string) => Promise<void>;
}

const ProfilesContext = createContext<ProfilesContextType | undefined>(undefined);

const STORAGE_KEY = '@mib2_profiles';
const ACTIVE_PROFILE_KEY = '@mib2_active_profile';

const DEFAULT_PROFILE: Omit<ConnectionProfile, 'id' | 'createdAt'> = {
  name: 'MIB2 Principal',
  host: '192.168.1.4',
  port: 23,
  username: 'root',
  password: 'root',
  description: 'Configuraci√≥n por defecto',
  color: '#0066CC',
};

function generateId(): string {
  return `profile_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

export function ProfilesProvider({ children }: { children: React.ReactNode }) {
  const [profiles, setProfiles] = useState<ConnectionProfile[]>([]);
  const [activeProfile, setActiveProfileState] = useState<ConnectionProfile | null>(null);

  // Load profiles on mount
  useEffect(() => {
    loadProfiles();
  }, []);

  const loadProfiles = async () => {
    try {
      const [profilesData, activeProfileId] = await Promise.all([
        AsyncStorage.getItem(STORAGE_KEY),
        AsyncStorage.getItem(ACTIVE_PROFILE_KEY),
      ]);

      let loadedProfiles: ConnectionProfile[] = [];

      if (profilesData) {
        loadedProfiles = JSON.parse(profilesData);
      } else {
        // Create default profile if none exist
        const defaultProfile: ConnectionProfile = {
          ...DEFAULT_PROFILE,
          id: generateId(),
          createdAt: Date.now(),
        };
        loadedProfiles = [defaultProfile];
        await AsyncStorage.setItem(STORAGE_KEY, JSON.stringify(loadedProfiles));
      }

      setProfiles(loadedProfiles);

      // Set active profile
      if (activeProfileId) {
        const active = loadedProfiles.find(p => p.id === activeProfileId);
        if (active) {
          setActiveProfileState(active);
        } else {
          setActiveProfileState(loadedProfiles[0]);
        }
      } else {
        setActiveProfileState(loadedProfiles[0]);
      }
    } catch (error) {
      console.error('Error loading profiles:', error);
    }
  };

  const saveProfiles = async (newProfiles: ConnectionProfile[]) => {
    try {
      await AsyncStorage.setItem(STORAGE_KEY, JSON.stringify(newProfiles));
      setProfiles(newProfiles);
    } catch (error) {
      console.error('Error saving profiles:', error);
      throw error;
    }
  };

  const createProfile = async (profileData: Omit<ConnectionProfile, 'id' | 'createdAt'>) => {
    const newProfile: ConnectionProfile = {
      ...profileData,
      id: generateId(),
      createdAt: Date.now(),
    };

    const updatedProfiles = [...profiles, newProfile];
    await saveProfiles(updatedProfiles);
  };

  const updateProfile = async (id: string, updates: Partial<ConnectionProfile>) => {
    const updatedProfiles = profiles.map(profile =>
      profile.id === id ? { ...profile, ...updates } : profile
    );

    await saveProfiles(updatedProfiles);

    // Update active profile if it was updated
    if (activeProfile?.id === id) {
      const updated = updatedProfiles.find(p => p.id === id);
      if (updated) {
        setActiveProfileState(updated);
      }
    }
  };

  const deleteProfile = async (id: string) => {
    if (profiles.length === 1) {
      throw new Error('No puedes eliminar el √∫nico perfil');
    }

    const updatedProfiles = profiles.filter(profile => profile.id !== id);
    await saveProfiles(updatedProfiles);

    // If deleted profile was active, switch to first profile
    if (activeProfile?.id === id) {
      await setActiveProfile(updatedProfiles[0].id);
    }
  };

  const setActiveProfile = async (id: string) => {
    const profile = profiles.find(p => p.id === id);
    if (!profile) {
      throw new Error('Perfil no encontrado');
    }

    // Update last used timestamp
    await updateProfile(id, { lastUsed: Date.now() });

    await AsyncStorage.setItem(ACTIVE_PROFILE_KEY, id);
    setActiveProfileState(profile);
  };

  const getProfile = (id: string): ConnectionProfile | undefined => {
    return profiles.find(p => p.id === id);
  };

  const duplicateProfile = async (id: string) => {
    const profile = getProfile(id);
    if (!profile) {
      throw new Error('Perfil no encontrado');
    }

    const duplicated: Omit<ConnectionProfile, 'id' | 'createdAt'> = {
      ...profile,
      name: `${profile.name} (Copia)`,
    };

    await createProfile(duplicated);
  };

  const value: ProfilesContextType = {
    profiles,
    activeProfile,
    createProfile,
    updateProfile,
    deleteProfile,
    setActiveProfile,
    getProfile,
    duplicateProfile,
  };

  return (
    <ProfilesContext.Provider value={value}>
      {children}
    </ProfilesContext.Provider>
  );
}

export function useProfiles(): ProfilesContextType {
  const context = useContext(ProfilesContext);
  if (context === undefined) {
    throw new Error('useProfiles must be used within ProfilesProvider');
  }
  return context;
}

================================================================================
FILE: lib/profiles-service.ts
================================================================================

import AsyncStorage from '@react-native-async-storage/async-storage';
import { usbService } from './usb-service';
import { backupService } from './backup-service';
import type { UsbDevice } from './usb-service';

const CUSTOM_PROFILES_KEY = '@mib2_custom_profiles';
const PREDEFINED_PROFILES_CACHE_KEY = '@mib2_predefined_profiles_cache';
const CACHE_METADATA_KEY = '@mib2_cache_metadata';

export interface CacheMetadata {
  lastUpdated: number;
  version: string;
  profileCount: number;
}

export interface VIDPIDProfile {
  id: string;
  name: string;
  manufacturer: string;
  model: string;
  vendorId: number;
  productId: number;
  chipset: string;
  category: 'mib2_compatible' | 'common_adapters' | 'custom';
  compatible: boolean;
  notes: string;
  icon: string;
}

/**
 * Perfiles predefinidos de VID/PID
 */
const PREDEFINED_PROFILES: VIDPIDProfile[] = [
  // MIB2 Compatible (objetivo principal)
  {
    id: 'dlink_dub_e100',
    name: 'D-Link DUB-E100',
    manufacturer: 'D-Link',
    model: 'DUB-E100',
    vendorId: 0x2001,
    productId: 0x3C05,
    chipset: 'ASIX AX88772',
    category: 'mib2_compatible',
    compatible: true,
    notes: 'Adaptador 100% compatible con MIB2. Este es el VID/PID objetivo para spoofing.',
    icon: '‚úÖ',
  },
  {
    id: 'dlink_dub_e100_v2',
    name: 'D-Link DUB-E100 (v2)',
    manufacturer: 'D-Link',
    model: 'DUB-E100 Rev. B1',
    vendorId: 0x2001,
    productId: 0x1A02,
    chipset: 'ASIX AX88772A',
    category: 'mib2_compatible',
    compatible: true,
    notes: 'Versi√≥n alternativa del DUB-E100, tambi√©n compatible con MIB2.',
    icon: '‚úÖ',
  },
  
  // Adaptadores Comunes (fuentes de spoofing)
  {
    id: 'tplink_ue300',
    name: 'TP-Link UE300',
    manufacturer: 'TP-Link',
    model: 'UE300',
    vendorId: 0x2357,
    productId: 0x0601,
    chipset: 'Realtek RTL8153',
    category: 'common_adapters',
    compatible: false,
    notes: 'Adaptador Gigabit com√∫n. Requiere spoofing para MIB2.',
    icon: 'üîß',
  },
  {
    id: 'tplink_ue200',
    name: 'TP-Link UE200',
    manufacturer: 'TP-Link',
    model: 'UE200',
    vendorId: 0x2357,
    productId: 0x0602,
    chipset: 'Realtek RTL8152',
    category: 'common_adapters',
    compatible: false,
    notes: 'Adaptador Fast Ethernet de TP-Link. Requiere spoofing.',
    icon: 'üîß',
  },
  {
    id: 'tplink_wl_nwu331gca',
    name: 'TP-Link WL-NWU331GCA',
    manufacturer: 'TP-Link',
    model: 'WL-NWU331GCA',
    vendorId: 0x0B95,
    productId: 0x772B,
    chipset: 'ASIX AX88772B',
    category: 'common_adapters',
    compatible: false,
    notes: 'Adaptador ASIX com√∫n. Ideal para spoofing a D-Link DUB-E100.',
    icon: 'üîß',
  },
  {
    id: 'asix_ax88772',
    name: 'ASIX AX88772 Generic',
    manufacturer: 'ASIX',
    model: 'AX88772',
    vendorId: 0x0B95,
    productId: 0x7720,
    chipset: 'ASIX AX88772',
    category: 'common_adapters',
    compatible: false,
    notes: 'Chipset ASIX gen√©rico. Compatible con spoofing.',
    icon: 'üîß',
  },
  {
    id: 'asix_ax88772a',
    name: 'ASIX AX88772A Generic',
    manufacturer: 'ASIX',
    model: 'AX88772A',
    vendorId: 0x0B95,
    productId: 0x772A,
    chipset: 'ASIX AX88772A',
    category: 'common_adapters',
    compatible: false,
    notes: 'Chipset ASIX gen√©rico (versi√≥n A). Compatible con spoofing.',
    icon: 'üîß',
  },
  {
    id: 'realtek_rtl8153',
    name: 'Realtek RTL8153 Generic',
    manufacturer: 'Realtek',
    model: 'RTL8153',
    vendorId: 0x0BDA,
    productId: 0x8153,
    chipset: 'Realtek RTL8153',
    category: 'common_adapters',
    compatible: false,
    notes: 'Chipset Realtek Gigabit com√∫n. Requiere spoofing.',
    icon: 'üîß',
  },
  {
    id: 'realtek_rtl8152',
    name: 'Realtek RTL8152 Generic',
    manufacturer: 'Realtek',
    model: 'RTL8152',
    vendorId: 0x0BDA,
    productId: 0x8152,
    chipset: 'Realtek RTL8152',
    category: 'common_adapters',
    compatible: false,
    notes: 'Chipset Realtek Fast Ethernet. Requiere spoofing.',
    icon: 'üîß',
  },
  
  // Otros adaptadores conocidos
  {
    id: 'apple_usb_ethernet',
    name: 'Apple USB Ethernet',
    manufacturer: 'Apple',
    model: 'USB Ethernet Adapter',
    vendorId: 0x05AC,
    productId: 0x1402,
    chipset: 'ASIX AX88772',
    category: 'common_adapters',
    compatible: false,
    notes: 'Adaptador oficial de Apple. Usa chipset ASIX.',
    icon: 'üçé',
  },
  {
    id: 'belkin_usb_ethernet',
    name: 'Belkin USB-C to Ethernet',
    manufacturer: 'Belkin',
    model: 'USB-C to Gigabit Ethernet',
    vendorId: 0x050D,
    productId: 0x0121,
    chipset: 'Realtek RTL8153',
    category: 'common_adapters',
    compatible: false,
    notes: 'Adaptador Belkin USB-C. Chipset Realtek NO compatible con spoofing en Android.',
    icon: 'üîß',
  },
  {
    id: 'realtek_rtl8156',
    name: 'Realtek RTL8156 Generic',
    manufacturer: 'Realtek',
    model: 'RTL8156',
    vendorId: 0x0BDA,
    productId: 0x8156,
    chipset: 'Realtek RTL8156',
    category: 'common_adapters',
    compatible: false,
    notes: 'Chipset Realtek 2.5G. NO compatible con spoofing en Android (requiere drivers kernel).',
    icon: 'üîß',
  },
  {
    id: 'asix_ax88178',
    name: 'ASIX AX88178 Generic',
    manufacturer: 'ASIX',
    model: 'AX88178',
    vendorId: 0x0B95,
    productId: 0x1780,
    chipset: 'ASIX AX88178',
    category: 'common_adapters',
    compatible: false,
    notes: 'Chipset ASIX Gigabit. Compatible con spoofing.',
    icon: 'üîß',
  },
  {
    id: 'asix_ax88179',
    name: 'ASIX AX88179 Generic',
    manufacturer: 'ASIX',
    model: 'AX88179',
    vendorId: 0x0B95,
    productId: 0x178A,
    chipset: 'ASIX AX88179',
    category: 'common_adapters',
    compatible: false,
    notes: 'Chipset ASIX Gigabit USB 3.0. Compatible con spoofing.',
    icon: 'üîß',
  },
  {
    id: 'microchip_lan9512',
    name: 'Microchip LAN9512/9514',
    manufacturer: 'Microchip',
    model: 'LAN9512/LAN9514',
    vendorId: 0x0424,
    productId: 0xEC00,
    chipset: 'Microchip LAN9512/9514',
    category: 'common_adapters',
    compatible: false,
    notes: 'Chipset Microchip com√∫n en Raspberry Pi. NO compatible con spoofing.',
    icon: 'üîß',
  },
  {
    id: 'microchip_lan7800',
    name: 'Microchip LAN7800',
    manufacturer: 'Microchip',
    model: 'LAN7800',
    vendorId: 0x0424,
    productId: 0x7800,
    chipset: 'Microchip LAN7800',
    category: 'common_adapters',
    compatible: false,
    notes: 'Chipset Microchip Gigabit USB 3.0. NO compatible con spoofing.',
    icon: 'üîß',
  },
  {
    id: 'davicom_dm9601',
    name: 'Davicom DM9601',
    manufacturer: 'Davicom',
    model: 'DM9601',
    vendorId: 0x0FE6,
    productId: 0x9700,
    chipset: 'Davicom DM9601',
    category: 'common_adapters',
    compatible: false,
    notes: 'Chipset Davicom econ√≥mico. NO compatible con spoofing.',
    icon: 'üîß',
  },
];

/**
 * Profiles Service - Gesti√≥n de perfiles VID/PID
 */
class ProfilesService {
  private cacheInitialized = false;

  /**
   * Inicializar cache de perfiles predefinidos
   */
  async initializeCache(): Promise<void> {
    if (this.cacheInitialized) return;
    
    try {
      // Guardar perfiles predefinidos en cache
      await AsyncStorage.setItem(PREDEFINED_PROFILES_CACHE_KEY, JSON.stringify(PREDEFINED_PROFILES));
      
      // Guardar metadata del cache
      const metadata: CacheMetadata = {
        lastUpdated: Date.now(),
        version: '1.0.0',
        profileCount: PREDEFINED_PROFILES.length,
      };
      await AsyncStorage.setItem(CACHE_METADATA_KEY, JSON.stringify(metadata));
      
      this.cacheInitialized = true;
      console.log(`[ProfilesService] Cache initialized with ${PREDEFINED_PROFILES.length} profiles`);
    } catch (error) {
      console.error('[ProfilesService] Error initializing cache:', error);
    }
  }

  /**
   * Obtener metadata del cache
   */
  async getCacheMetadata(): Promise<CacheMetadata | null> {
    try {
      const stored = await AsyncStorage.getItem(CACHE_METADATA_KEY);
      if (!stored) return null;
      return JSON.parse(stored) as CacheMetadata;
    } catch (error) {
      console.error('[ProfilesService] Error getting cache metadata:', error);
      return null;
    }
  }

  /**
   * Cargar perfiles predefinidos desde cache (modo offline)
   */
  async loadCachedPredefinedProfiles(): Promise<VIDPIDProfile[]> {
    try {
      const stored = await AsyncStorage.getItem(PREDEFINED_PROFILES_CACHE_KEY);
      if (!stored) {
        // Si no hay cache, inicializar y devolver predefinidos
        await this.initializeCache();
        return PREDEFINED_PROFILES;
      }
      return JSON.parse(stored) as VIDPIDProfile[];
    } catch (error) {
      console.error('[ProfilesService] Error loading cached profiles:', error);
      return PREDEFINED_PROFILES; // Fallback a predefinidos en memoria
    }
  }

  /**
   * Actualizar cache de perfiles predefinidos (refresh manual)
   */
  async refreshCache(): Promise<{ success: boolean; profileCount: number; timestamp: number }> {
    try {
      await AsyncStorage.setItem(PREDEFINED_PROFILES_CACHE_KEY, JSON.stringify(PREDEFINED_PROFILES));
      
      const metadata: CacheMetadata = {
        lastUpdated: Date.now(),
        version: '1.0.0',
        profileCount: PREDEFINED_PROFILES.length,
      };
      await AsyncStorage.setItem(CACHE_METADATA_KEY, JSON.stringify(metadata));
      
      console.log(`[ProfilesService] Cache refreshed with ${PREDEFINED_PROFILES.length} profiles`);
      return {
        success: true,
        profileCount: PREDEFINED_PROFILES.length,
        timestamp: metadata.lastUpdated,
      };
    } catch (error) {
      console.error('[ProfilesService] Error refreshing cache:', error);
      return { success: false, profileCount: 0, timestamp: 0 };
    }
  }

  /**
   * Verificar si el cache est√° disponible (modo offline)
   */
  async isCacheAvailable(): Promise<boolean> {
    try {
      const stored = await AsyncStorage.getItem(PREDEFINED_PROFILES_CACHE_KEY);
      return stored !== null;
    } catch {
      return false;
    }
  }

  /**
   * Cargar perfiles personalizados desde AsyncStorage
   */
  async loadCustomProfiles(): Promise<VIDPIDProfile[]> {
    try {
      const stored = await AsyncStorage.getItem(CUSTOM_PROFILES_KEY);
      if (!stored) return [];
      return JSON.parse(stored) as VIDPIDProfile[];
    } catch (error) {
      console.error('[ProfilesService] Error loading custom profiles:', error);
      return [];
    }
  }

  /**
   * Verificar si existe un perfil con el mismo VID/PID
   */
  async checkDuplicateProfile(vendorId: number, productId: number, excludeId?: string): Promise<{
    isDuplicate: boolean;
    existingProfile?: VIDPIDProfile;
    isPredefined: boolean;
  }> {
    const allProfiles = await this.getAllProfiles();
    
    const existing = allProfiles.find(p => 
      p.vendorId === vendorId && 
      p.productId === productId &&
      p.id !== excludeId
    );
    
    if (existing) {
      return {
        isDuplicate: true,
        existingProfile: existing,
        isPredefined: existing.category !== 'custom',
      };
    }
    
    return { isDuplicate: false, isPredefined: false };
  }

  /**
   * Guardar perfil personalizado
   */
  async saveCustomProfile(profile: Omit<VIDPIDProfile, 'id' | 'category'>): Promise<VIDPIDProfile> {
    try {
      const customProfiles = await this.loadCustomProfiles();
      
      const newProfile: VIDPIDProfile = {
        ...profile,
        id: `custom_${Date.now()}`,
        category: 'custom',
      };
      
      customProfiles.push(newProfile);
      await AsyncStorage.setItem(CUSTOM_PROFILES_KEY, JSON.stringify(customProfiles));
      
      console.log(`[ProfilesService] Custom profile saved: ${newProfile.name}`);
      return newProfile;
    } catch (error) {
      console.error('[ProfilesService] Error saving custom profile:', error);
      throw new Error('No se pudo guardar el perfil personalizado');
    }
  }

  /**
   * Actualizar perfil personalizado existente
   */
  async updateCustomProfile(id: string, updates: Partial<Omit<VIDPIDProfile, 'id' | 'category'>>): Promise<void> {
    try {
      const customProfiles = await this.loadCustomProfiles();
      const index = customProfiles.findIndex(p => p.id === id);
      
      if (index === -1) {
        throw new Error('Perfil no encontrado');
      }
      
      customProfiles[index] = {
        ...customProfiles[index],
        ...updates,
      };
      
      await AsyncStorage.setItem(CUSTOM_PROFILES_KEY, JSON.stringify(customProfiles));
      console.log(`[ProfilesService] Custom profile updated: ${id}`);
    } catch (error) {
      console.error('[ProfilesService] Error updating custom profile:', error);
      throw new Error('No se pudo actualizar el perfil');
    }
  }

  /**
   * Eliminar perfil personalizado
   */
  async deleteCustomProfile(id: string): Promise<void> {
    try {
      const customProfiles = await this.loadCustomProfiles();
      const filtered = customProfiles.filter(p => p.id !== id);
      
      await AsyncStorage.setItem(CUSTOM_PROFILES_KEY, JSON.stringify(filtered));
      console.log(`[ProfilesService] Custom profile deleted: ${id}`);
    } catch (error) {
      console.error('[ProfilesService] Error deleting custom profile:', error);
      throw new Error('No se pudo eliminar el perfil');
    }
  }

  /**
   * Obtener todos los perfiles (predefinidos + personalizados)
   */
  async getAllProfiles(): Promise<VIDPIDProfile[]> {
    const customProfiles = await this.loadCustomProfiles();
    return [...PREDEFINED_PROFILES, ...customProfiles];
  }

  /**
   * Obtener todos los perfiles predefinidos
   */
  getPredefinedProfiles(): VIDPIDProfile[] {
    return PREDEFINED_PROFILES;
  }

  /**
   * Filtrar perfiles por categor√≠a
   */
  async getProfilesByCategory(category: VIDPIDProfile['category']): Promise<VIDPIDProfile[]> {
    const allProfiles = await this.getAllProfiles();
    return allProfiles.filter(p => p.category === category);
  }

    /**
   * Buscar perfil por ID
   */
  async getProfileById(id: string): Promise<VIDPIDProfile | null> {
    const allProfiles = await this.getAllProfiles();
    return allProfiles.find(p => p.id === id) || null;
  }

  /**
   * Buscar perfil por VID/PID
   */
  async findProfileByVIDPID(vendorId: number, productId: number): Promise<VIDPIDProfile | null> {
    const allProfiles = await this.getAllProfiles();
    return allProfiles.find(
      p => p.vendorId === vendorId && p.productId === productId
    ) || null;
  }

  /**
   * Exportar perfil como JSON
   */
  exportProfile(profile: VIDPIDProfile): string {
    return JSON.stringify(profile, null, 2);
  }

  /**
   * Importar perfil desde JSON
   */
  async importProfile(jsonString: string): Promise<VIDPIDProfile> {
    try {
      const profile = JSON.parse(jsonString) as VIDPIDProfile;
      
      // Validar estructura
      if (!profile.name || !profile.vendorId || !profile.productId) {
        throw new Error('JSON inv√°lido: faltan campos requeridos');
      }
      
      // Guardar como perfil personalizado
      const saved = await this.saveCustomProfile({
        name: profile.name,
        manufacturer: profile.manufacturer || 'Desconocido',
        model: profile.model || 'Desconocido',
        vendorId: profile.vendorId,
        productId: profile.productId,
        chipset: profile.chipset || 'Desconocido',
        compatible: profile.compatible || false,
        notes: profile.notes || '',
        icon: profile.icon || 'üîß',
      });
      
      return saved;
    } catch (error) {
      console.error('[ProfilesService] Error importing profile:', error);
      throw new Error('No se pudo importar el perfil: JSON inv√°lido');
    }
  }

  /**
   * Aplicar perfil a dispositivo conectado
   */
  async applyProfile(
    profile: VIDPIDProfile,
    device: UsbDevice,
    createBackup: boolean = true
  ): Promise<{ success: boolean; backupId?: string }> {
    try {
      console.log(`[ProfilesService] Applying profile: ${profile.name}`);
      
      // Crear backup autom√°tico si est√° habilitado
      let backupId: string | undefined;
      if (createBackup) {
        const backup = await backupService.createBackup(
          device,
          `Backup antes de aplicar perfil: ${profile.name}`
        );
        backupId = backup.id;
        console.log(`[ProfilesService] Backup created: ${backupId}`);
      }
      
      // Convertir VID/PID a bytes little endian
      const vidLow = (profile.vendorId & 0xFF).toString(16).padStart(2, '0');
      const vidHigh = ((profile.vendorId >> 8) & 0xFF).toString(16).padStart(2, '0');
      const pidLow = (profile.productId & 0xFF).toString(16).padStart(2, '0');
      const pidHigh = ((profile.productId >> 8) & 0xFF).toString(16).padStart(2, '0');
      
      console.log(`[ProfilesService] Writing VID: 0x${profile.vendorId.toString(16).padStart(4, '0')} (${vidHigh}${vidLow})`);
      console.log(`[ProfilesService] Writing PID: 0x${profile.productId.toString(16).padStart(4, '0')} (${pidHigh}${pidLow})`);
      
      // Escribir VID (offsets 0x88-0x89)
      await usbService.writeEEPROM(0x88, vidLow);
      await new Promise(resolve => setTimeout(resolve, 100));
      await usbService.writeEEPROM(0x89, vidHigh);
      await new Promise(resolve => setTimeout(resolve, 100));
      
      // Escribir PID (offsets 0x8A-0x8B)
      await usbService.writeEEPROM(0x8A, pidLow);
      await new Promise(resolve => setTimeout(resolve, 100));
      await usbService.writeEEPROM(0x8B, pidHigh);
      await new Promise(resolve => setTimeout(resolve, 100));
      
      // Verificar escritura
      const readVidLow = await usbService.readEEPROM(0x88, 1);
      const readVidHigh = await usbService.readEEPROM(0x89, 1);
      const readPidLow = await usbService.readEEPROM(0x8A, 1);
      const readPidHigh = await usbService.readEEPROM(0x8B, 1);
      
      if (
        readVidLow.data.toLowerCase() !== vidLow.toLowerCase() ||
        readVidHigh.data.toLowerCase() !== vidHigh.toLowerCase() ||
        readPidLow.data.toLowerCase() !== pidLow.toLowerCase() ||
        readPidHigh.data.toLowerCase() !== pidHigh.toLowerCase()
      ) {
        throw new Error('Verificaci√≥n fall√≥: valores escritos no coinciden');
      }
      
      console.log(`[ProfilesService] Profile applied successfully: ${profile.name}`);
      return { success: true, backupId };
    } catch (error) {
      console.error('[ProfilesService] Error applying profile:', error);
      throw new Error(`No se pudo aplicar el perfil: ${error}`);
    }
  }

  /**
   * Obtener perfiles compatibles con MIB2
   */
  getMIB2CompatibleProfiles(): VIDPIDProfile[] {
    return PREDEFINED_PROFILES.filter(p => p.compatible);
  }

  /**
   * Obtener perfiles recomendados para spoofing
   */
  getRecommendedProfiles(): VIDPIDProfile[] {
    // Perfiles MIB2 compatibles son los recomendados
    return this.getMIB2CompatibleProfiles();
  }

  /**
   * Validar si un dispositivo puede ser spoofed
   */
  async canDeviceBeSpoof(device: UsbDevice): Promise<{ canSpoof: boolean; reason?: string }> {
    // Verificar si es chipset ASIX
    const isASIX = device.chipset?.toLowerCase().includes('asix') || 
                   device.vendorId === 0x0B95;
    
    if (!isASIX) {
      // Detectar chipset espec√≠fico para mensaje personalizado
      const chipsetLower = device.chipset?.toLowerCase() || '';
      
      if (chipsetLower.includes('realtek')) {
        return {
          canSpoof: false,
          reason: 'Chipsets Realtek NO son compatibles con spoofing en Android. Requieren drivers kernel de Linux/Windows y herramientas espec√≠ficas (PG Tool). Considera conseguir un adaptador ASIX.',
        };
      }
      
      if (chipsetLower.includes('microchip') || chipsetLower.includes('lan')) {
        return {
          canSpoof: false,
          reason: 'Chipsets Microchip NO soportan modificaci√≥n de VID/PID. Solo chipsets ASIX AX88772/A/B son compatibles.',
        };
      }
      
      if (chipsetLower.includes('broadcom')) {
        return {
          canSpoof: false,
          reason: 'Chipsets Broadcom NO soportan modificaci√≥n de VID/PID. Solo chipsets ASIX AX88772/A/B son compatibles.',
        };
      }
      
      if (chipsetLower.includes('davicom')) {
        return {
          canSpoof: false,
          reason: 'Chipsets Davicom NO soportan modificaci√≥n de VID/PID. Solo chipsets ASIX AX88772/A/B son compatibles.',
        };
      }
      
      return {
        canSpoof: false,
        reason: 'Solo chipsets ASIX AX88772/A/B soportan spoofing de EEPROM para MIB2.',
      };
    }
    
    // Validaci√≥n expandida: todos los chipsets ASIX soportan spoofing
    // Los AX88772/A/B est√°n confirmados, otros ASIX son experimentales pero compatibles
    const chipset = device.chipset?.toLowerCase() || '';
    const confirmedModels = ['ax88772', 'ax88772a', 'ax88772b'];
    const isConfirmed = confirmedModels.some(model => chipset.includes(model));
    
    // Todos los ASIX son compatibles (comparten arquitectura de EEPROM)
    // Solo advertimos si es experimental
    if (!isConfirmed) {
      console.log(`[ProfilesService] Chipset ASIX experimental detectado: ${device.chipset}`);
    }
    
    // Verificar si ya tiene VID/PID compatible
    const currentProfile = await this.findProfileByVIDPID(device.vendorId, device.productId);
    if (currentProfile?.compatible) {
      return {
        canSpoof: false,
        reason: 'Dispositivo ya tiene VID/PID compatible con MIB2',
      };
    }
    
    return { canSpoof: true };
  }

  /**
   * Obtener estad√≠sticas de perfiles
   */
  async getStats(): Promise<{
    total: number;
    compatible: number;
    asix: number;
    realtek: number;
    categories: Record<string, number>;
  }> {
    const allProfiles = await this.getAllProfiles();
    const stats = {
      total: allProfiles.length,
      compatible: allProfiles.filter(p => p.compatible).length,
      asix: allProfiles.filter(p => p.chipset.toLowerCase().includes('asix')).length,
      realtek: allProfiles.filter(p => p.chipset.toLowerCase().includes('realtek')).length,
      categories: {} as Record<string, number>,
    };
    
    // Contar por categor√≠a
    allProfiles.forEach(p => {
      stats.categories[p.category] = (stats.categories[p.category] || 0) + 1;
    });
    
    return stats;
  }
}

export const profilesService = new ProfilesService();

================================================================================
FILE: lib/safety-validator.ts
================================================================================

/**
 * Validador de Configuraciones y Sistema de Advertencias de Seguridad
 * Basado en el documento t√©cnico MIB2Acceso.pdf
 */

export type HardwareVersion = '790' | '790A' | '790B' | '790B+' | 'unknown';
export type FirmwareVersion = 'T480' | 'T490' | 'T500' | 'unknown';
export type ValidationLevel = 'pass' | 'warning' | 'error' | 'critical';

export interface HardwareInfo {
  partNumber: string;
  version: HardwareVersion;
  description: string;
  capabilities: string[];
  limitations?: string[];
}

export interface FirmwareInfo {
  version: FirmwareVersion;
  buildDate?: string;
  features: string[];
  knownIssues?: string[];
}

export interface ValidationResult {
  level: ValidationLevel;
  title: string;
  message: string;
  recommendations?: string[];
  technicalDetails?: string;
}

/**
 * Base de datos de hardware conocido
 */
export const KNOWN_HARDWARE: Record<string, HardwareInfo> = {
  '5F0920790': {
    partNumber: '5F0 920 790',
    version: '790',
    description: 'MIB2 STD2 Base (sin letra)',
    capabilities: [
      'Cuadro digital b√°sico',
      'Compatible con skin Carbono (Variante 2)',
      'Soporte para modificaciones VCDS est√°ndar',
    ],
  },
  '5F0920790A': {
    partNumber: '5F0 920 790 A',
    version: '790A',
    description: 'MIB2 STD2 Revisi√≥n A',
    capabilities: [
      'Cuadro digital mejorado',
      'Compatible con skin Carbono (Variante 2)',
      'Soporte completo para VCDS',
    ],
  },
  '5F0920790B': {
    partNumber: '5F0 920 790 B',
    version: '790B',
    description: 'MIB2 STD2 Revisi√≥n B',
    capabilities: [
      'Cuadro digital avanzado',
      'Compatible con skins Carbono y Cupra (Variantes 2 y 3)',
      'Soporte completo para VCDS',
    ],
  },
  '5F0920790B+': {
    partNumber: '5F0 920 790 B+',
    version: '790B+',
    description: 'MIB2 STD2 Revisi√≥n B+ (Vista Sport)',
    capabilities: [
      'Cuadro digital con Vista Sport',
      'Compatible con todos los skins',
      'Soporte completo para VCDS',
      'Performance Monitor nativo',
    ],
  },
};

/**
 * Informaci√≥n de firmware conocido
 */
export const KNOWN_FIRMWARE: Record<string, FirmwareInfo> = {
  T480: {
    version: 'T480',
    features: [
      'Soporte para MIB2 Toolbox',
      'Compatible con c√≥digos FEC',
      'Modificaciones VCDS est√°ndar',
    ],
    knownIssues: [
      'Algunas unidades 1-SD carecen de rutinas de validaci√≥n de firmas',
    ],
  },
  T490: {
    version: 'T490',
    features: [
      'Soporte mejorado para MIB2 Toolbox',
      'Compatible con c√≥digos FEC',
      'Modificaciones VCDS completas',
    ],
  },
  T500: {
    version: 'T500',
    features: [
      '√öltima versi√≥n estable',
      'Soporte completo para MIB2 Toolbox',
      'Compatible con c√≥digos FEC',
      'Modificaciones VCDS completas',
    ],
  },
};

/**
 * Validar compatibilidad de hardware
 */
export function validateHardware(partNumber: string): ValidationResult {
  const hardware = KNOWN_HARDWARE[partNumber.replace(/\s/g, '')];
  
  if (!hardware) {
    return {
      level: 'warning',
      title: 'Hardware Desconocido',
      message: `El n√∫mero de parte "${partNumber}" no est√° en la base de datos de hardware conocido.`,
      recommendations: [
        'Verificar el n√∫mero de parte en la etiqueta de la unidad',
        'Consultar el manual del veh√≠culo para confirmar la versi√≥n',
        'Proceder con precauci√≥n al aplicar modificaciones',
      ],
      technicalDetails: 'Las modificaciones pueden funcionar, pero no hay garant√≠a de compatibilidad completa.',
    };
  }

  if (hardware.limitations && hardware.limitations.length > 0) {
    return {
      level: 'warning',
      title: 'Hardware con Limitaciones',
      message: `Hardware ${hardware.description} identificado con limitaciones conocidas.`,
      recommendations: hardware.limitations,
      technicalDetails: `Capacidades: ${hardware.capabilities.join(', ')}`,
    };
  }

  return {
    level: 'pass',
    title: 'Hardware Compatible',
    message: `Hardware ${hardware.description} identificado correctamente.`,
    recommendations: [`Capacidades disponibles: ${hardware.capabilities.join(', ')}`],
  };
}

/**
 * Validar versi√≥n de firmware
 */
export function validateFirmware(version: string): ValidationResult {
  const firmware = KNOWN_FIRMWARE[version.toUpperCase()];
  
  if (!firmware) {
    return {
      level: 'warning',
      title: 'Firmware Desconocido',
      message: `La versi√≥n de firmware "${version}" no est√° en la base de datos.`,
      recommendations: [
        'Verificar la versi√≥n de firmware en el men√∫ del sistema',
        'Consultar la documentaci√≥n oficial de VW',
        'Considerar actualizar a una versi√≥n conocida',
      ],
    };
  }

  if (firmware.knownIssues && firmware.knownIssues.length > 0) {
    return {
      level: 'warning',
      title: 'Firmware con Problemas Conocidos',
      message: `Firmware ${firmware.version} tiene problemas conocidos.`,
      recommendations: firmware.knownIssues,
      technicalDetails: `Caracter√≠sticas: ${firmware.features.join(', ')}`,
    };
  }

  return {
    level: 'pass',
    title: 'Firmware Compatible',
    message: `Firmware ${firmware.version} identificado correctamente.`,
    recommendations: [`Caracter√≠sticas disponibles: ${firmware.features.join(', ')}`],
  };
}

/**
 * Validar c√≥digo FEC antes de inyecci√≥n
 */
export function validateFECInjection(fecCodes: string[], hardwareVersion: HardwareVersion, firmwareVersion: FirmwareVersion): ValidationResult {
  // Validar que el hardware soporte c√≥digos FEC
  if (hardwareVersion === 'unknown') {
    return {
      level: 'error',
      title: 'Hardware No Identificado',
      message: 'No se puede validar la compatibilidad de c√≥digos FEC sin identificar el hardware.',
      recommendations: [
        'Identificar el n√∫mero de parte del hardware',
        'Verificar la compatibilidad antes de inyectar c√≥digos',
      ],
    };
  }

  // Validar que el firmware soporte el m√©todo de inyecci√≥n
  if (firmwareVersion === 'unknown') {
    return {
      level: 'warning',
      title: 'Firmware No Identificado',
      message: 'No se puede garantizar que el m√©todo de inyecci√≥n funcione con este firmware.',
      recommendations: [
        'Identificar la versi√≥n de firmware',
        'Verificar que el MIB2 Toolbox est√© instalado',
        'Realizar backup antes de proceder',
      ],
    };
  }

  // Advertencia sobre el m√©todo de parcheo
  return {
    level: 'warning',
    title: 'Validaci√≥n de Inyecci√≥n FEC',
    message: 'La inyecci√≥n de c√≥digos FEC sortea la validaci√≥n de firmware digital de VW AG.',
    recommendations: [
      'Asegurarse de que el MIB2 Toolbox est√© instalado',
      'Verificar que el sistema est√© parcheado (tsd.mibstd2.system.swap)',
      'Crear ExceptionList.txt con los c√≥digos seleccionados',
      'Realizar backup completo antes de proceder',
    ],
    technicalDetails: 'El m√©todo de parcheo modifica el binario del sistema para alterar la rutina de verificaci√≥n de firmas. Una vez parcheado, el sistema consulta la ExceptionList.txt generada por el usuario.',
  };
}

/**
 * Advertencias cr√≠ticas de seguridad por procedimiento
 */
export const CRITICAL_SAFETY_WARNINGS: Record<string, ValidationResult> = {
  xds_strong: {
    level: 'critical',
    title: '‚ö†Ô∏è ADVERTENCIA CR√çTICA: XDS+ en Modo "Strong"',
    message: 'NO configurar el XDS+ en modo "Strong" (Stark). Este ajuste genera desgaste parasitario de frenos y estr√©s t√©rmico sin beneficios tangibles.',
    recommendations: [
      'Las temperaturas del disco pueden superar 600¬∞C-700¬∞C',
      'El l√≠quido de frenos puede alcanzar su punto de ebullici√≥n (vapor lock)',
      'El desgaste se acelera exponencialmente',
      'Un juego de pastillas puede destruirse en una sola sesi√≥n de pista',
      'En veh√≠culos con VAQ, genera un bucle de control conflictivo',
    ],
    technicalDetails: 'Configuraci√≥n recomendada: "Standard" (Est√°ndar). El XDS+ debe actuar solo como red de seguridad de √∫ltimo recurso, no como sistema de vectorizaci√≥n primario.',
  },
  vaq_traction: {
    level: 'warning',
    title: 'Recomendaci√≥n: VAQ Tracci√≥n Aumentada',
    message: 'Para maximizar tracci√≥n, ajustar el VAQ a "Tracci√≥n Aumentada" en lugar de modificar XDS+.',
    recommendations: [
      'Permite un bloqueo m√°s agresivo y r√°pido de los discos del embrague',
      'Sacrifica suavidad ac√∫stica a cambio de mayor rendimiento',
      'El VAQ es mec√°nicamente superior y t√©rmicamente eficiente',
      'Pueden escucharse crujidos o arrastre de neum√°ticos en giros cerrados a baja velocidad',
    ],
    technicalDetails: 'El VAQ (Vorderachsquersperre) es el diferencial de deslizamiento limitado electrohidr√°ulico situado entre la caja del diferencial y el semieje derecho.',
  },
  vista_sport_limitation: {
    level: 'warning',
    title: 'Limitaci√≥n: Vista Sport',
    message: 'La Vista Sport solo est√° disponible en unidades de hardware 790 B+.',
    recommendations: [
      'Verificar el n√∫mero de parte del hardware antes de intentar activar',
      'En unidades 790, 790A o 790B sin el sufijo "+", la Vista Sport no estar√° disponible',
      'Considerar actualizaci√≥n de hardware si se requiere esta funci√≥n',
    ],
    technicalDetails: 'La Vista Sport es una caracter√≠stica de hardware que requiere el cuadro digital espec√≠fico de la revisi√≥n B+.',
  },
  emmc_access_warning: {
    level: 'critical',
    title: '‚ö†Ô∏è ADVERTENCIA CR√çTICA: Acceso Directo eMMC',
    message: 'El acceso directo al chip eMMC es un m√©todo avanzado que puede da√±ar permanentemente la unidad.',
    recommendations: [
      'Requiere habilidades avanzadas de microsoldadura',
      'Puede anular la garant√≠a',
      'Riesgo de "brickear" la unidad permanentemente',
      'Solo para usuarios con experiencia en electr√≥nica',
      '√öltimo recurso cuando otros m√©todos fallan',
    ],
    technicalDetails: 'Este m√©todo implica soldadura directa a los pines del chip eMMC para acceder a la memoria no vol√°til. Ofrece control total pero es destructivo potencialmente.',
  },
};

/**
 * Obtener advertencia de seguridad por ID
 */
export function getSafetyWarning(id: string): ValidationResult | undefined {
  return CRITICAL_SAFETY_WARNINGS[id];
}

/**
 * Validar configuraci√≥n completa antes de aplicar modificaciones
 */
export function validateConfiguration(
  hardwarePartNumber: string,
  firmwareVersion: string,
  procedureId: string
): ValidationResult[] {
  const results: ValidationResult[] = [];

  // Validar hardware
  results.push(validateHardware(hardwarePartNumber));

  // Validar firmware
  results.push(validateFirmware(firmwareVersion));

  // Agregar advertencias espec√≠ficas del procedimiento
  if (procedureId === 'xds_control') {
    results.push(CRITICAL_SAFETY_WARNINGS.xds_strong);
  }

  if (procedureId === 'vaq_optimization') {
    results.push(CRITICAL_SAFETY_WARNINGS.vaq_traction);
  }

  return results;
}

/**
 * Generar reporte de validaci√≥n
 */
export function generateValidationReport(results: ValidationResult[]): string {
  const report = `# Reporte de Validaci√≥n de Configuraci√≥n
# Generado por MIB2 Controller
# Fecha: ${new Date().toISOString()}

## Resumen

Total de validaciones: ${results.length}
- Cr√≠ticas: ${results.filter(r => r.level === 'critical').length}
- Errores: ${results.filter(r => r.level === 'error').length}
- Advertencias: ${results.filter(r => r.level === 'warning').length}
- Aprobadas: ${results.filter(r => r.level === 'pass').length}

## Detalles

${results.map((result, index) => `
### ${index + 1}. ${result.title} [${result.level.toUpperCase()}]

${result.message}

${result.recommendations ? `**Recomendaciones:**\n${result.recommendations.map(r => `- ${r}`).join('\n')}` : ''}

${result.technicalDetails ? `**Detalles T√©cnicos:**\n${result.technicalDetails}` : ''}
`).join('\n---\n')}

## Conclusi√≥n

${results.some(r => r.level === 'critical' || r.level === 'error') 
  ? '‚ö†Ô∏è Se encontraron problemas cr√≠ticos o errores. Revisar las recomendaciones antes de proceder.' 
  : results.some(r => r.level === 'warning')
  ? '‚ö†Ô∏è Se encontraron advertencias. Proceder con precauci√≥n.'
  : '‚úÖ Todas las validaciones pasaron correctamente.'}
`;

  return report;
}

================================================================================
FILE: lib/telnet-client.ts
================================================================================

import TcpSocket from "react-native-tcp-socket";

export interface TelnetConfig {
  host: string;
  port: number;
  username: string;
  password: string;
}

export interface TelnetMessage {
  type: "info" | "error" | "command" | "response";
  text: string;
  timestamp: Date;
}

export class TelnetClient {
  private socket: any = null;
  private connected = false;
  private buffer = "";
  private onMessageCallback?: (message: TelnetMessage) => void;
  private onConnectCallback?: () => void;
  private onDisconnectCallback?: () => void;

  constructor(
    private config: TelnetConfig,
    callbacks?: {
      onMessage?: (message: TelnetMessage) => void;
      onConnect?: () => void;
      onDisconnect?: () => void;
    }
  ) {
    this.onMessageCallback = callbacks?.onMessage;
    this.onConnectCallback = callbacks?.onConnect;
    this.onDisconnectCallback = callbacks?.onDisconnect;
  }

  connect(): Promise<void> {
    return new Promise((resolve, reject) => {
      try {
        this.socket = TcpSocket.createConnection(
          {
            host: this.config.host,
            port: this.config.port,
          },
          () => {
            this.connected = true;
            this.emitMessage("info", `Conectado a ${this.config.host}:${this.config.port}`);
            this.onConnectCallback?.();
            
            // Esperar prompt de login y enviar credenciales
            setTimeout(() => {
              this.sendCommand(this.config.username);
              setTimeout(() => {
                this.sendCommand(this.config.password);
              }, 500);
            }, 1000);
            
            resolve();
          }
        );

        this.socket.on("data", (data: Buffer) => {
          const text = data.toString("utf8");
          this.buffer += text;
          
          // Procesar l√≠neas completas
          const lines = this.buffer.split("\n");
          this.buffer = lines.pop() || "";
          
          lines.forEach((line) => {
            const trimmed = line.trim();
            if (trimmed) {
              this.emitMessage("response", trimmed);
            }
          });
        });

        this.socket.on("error", (error: Error) => {
          this.emitMessage("error", `Error: ${error.message}`);
          reject(error);
        });

        this.socket.on("close", () => {
          this.connected = false;
          this.emitMessage("info", "Conexi√≥n cerrada");
          this.onDisconnectCallback?.();
        });
      } catch (error) {
        reject(error);
      }
    });
  }

  sendCommand(command: string): void {
    if (!this.connected || !this.socket) {
      this.emitMessage("error", "No conectado");
      return;
    }

    try {
      this.emitMessage("command", `$ ${command}`);
      this.socket.write(`${command}\n`);
    } catch (error) {
      this.emitMessage("error", `Error al enviar comando: ${(error as Error).message}`);
    }
  }

  disconnect(): void {
    if (this.socket) {
      this.socket.destroy();
      this.socket = null;
      this.connected = false;
    }
  }

  isConnected(): boolean {
    return this.connected;
  }

  private emitMessage(type: TelnetMessage["type"], text: string): void {
    const message: TelnetMessage = {
      type,
      text,
      timestamp: new Date(),
    };
    this.onMessageCallback?.(message);
  }
}

// Comandos pre-configurados para MIB2
export const MIB2_COMMANDS = {
  // Informaci√≥n del sistema
  VERSION: "cat /net/rcc/dev/shmem/version.txt",
  MIB_INFO: "cat /net/rcc/dev/shmem/mib_info",
  MOUNT: "mount",
  UPTIME: "uptime",
  IFCONFIG: "ifconfig",
  
  // Instalaci√≥n de Toolbox
  INSTALL_TOOLBOX: "ksh /media/mp000/install.sh",
  INSTALL_TOOLBOX_USB: "ksh /media/mp002/install.sh",
  
  // Navegaci√≥n
  LS_ROOT: "ls -la /",
  LS_NET_RCC: "ls -la /net/rcc",
  LS_MEDIA: "ls -la /media",
  
  // Procesos
  PS: "ps aux",
  TOP: "top -n 1",
  
  // Toolbox
  TOOLBOX_MENU: "/mnt/efs-persist/toolbox/bin/mibstd2_toolbox",
};

// Configuraci√≥n por defecto para MIB2 STD2
export const DEFAULT_MIB2_CONFIG: TelnetConfig = {
  host: "192.168.1.4",
  port: 23,
  username: "root",
  password: "root",
};

================================================================================
FILE: lib/telnet-provider.tsx
================================================================================

/**
 * Telnet Provider - React Context for MIB2 Connection Management
 */

import React, { createContext, useContext, useState, useCallback, useEffect } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';
import {
  TelnetClient,
  TelnetConfig,
  TelnetMessage,
  DEFAULT_MIB2_CONFIG,
} from './telnet-client';

interface TelnetContextValue {
  // Connection state
  isConnected: boolean;
  isConnecting: boolean;
  
  // Configuration
  config: TelnetConfig;
  updateConfig: (config: Partial<TelnetConfig>) => Promise<void>;
  
  // Connection methods
  connect: () => Promise<void>;
  disconnect: () => void;
  
  // Command execution
  sendCommand: (command: string) => void;
  
  // Message history
  messages: TelnetMessage[];
  clearMessages: () => void;
}

const TelnetContext = createContext<TelnetContextValue | undefined>(undefined);

const STORAGE_KEY_CONFIG = '@mib2_controller:telnet_config';
const STORAGE_KEY_MESSAGES = '@mib2_controller:telnet_messages';
const MAX_MESSAGES = 500;

export function TelnetProvider({ children }: { children: React.ReactNode }) {
  const [client, setClient] = useState<TelnetClient | null>(null);
  const [config, setConfig] = useState<TelnetConfig>(DEFAULT_MIB2_CONFIG);
  const [isConnected, setIsConnected] = useState(false);
  const [isConnecting, setIsConnecting] = useState(false);
  const [messages, setMessages] = useState<TelnetMessage[]>([]);

  // Load saved configuration on mount
  useEffect(() => {
    loadConfig();
    loadMessages();
  }, []);

  // Save messages when they change
  useEffect(() => {
    saveMessages();
  }, [messages]);

  const loadConfig = async () => {
    try {
      const saved = await AsyncStorage.getItem(STORAGE_KEY_CONFIG);
      if (saved) {
        setConfig(JSON.parse(saved));
      }
    } catch (error) {
      console.error('Error loading telnet config:', error);
    }
  };

  const loadMessages = async () => {
    try {
      const saved = await AsyncStorage.getItem(STORAGE_KEY_MESSAGES);
      if (saved) {
        const parsed = JSON.parse(saved);
        // Convert timestamp strings back to Date objects
        const messagesWithDates = parsed.map((msg: any) => ({
          ...msg,
          timestamp: new Date(msg.timestamp),
        }));
        setMessages(messagesWithDates);
      }
    } catch (error) {
      console.error('Error loading messages:', error);
    }
  };

  const saveMessages = async () => {
    try {
      await AsyncStorage.setItem(STORAGE_KEY_MESSAGES, JSON.stringify(messages));
    } catch (error) {
      console.error('Error saving messages:', error);
    }
  };

  const updateConfig = useCallback(async (newConfig: Partial<TelnetConfig>) => {
    const updated = { ...config, ...newConfig };
    setConfig(updated);
    try {
      await AsyncStorage.setItem(STORAGE_KEY_CONFIG, JSON.stringify(updated));
    } catch (error) {
      console.error('Error saving telnet config:', error);
    }
  }, [config]);

  const addMessage = useCallback((message: TelnetMessage) => {
    setMessages((prev) => {
      const updated = [...prev, message];
      // Keep only last MAX_MESSAGES
      if (updated.length > MAX_MESSAGES) {
        return updated.slice(-MAX_MESSAGES);
      }
      return updated;
    });
  }, []);

  const connect = useCallback(async () => {
    if (isConnecting || isConnected) return;

    setIsConnecting(true);
    
    try {
      const newClient = new TelnetClient(config, {
        onMessage: addMessage,
        onConnect: () => {
          setIsConnected(true);
          setIsConnecting(false);
        },
        onDisconnect: () => {
          setIsConnected(false);
          setClient(null);
        },
      });

      await newClient.connect();
      setClient(newClient);
    } catch (error) {
      setIsConnecting(false);
      addMessage({
        type: 'error',
        text: `Error de conexi√≥n: ${(error as Error).message}`,
        timestamp: new Date(),
      });
      throw error;
    }
  }, [config, isConnecting, isConnected, addMessage]);

  const disconnect = useCallback(() => {
    if (client) {
      client.disconnect();
      setClient(null);
      setIsConnected(false);
    }
  }, [client]);

  const sendCommand = useCallback((command: string) => {
    if (!client || !isConnected) {
      addMessage({
        type: 'error',
        text: 'No conectado a MIB2',
        timestamp: new Date(),
      });
      return;
    }

    client.sendCommand(command);
  }, [client, isConnected, addMessage]);

  const clearMessages = useCallback(() => {
    setMessages([]);
  }, []);

  const value: TelnetContextValue = {
    isConnected,
    isConnecting,
    config,
    updateConfig,
    connect,
    disconnect,
    sendCommand,
    messages,
    clearMessages,
  };

  return <TelnetContext.Provider value={value}>{children}</TelnetContext.Provider>;
}

export function useTelnet() {
  const context = useContext(TelnetContext);
  if (!context) {
    throw new Error('useTelnet must be used within TelnetProvider');
  }
  return context;
}

================================================================================
FILE: lib/theme-provider.tsx
================================================================================

import { createContext, useCallback, useContext, useEffect, useMemo, useState } from "react";
import { Appearance, View, useColorScheme as useSystemColorScheme } from "react-native";
import { colorScheme as nativewindColorScheme, vars } from "nativewind";

import { SchemeColors, type ColorScheme } from "@/constants/theme";

type ThemeContextValue = {
  colorScheme: ColorScheme;
  setColorScheme: (scheme: ColorScheme) => void;
};

const ThemeContext = createContext<ThemeContextValue | null>(null);

export function ThemeProvider({ children }: { children: React.ReactNode }) {
  const systemScheme = useSystemColorScheme() ?? "light";
  const [colorScheme, setColorSchemeState] = useState<ColorScheme>(systemScheme);

  const applyScheme = useCallback((scheme: ColorScheme) => {
    nativewindColorScheme.set(scheme);
    Appearance.setColorScheme?.(scheme);
    if (typeof document !== "undefined") {
      const root = document.documentElement;
      root.dataset.theme = scheme;
      root.classList.toggle("dark", scheme === "dark");
      const palette = SchemeColors[scheme];
      Object.entries(palette).forEach(([token, value]) => {
        root.style.setProperty(`--color-${token}`, value);
      });
    }
  }, []);

  const setColorScheme = useCallback((scheme: ColorScheme) => {
    setColorSchemeState(scheme);
    applyScheme(scheme);
  }, [applyScheme]);

  useEffect(() => {
    applyScheme(colorScheme);
  }, [applyScheme, colorScheme]);

  const themeVariables = useMemo(
    () =>
      vars({
        "color-primary": SchemeColors[colorScheme].primary,
        "color-background": SchemeColors[colorScheme].background,
        "color-surface": SchemeColors[colorScheme].surface,
        "color-foreground": SchemeColors[colorScheme].foreground,
        "color-muted": SchemeColors[colorScheme].muted,
        "color-border": SchemeColors[colorScheme].border,
        "color-success": SchemeColors[colorScheme].success,
        "color-warning": SchemeColors[colorScheme].warning,
        "color-error": SchemeColors[colorScheme].error,
      }),
    [colorScheme],
  );

  const value = useMemo(
    () => ({
      colorScheme,
      setColorScheme,
    }),
    [colorScheme, setColorScheme],
  );
  console.log(value, themeVariables)

  return (
    <ThemeContext.Provider value={value}>
      <View style={[{ flex: 1 }, themeVariables]}>{children}</View>
    </ThemeContext.Provider>
  );
}

export function useThemeContext(): ThemeContextValue {
  const ctx = useContext(ThemeContext);
  if (!ctx) {
    throw new Error("useThemeContext must be used within ThemeProvider");
  }
  return ctx;
}

================================================================================
FILE: lib/toolbox-backup.ts
================================================================================

/**
 * MIB2 Toolbox Backup System
 * 
 * Sistema de backup autom√°tico para archivos cr√≠ticos del MIB2
 * antes de realizar modificaciones peligrosas.
 */

export interface BackupInfo {
  filename: string;
  originalPath: string;
  backupPath: string;
  timestamp: string;
  size: number;
  checksum?: string;
}

export interface BackupResult {
  success: boolean;
  backup?: BackupInfo;
  error?: string;
}

/**
 * Crear backup de un archivo cr√≠tico del MIB2
 */
export async function createBackup(
  executeCommand: (cmd: string) => Promise<any>,
  filePath: string
): Promise<BackupResult> {
  try {
    // Verificar que el archivo existe
    const checkResponse = await executeCommand(`ls -la ${filePath} 2>/dev/null || echo "NOT_FOUND"`);
    if (!checkResponse.success || checkResponse.output.includes('NOT_FOUND')) {
      return {
        success: false,
        error: `Archivo no encontrado: ${filePath}`,
      };
    }

    // Obtener tama√±o del archivo
    const sizeResponse = await executeCommand(`stat -c %s ${filePath} 2>/dev/null || echo "0"`);
    const size = parseInt(sizeResponse.output.trim()) || 0;

    // Generar nombre de backup con timestamp
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = filePath.split('/').pop() || 'unknown';
    const backupPath = `/net/rcc/mnt/efs-persist/backups/${filename}.${timestamp}.bak`;

    // Crear directorio de backups si no existe
    await executeCommand('mkdir -p /net/rcc/mnt/efs-persist/backups');

    // Copiar archivo a backup
    const copyResponse = await executeCommand(`cp -p ${filePath} ${backupPath} 2>&1`);
    if (!copyResponse.success) {
      return {
        success: false,
        error: `Error al copiar archivo: ${copyResponse.output}`,
      };
    }

    // Verificar que el backup se cre√≥ correctamente
    const verifyResponse = await executeCommand(`ls -la ${backupPath} 2>/dev/null || echo "NOT_FOUND"`);
    if (!verifyResponse.success || verifyResponse.output.includes('NOT_FOUND')) {
      return {
        success: false,
        error: 'Backup creado pero no se pudo verificar',
      };
    }

    // Calcular checksum (MD5) para verificaci√≥n de integridad
    const checksumResponse = await executeCommand(`md5sum ${backupPath} 2>/dev/null | awk '{print $1}' || echo "NO_CHECKSUM"`);
    const checksum = checksumResponse.success && !checksumResponse.output.includes('NO_CHECKSUM')
      ? checksumResponse.output.trim()
      : undefined;

    return {
      success: true,
      backup: {
        filename,
        originalPath: filePath,
        backupPath,
        timestamp,
        size,
        checksum,
      },
    };
  } catch (error) {
    return {
      success: false,
      error: `Error inesperado: ${error}`,
    };
  }
}

/**
 * Restaurar un archivo desde backup
 */
export async function restoreBackup(
  executeCommand: (cmd: string) => Promise<any>,
  backup: BackupInfo
): Promise<BackupResult> {
  try {
    // Verificar que el backup existe
    const checkResponse = await executeCommand(`ls -la ${backup.backupPath} 2>/dev/null || echo "NOT_FOUND"`);
    if (!checkResponse.success || checkResponse.output.includes('NOT_FOUND')) {
      return {
        success: false,
        error: `Backup no encontrado: ${backup.backupPath}`,
      };
    }

    // Verificar checksum antes de restaurar (si est√° disponible)
    if (backup.checksum) {
      const checksumResponse = await executeCommand(`md5sum ${backup.backupPath} 2>/dev/null | awk '{print $1}' || echo "NO_CHECKSUM"`);
      const currentChecksum = checksumResponse.output.trim();
      
      if (currentChecksum !== backup.checksum && currentChecksum !== 'NO_CHECKSUM') {
        return {
          success: false,
          error: 'Checksum del backup no coincide. El archivo puede estar corrupto.',
        };
      }
    }

    // Restaurar archivo
    const restoreResponse = await executeCommand(`cp -p ${backup.backupPath} ${backup.originalPath} 2>&1`);
    if (!restoreResponse.success) {
      return {
        success: false,
        error: `Error al restaurar archivo: ${restoreResponse.output}`,
      };
    }

    // Verificar que la restauraci√≥n fue exitosa
    const verifyResponse = await executeCommand(`ls -la ${backup.originalPath} 2>/dev/null || echo "NOT_FOUND"`);
    if (!verifyResponse.success || verifyResponse.output.includes('NOT_FOUND')) {
      return {
        success: false,
        error: 'Archivo restaurado pero no se pudo verificar',
      };
    }

    return {
      success: true,
      backup,
    };
  } catch (error) {
    return {
      success: false,
      error: `Error inesperado: ${error}`,
    };
  }
}

/**
 * Listar todos los backups disponibles
 */
export async function listBackups(
  executeCommand: (cmd: string) => Promise<any>
): Promise<BackupInfo[]> {
  try {
    const listResponse = await executeCommand('ls -la /net/rcc/mnt/efs-persist/backups/*.bak 2>/dev/null || echo "NO_BACKUPS"');
    
    if (!listResponse.success || listResponse.output.includes('NO_BACKUPS')) {
      return [];
    }

    const lines = listResponse.output.trim().split('\n');
    const backups: BackupInfo[] = [];

    for (const line of lines) {
      // Parsear l√≠nea de ls -la
      const match = line.match(/(\S+)\s+(\d+)\s+\S+\s+\S+\s+(\d+)\s+.*\s+(\S+\.bak)$/);
      if (match) {
        const [, , , sizeStr, backupPath] = match;
        const filename = backupPath.split('/').pop() || '';
        
        // Extraer timestamp del nombre del archivo
        const timestampMatch = filename.match(/\.(\d{4}-\d{2}-\d{2}T\d{2}-\d{2}-\d{2}-\d{3}Z)\.bak$/);
        const timestamp = timestampMatch ? timestampMatch[1].replace(/-/g, ':').replace('T', ' ') : 'Unknown';

        // Intentar determinar ruta original
        const originalFilename = filename.replace(/\.\d{4}-\d{2}-\d{2}T.*\.bak$/, '');
        const originalPath = `/net/rcc/dev/sbin/${originalFilename}`; // Ruta com√∫n para binarios

        backups.push({
          filename: originalFilename,
          originalPath,
          backupPath,
          timestamp,
          size: parseInt(sizeStr) || 0,
        });
      }
    }

    return backups;
  } catch (error) {
    console.error('Error al listar backups:', error);
    return [];
  }
}

/**
 * Eliminar un backup
 */
export async function deleteBackup(
  executeCommand: (cmd: string) => Promise<any>,
  backupPath: string
): Promise<boolean> {
  try {
    const deleteResponse = await executeCommand(`rm -f ${backupPath} 2>&1`);
    return deleteResponse.success;
  } catch (error) {
    console.error('Error al eliminar backup:', error);
    return false;
  }
}

/**
 * Crear backup del binario cr√≠tico tsd.mibstd2.system.swap antes de parchear
 */
export async function backupCriticalBinary(
  executeCommand: (cmd: string) => Promise<any>
): Promise<BackupResult> {
  const criticalBinaryPath = '/net/rcc/dev/sbin/tsd.mibstd2.system.swap';
  return createBackup(executeCommand, criticalBinaryPath);
}

/**
 * Verificar integridad de un archivo comparando con su backup
 */
export async function verifyFileIntegrity(
  executeCommand: (cmd: string) => Promise<any>,
  filePath: string,
  backup: BackupInfo
): Promise<boolean> {
  try {
    if (!backup.checksum) {
      return false;
    }

    const checksumResponse = await executeCommand(`md5sum ${filePath} 2>/dev/null | awk '{print $1}' || echo "NO_CHECKSUM"`);
    const currentChecksum = checksumResponse.output.trim();

    return currentChecksum === backup.checksum;
  } catch (error) {
    console.error('Error al verificar integridad:', error);
    return false;
  }
}

================================================================================
FILE: lib/toolbox-detector.ts
================================================================================

/**
 * MIB2 Toolbox Detector
 * 
 * Detects if MIB2 Toolbox is installed and retrieves version/status information
 */

export interface ToolboxInfo {
  installed: boolean;
  version?: string;
  services?: {
    telnet: boolean;
    ftp: boolean;
    ssh: boolean;
    webserver: boolean;
  };
  installPath?: string;
  configFiles?: string[];
  firmwareVersion?: string;
  firmwareCompatible?: boolean;
  hardwareVersion?: string;
}

/**
 * Detect if MIB2 Toolbox is installed
 */
export async function detectToolbox(executeCommand: (cmd: string) => Promise<any>): Promise<ToolboxInfo> {
  const result: ToolboxInfo = {
    installed: false,
  };

  try {
    // Check for common Toolbox installation paths
    const pathCheckResponse = await executeCommand('ls -la /net/rcc/mnt/efs-system/toolbox 2>/dev/null || echo "NOT_FOUND"');
    
    if (pathCheckResponse.success && !pathCheckResponse.output.includes('NOT_FOUND')) {
      result.installed = true;
      result.installPath = '/net/rcc/mnt/efs-system/toolbox';

      // Try to get version
      const versionResponse = await executeCommand('cat /net/rcc/mnt/efs-system/toolbox/version.txt 2>/dev/null || cat /net/rcc/mnt/efs-system/toolbox/VERSION 2>/dev/null || echo "UNKNOWN"');
      if (versionResponse.success && !versionResponse.output.includes('UNKNOWN')) {
        result.version = versionResponse.output.trim();
      }

      // Check for services
      result.services = await detectServices(executeCommand);

      // List config files
      const configResponse = await executeCommand('ls /net/rcc/mnt/efs-system/toolbox/*.cfg 2>/dev/null || echo "NONE"');
      if (configResponse.success && !configResponse.output.includes('NONE')) {
        result.configFiles = configResponse.output.trim().split('\n').filter(Boolean);
      }
    } else {
      // Try alternative path
      const altPathResponse = await executeCommand('ls -la /net/rcc/mnt/efs-persist/toolbox 2>/dev/null || echo "NOT_FOUND"');
      
      if (altPathResponse.success && !altPathResponse.output.includes('NOT_FOUND')) {
        result.installed = true;
        result.installPath = '/net/rcc/mnt/efs-persist/toolbox';

        // Try to get version from alternative path
        const versionResponse = await executeCommand('cat /net/rcc/mnt/efs-persist/toolbox/version.txt 2>/dev/null || echo "UNKNOWN"');
        if (versionResponse.success && !versionResponse.output.includes('UNKNOWN')) {
          result.version = versionResponse.output.trim();
        }

        result.services = await detectServices(executeCommand);
      }
    }
    // Detect firmware version
    const firmwareInfo = await detectFirmwareVersion(executeCommand);
    result.firmwareVersion = firmwareInfo.version;
    result.firmwareCompatible = firmwareInfo.compatible;
    result.hardwareVersion = firmwareInfo.hardware;
  } catch (error) {
    console.error('Error detecting toolbox:', error);
  }

  return result;
}

/**
 * Detect MIB2 firmware version and hardware
 */
async function detectFirmwareVersion(executeCommand: (cmd: string) => Promise<any>): Promise<{
  version: string;
  compatible: boolean;
  hardware: string;
}> {
  const result = {
    version: 'Unknown',
    compatible: true,
    hardware: 'Unknown',
  };

  try {
    // Try to get firmware version from /etc/version
    const versionResponse = await executeCommand('cat /etc/version 2>/dev/null || echo "NOT_FOUND"');
    if (versionResponse.success && !versionResponse.output.includes('NOT_FOUND')) {
      result.version = versionResponse.output.trim();
    } else {
      // Try alternative paths
      const altVersionResponse = await executeCommand('cat /net/rcc/mnt/efs-system/version.txt 2>/dev/null || cat /proc/version 2>/dev/null || echo "NOT_FOUND"');
      if (altVersionResponse.success && !altVersionResponse.output.includes('NOT_FOUND')) {
        result.version = altVersionResponse.output.trim().substring(0, 100); // Limit length
      }
    }

    // Try to detect hardware version
    const hwResponse = await executeCommand('cat /proc/cpuinfo | grep Hardware || echo "NOT_FOUND"');
    if (hwResponse.success && !hwResponse.output.includes('NOT_FOUND')) {
      result.hardware = hwResponse.output.trim();
    }

    // Validate compatibility (Telnet debe estar disponible)
    const telnetCheck = await executeCommand('netstat -an | grep ":23 " | grep LISTEN || echo "TELNET_CLOSED"');
    if (telnetCheck.success && telnetCheck.output.includes('TELNET_CLOSED')) {
      result.compatible = false;
    }
  } catch (error) {
    console.error('Error detecting firmware version:', error);
  }

  return result;
}

/**
 * Detect which services are enabled
 */
async function detectServices(executeCommand: (cmd: string) => Promise<any>): Promise<ToolboxInfo['services']> {
  const services = {
    telnet: false,
    ftp: false,
    ssh: false,
    webserver: false,
  };

  try {
    // Check if telnet is running (port 23)
    const telnetCheck = await executeCommand('netstat -an | grep ":23 " | grep LISTEN || echo "NOT_RUNNING"');
    services.telnet = telnetCheck.success && !telnetCheck.output.includes('NOT_RUNNING');

    // Check if FTP is running (port 21)
    const ftpCheck = await executeCommand('netstat -an | grep ":21 " | grep LISTEN || echo "NOT_RUNNING"');
    services.ftp = ftpCheck.success && !ftpCheck.output.includes('NOT_RUNNING');

    // Check if SSH is running (port 22)
    const sshCheck = await executeCommand('netstat -an | grep ":22 " | grep LISTEN || echo "NOT_RUNNING"');
    services.ssh = sshCheck.success && !sshCheck.output.includes('NOT_RUNNING');

    // Check if web server is running (port 80 or 8080)
    const webCheck = await executeCommand('netstat -an | grep -E ":(80|8080) " | grep LISTEN || echo "NOT_RUNNING"');
    services.webserver = webCheck.success && !webCheck.output.includes('NOT_RUNNING');
  } catch (error) {
    console.error('Error detecting services:', error);
  }

  return services;
}

/**
 * Get Toolbox installation recommendations
 */
export function getToolboxRecommendations(info: ToolboxInfo): string[] {
  const recommendations: string[] = [];

  if (!info.installed) {
    recommendations.push('MIB2 Toolbox no est√° instalado. Se recomienda instalarlo para acceso completo.');
    recommendations.push('Visita foros especializados para obtener la √∫ltima versi√≥n del Toolbox.');
  } else {
    if (!info.services?.telnet) {
      recommendations.push('Telnet no est√° activo. Habil√≠talo desde el Toolbox para usar esta app.');
    }
    if (!info.services?.ftp) {
      recommendations.push('FTP no est√° activo. Consid√©ralo para transferencia de archivos.');
    }
    if (info.version && info.version.includes('old')) {
      recommendations.push('Versi√≥n antigua del Toolbox detectada. Considera actualizar.');
    }
  }

  return recommendations;
}

/**
 * Format Toolbox info for display
 */
export function formatToolboxInfo(info: ToolboxInfo): string {
  if (!info.installed) {
    return 'MIB2 Toolbox: No instalado';
  }

  let output = `MIB2 Toolbox: Instalado\n`;
  
  if (info.version) {
    output += `Versi√≥n: ${info.version}\n`;
  }
  
  if (info.installPath) {
    output += `Ruta: ${info.installPath}\n`;
  }

  if (info.services) {
    output += `\nServicios:\n`;
    output += `  Telnet: ${info.services.telnet ? '‚úì Activo' : '‚úó Inactivo'}\n`;
    output += `  FTP: ${info.services.ftp ? '‚úì Activo' : '‚úó Inactivo'}\n`;
    output += `  SSH: ${info.services.ssh ? '‚úì Activo' : '‚úó Inactivo'}\n`;
    output += `  Web Server: ${info.services.webserver ? '‚úì Activo' : '‚úó Inactivo'}\n`;
  }

  return output;
}

================================================================================
FILE: lib/toolbox-installer.ts
================================================================================

/**
 * Asistente de Instalaci√≥n del MIB2 STD2 Toolbox
 * Basado en el documento t√©cnico MIB2Acceso.pdf
 */

export interface InstallationStep {
  step: number;
  title: string;
  description: string;
  command?: string;
  expectedOutput?: string;
  warnings?: string[];
  isOptional?: boolean;
}

/**
 * Pasos para instalaci√≥n del Toolbox v√≠a Telnet (D-Link)
 */
export const TOOLBOX_INSTALLATION_STEPS: InstallationStep[] = [
  {
    step: 1,
    title: "Conectar Adaptador USB-Ethernet",
    description: "Conectar el adaptador D-Link DUB-E100 al puerto USB de la unidad MIB2. Conectar el cable Ethernet desde el adaptador al dispositivo Android (v√≠a adaptador USB-C a Ethernet) o a un router WiFi.",
    warnings: [
      "Asegurarse de usar el adaptador D-Link DUB-E100 espec√≠ficamente",
      "El chipset ASIX AX88772 es reconocido nativamente por el firmware MIB2",
    ],
  },
  {
    step: 2,
    title: "Configurar Red",
    description: "La unidad MIB2 generalmente tiene una direcci√≥n IP est√°tica preasignada en la subred 192.168.1.x (frecuentemente 192.168.1.4 para el host). Configurar el dispositivo con una IP est√°tica en el mismo rango (ej. 192.168.1.10).",
    command: `# En el dispositivo Android/PC:
# Configurar IP est√°tica: 192.168.1.10
# M√°scara de subred: 255.255.255.0
# Gateway: 192.168.1.1`,
  },
  {
    step: 3,
    title: "Verificar Conectividad",
    description: "Verificar que se puede hacer ping a la unidad MIB2 antes de intentar conectar por Telnet.",
    command: "ping 192.168.1.4",
    expectedOutput: "64 bytes from 192.168.1.4: icmp_seq=1 ttl=64 time=1.23 ms",
  },
  {
    step: 4,
    title: "Conectar por Telnet",
    description: "El servicio Telnet (puerto 23) puede estar activo pero protegido o inactivo por defecto. En versiones de firmware antiguas o espec√≠ficas de Technisat ZR (Zentralrechner), este puerto puede estar abierto, permitiendo una conexi√≥n remota desde una laptop configurada con una IP est√°tica en el mismo rango.",
    command: "telnet 192.168.1.4 23",
    expectedOutput: `Connected to 192.168.1.4
QNX Neutrino (localhost) (pts/0)

login: `,
    warnings: [
      "Si el puerto Telnet est√° cerrado, no se puede activar mediante codificaci√≥n VCDS",
      "En ese caso, el √∫ltimo recurso es el acceso directo al almacenamiento no vol√°til (eMMC Direct Access) mediante soldadura",
    ],
  },
  {
    step: 5,
    title: "Iniciar Sesi√≥n como Root",
    description: "Una vez establecida la sesi√≥n Telnet, se obtiene acceso a la shell de comandos de QNX (ksh).",
    command: `login: root
password: root`,
    expectedOutput: "# ",
  },
  {
    step: 6,
    title: "Verificar Sistema de Archivos",
    description: "Desde aqu√≠, las restricciones de la interfaz gr√°fica (HMI) son irrelevantes. Se puede montar manualmente la tarjeta SD (que el sistema reconoce como un dispositivo de almacenamiento masivo en /media/mp000 o similar) y ejecutar scripts de shell (install.sh) directamente.",
    command: `# Verificar montaje de la tarjeta SD
ls -la /media/mp000

# Verificar sistema de archivos
df -h`,
    expectedOutput: `/dev/hd0t177  /media/mp000  vfat`,
  },
  {
    step: 7,
    title: "Descargar MIB2 Toolbox",
    description: "Descargar el MIB2 STD2 Toolbox desde el repositorio oficial de GitHub y copiarlo a una tarjeta SD.",
    command: `# En tu PC:
# Descargar desde: https://github.com/olli991/mib-std2-pq-zr-toolbox
# Copiar el archivo install.sh a la ra√≠z de la tarjeta SD`,
    warnings: [
      "Asegurarse de descargar la versi√≥n correcta para MIB2 STD2 (no MIB2 High)",
      "Verificar la integridad del archivo descargado",
    ],
  },
  {
    step: 8,
    title: "Ejecutar Script de Instalaci√≥n",
    description: 'Este m√©todo "inyecta" el instalador del MIB STD2 Toolbox sorteando la validaci√≥n de firmas digitales del gestor de actualizaciones SWDL, ya que estamos ejecutando el script de instalaci√≥n manualmente con privilegios de root, en lugar de pedirle al sistema que "actualice" el firmware.',
    command: `# Navegar a la tarjeta SD
cd /media/mp000

# Dar permisos de ejecuci√≥n
chmod +x install.sh

# Ejecutar instalaci√≥n
./install.sh`,
    expectedOutput: "MIB2 Toolbox installed successfully",
    warnings: [
      "Este m√©todo sortea la validaci√≥n de firmware digital del gestor de actualizaciones SWDL",
      "Estamos ejecutando el script manualmente con privilegios root",
    ],
  },
  {
    step: 9,
    title: "Aplicar Parcheo del Sistema",
    description: "Una vez instalado el Toolbox, ejecutar la funci√≥n de parcheo desde el men√∫ verde (GEM - Green Engineering Menu) accesible tras la instalaci√≥n.",
    command: `# Desde el men√∫ verde (GEM) del Toolbox:
# Seleccionar: "Patch tsd.mibstd2.system.swap"`,
    warnings: [
      "Este parcheo modifica el binario del sistema para alterar la rutina de verificaci√≥n de firmas",
      "Una vez parcheado, el sistema se instruye para consultar la ExceptionList.txt",
    ],
  },
  {
    step: 10,
    title: "Verificar Instalaci√≥n",
    description: "Verificar que el Toolbox se instal√≥ correctamente y est√° accesible desde el sistema.",
    command: `# Verificar archivos del Toolbox
ls -la /net/mmx/mnt/app/eso/hmi/lsd/jars/

# Buscar archivos relacionados con el Toolbox
find /net/mmx -name "*toolbox*" -o -name "*mib*"`,
    expectedOutput: "Archivos del Toolbox visibles en el directorio",
  },
  {
    step: 11,
    title: "Reiniciar Sistema",
    description: "Reiniciar la unidad MIB2 para que los cambios surtan efecto.",
    command: "reboot",
    warnings: [
      "Despu√©s del reinicio, el Toolbox deber√≠a estar accesible desde el men√∫ del sistema",
      "El men√∫ verde (GEM) estar√° disponible para funciones avanzadas",
    ],
  },
];

/**
 * M√©todo alternativo: Acceso directo eMMC (solo informativo)
 */
export const EMMC_ACCESS_INFO = {
  title: "M√©todo Alternativo: Acceso Directo eMMC (Avanzado)",
  description: "Si el puerto Telnet est√° cerrado y no se puede activar mediante codificaci√≥n VCDS, el √∫ltimo recurso es el acceso directo al almacenamiento no vol√°til.",
  steps: [
    "Extracci√≥n f√≠sica de la unidad MIB2 del veh√≠culo",
    "Desmontaje del chasis y soldadura de un lector SD modificado",
    "Acceso directo a los pines del chip eMMC (Embedded Multi-Media Controller)",
    "Modificaci√≥n del archivo shadow (contrase√±as) o inyecci√≥n directa de archivos parcheados",
    "Re-escritura de la imagen en el chip",
  ],
  warnings: [
    "‚ö†Ô∏è Este m√©todo es destructivo potencialmente y requiere habilidades avanzadas de microsoldadura",
    "‚ö†Ô∏è Ofrece control total sobre la unidad, permitiendo incluso revivir unidades 'briqueadas'",
    "‚ö†Ô∏è NO recomendado para usuarios sin experiencia en electr√≥nica",
    "‚ö†Ô∏è Puede anular la garant√≠a y da√±ar permanentemente la unidad",
  ],
  technicalNote: "Al volcar la imagen de la memoria eMMC en un PC (utilizando herramientas de bajo nivel en Linux), se puede modificar el archivo shadow (contrase√±as) o inyectar directamente los archivos parcheados, para luego volver a escribir la imagen en el chip. Este m√©todo es destructivo potencialmente y requiere habilidades avanzadas de microsoldadura, pero ofrece control total sobre la unidad, permitiendo incluso revivir unidades 'briqueadas'.",
};

/**
 * Comandos √∫tiles para diagn√≥stico del sistema
 */
export const DIAGNOSTIC_COMMANDS = [
  {
    name: "Informaci√≥n del Sistema",
    command: "uname -a",
    description: "Muestra informaci√≥n del sistema operativo QNX",
  },
  {
    name: "Versi√≥n del Firmware",
    command: "cat /net/mmx/fs/sda0/VERSION",
    description: "Muestra la versi√≥n del firmware instalado",
  },
  {
    name: "Procesos en Ejecuci√≥n",
    command: "ps aux",
    description: "Lista todos los procesos en ejecuci√≥n",
  },
  {
    name: "Espacio en Disco",
    command: "df -h",
    description: "Muestra el espacio disponible en los sistemas de archivos",
  },
  {
    name: "Dispositivos de Red",
    command: "ifconfig -a",
    description: "Muestra la configuraci√≥n de las interfaces de red",
  },
  {
    name: "Servicios Activos",
    command: "netstat -an | grep LISTEN",
    description: "Muestra los puertos en escucha (Telnet, FTP, SSH, etc.)",
  },
  {
    name: "Informaci√≥n de Hardware",
    command: "pidin info",
    description: "Muestra informaci√≥n detallada del hardware y procesos",
  },
];

/**
 * Generar script completo de instalaci√≥n
 */
export function generateInstallationScript(): string {
  return `#!/bin/sh
# Script de Instalaci√≥n del MIB2 STD2 Toolbox
# Generado por MIB2 Controller
# Fecha: ${new Date().toISOString()}

echo "=== Instalaci√≥n del MIB2 STD2 Toolbox ==="
echo ""

# Verificar que estamos en root
if [ "$(whoami)" != "root" ]; then
    echo "ERROR: Este script debe ejecutarse como root"
    exit 1
fi

# Verificar montaje de la tarjeta SD
echo "Verificando tarjeta SD..."
if [ ! -d "/media/mp000" ]; then
    echo "ERROR: Tarjeta SD no montada en /media/mp000"
    exit 1
fi

# Verificar que el archivo install.sh del Toolbox existe
if [ ! -f "/media/mp000/install.sh" ]; then
    echo "ERROR: No se encontr√≥ install.sh en la tarjeta SD"
    echo "Descargar el Toolbox desde: https://github.com/olli991/mib-std2-pq-zr-toolbox"
    exit 1
fi

# Ejecutar instalaci√≥n del Toolbox
echo "Ejecutando instalaci√≥n del Toolbox..."
cd /media/mp000
chmod +x install.sh
./install.sh

# Verificar instalaci√≥n
echo ""
echo "Verificando instalaci√≥n..."
if [ -d "/net/mmx/mnt/app/eso/hmi/lsd/jars/" ]; then
    echo "‚úì Toolbox instalado correctamente"
    echo ""
    echo "Pr√≥ximos pasos:"
    echo "1. Reiniciar la unidad MIB2"
    echo "2. Acceder al men√∫ verde (GEM) del Toolbox"
    echo "3. Ejecutar 'Patch tsd.mibstd2.system.swap'"
    echo "4. Crear ExceptionList.txt con los c√≥digos FEC deseados"
else
    echo "‚úó Error en la instalaci√≥n"
    exit 1
fi

echo ""
echo "=== Instalaci√≥n completada ==="
`;
}

/**
 * Validar que el Toolbox est√° instalado
 */
export function generateToolboxVerificationCommand(): string {
  return `# Verificar instalaci√≥n del MIB2 Toolbox
echo "Verificando instalaci√≥n del Toolbox..."

# Buscar archivos del Toolbox
if [ -d "/net/mmx/mnt/app/eso/hmi/lsd/jars/" ]; then
    echo "‚úì Directorio del Toolbox encontrado"
    ls -la /net/mmx/mnt/app/eso/hmi/lsd/jars/ | grep -i toolbox
else
    echo "‚úó Toolbox no instalado"
fi

# Verificar si el sistema est√° parcheado
if [ -f "/media/mp000/ExceptionList.txt" ]; then
    echo "‚úì ExceptionList.txt encontrada"
    cat /media/mp000/ExceptionList.txt
else
    echo "‚Ñπ ExceptionList.txt no encontrada (sistema no parcheado)"
fi
`;
}

================================================================================
FILE: lib/trpc.ts
================================================================================

import { createTRPCReact } from "@trpc/react-query";
import { httpBatchLink } from "@trpc/client";
import superjson from "superjson";
import type { AppRouter } from "@/server/routers";
import { getApiBaseUrl } from "@/constants/oauth";
import * as Auth from "@/lib/_core/auth";

/**
 * tRPC React client for type-safe API calls.
 *
 * IMPORTANT (tRPC v11): The `transformer` must be inside `httpBatchLink`,
 * NOT at the root createClient level. This ensures client and server
 * use the same serialization format (superjson).
 */
export const trpc = createTRPCReact<AppRouter>();

/**
 * Creates the tRPC client with proper configuration.
 * Call this once in your app's root layout.
 */
export function createTRPCClient() {
  return trpc.createClient({
    links: [
      httpBatchLink({
        url: `${getApiBaseUrl()}/api/trpc`,
        // tRPC v11: transformer MUST be inside httpBatchLink, not at root
        transformer: superjson,
        async headers() {
          const token = await Auth.getSessionToken();
          return token ? { Authorization: `Bearer ${token}` } : {};
        },
        // Custom fetch to include credentials for cookie-based auth
        fetch(url, options) {
          return fetch(url, {
            ...options,
            credentials: "include",
          });
        },
      }),
    ],
  });
}

================================================================================
FILE: lib/usb-logger.ts
================================================================================

/**
 * USB Logger Service - Sistema de logging centralizado para operaciones USB
 */

export type LogLevel = 'info' | 'warning' | 'error' | 'success';

export interface UsbLogEntry {
  id: string;
  timestamp: number;
  level: LogLevel;
  operation: string;
  message: string;
  details?: any;
}

type LogListener = (logs: UsbLogEntry[]) => void;

class UsbLogger {
  private logs: UsbLogEntry[] = [];
  private maxLogs = 500; // Mantener √∫ltimos 500 logs en memoria
  private listeners: Set<LogListener> = new Set();

  /**
   * Agregar log
   */
  log(level: LogLevel, operation: string, message: string, details?: any) {
    const entry: UsbLogEntry = {
      id: `log_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      timestamp: Date.now(),
      level,
      operation,
      message,
      details,
    };

    this.logs.push(entry);

    // Mantener solo los √∫ltimos maxLogs
    if (this.logs.length > this.maxLogs) {
      this.logs = this.logs.slice(-this.maxLogs);
    }

    // Notificar a listeners
    this.notifyListeners();

    // Tambi√©n log a console para debugging
    const prefix = `[UsbLogger][${operation}]`;
    switch (level) {
      case 'info':
        console.log(prefix, message, details || '');
        break;
      case 'warning':
        console.warn(prefix, message, details || '');
        break;
      case 'error':
        console.error(prefix, message, details || '');
        break;
      case 'success':
        console.log(`‚úÖ ${prefix}`, message, details || '');
        break;
    }
  }

  /**
   * M√©todos de conveniencia
   */
  info(operation: string, message: string, details?: any) {
    this.log('info', operation, message, details);
  }

  warning(operation: string, message: string, details?: any) {
    this.log('warning', operation, message, details);
  }

  error(operation: string, message: string, details?: any) {
    this.log('error', operation, message, details);
  }

  success(operation: string, message: string, details?: any) {
    this.log('success', operation, message, details);
  }

  /**
   * Obtener todos los logs
   */
  getLogs(): UsbLogEntry[] {
    return [...this.logs];
  }

  /**
   * Limpiar logs
   */
  clear() {
    this.logs = [];
    this.notifyListeners();
  }

  /**
   * Suscribirse a cambios en logs
   */
  subscribe(listener: LogListener) {
    this.listeners.add(listener);
    // Enviar logs actuales inmediatamente
    listener(this.getLogs());
    
    // Retornar funci√≥n para desuscribirse
    return () => {
      this.listeners.delete(listener);
    };
  }

  /**
   * Notificar a todos los listeners
   */
  private notifyListeners() {
    const currentLogs = this.getLogs();
    this.listeners.forEach(listener => listener(currentLogs));
  }

  /**
   * Exportar logs como texto
   */
  exportAsText(): string {
    return this.logs.map(log => {
      const date = new Date(log.timestamp).toLocaleString('es-ES');
      const details = log.details ? `\n  Details: ${JSON.stringify(log.details, null, 2)}` : '';
      return `[${date}] [${log.level.toUpperCase()}] [${log.operation}] ${log.message}${details}`;
    }).join('\n\n');
  }
}

// Singleton instance
export const usbLogger = new UsbLogger();

================================================================================
FILE: lib/usb-service.ts
================================================================================

import { Platform } from 'react-native';
import UsbNativeModule, { type UsbDevice as NativeUsbDevice, type EEPROMReadResult, type EEPROMDumpResult, type SpoofResult } from '../modules/usb-native';
import { usbLogger } from './usb-logger';

export type UsbDevice = NativeUsbDevice;
export { type EEPROMReadResult, type EEPROMDumpResult, type SpoofResult };

// Magic value for EEPROM write authorization (as specified in Gu√≠aspoofing.pdf)
export const MAGIC_VALUE = 0xDEADBEEF;

// EEPROM offsets for VID/PID (as specified in Gu√≠aspoofing.pdf)
export const EEPROM_VID_OFFSET = 0x88;
export const EEPROM_PID_OFFSET = 0x8A;

// Target VID/PID for D-Link DUB-E100 (MIB2 compatible)
export const TARGET_VID = 0x2001;
export const TARGET_PID = 0x3C05;

/**
 * USB Service - Detecci√≥n y gesti√≥n de dispositivos USB con funciones EEPROM
 */
class UsbService {
  private devices: UsbDevice[] = [];
  private listeners: Set<(devices: UsbDevice[]) => void> = new Set();
  private scanInterval: ReturnType<typeof setInterval> | null = null;
  private currentDeviceId: number | null = null;

  /**
   * Inicializar el servicio USB
   */
  async initialize(): Promise<boolean> {
    if (Platform.OS !== 'android') {
      console.warn('[UsbService] USB service only available on Android');
      return false;
    }

    console.log('[UsbService] Initialized with native module');
    this.startMonitoring();
    return true;
  }

  /**
   * Escanear dispositivos USB conectados
   */
  async scanDevices(): Promise<UsbDevice[]> {
    if (Platform.OS !== 'android') {
      return [];
    }

    try {
      usbLogger.info('scan', 'Escaneando dispositivos USB...');
      this.devices = UsbNativeModule.getDeviceList();
      usbLogger.success('scan', `Encontrados ${this.devices.length} dispositivos USB`, 
        this.devices.map(d => `${d.deviceName} (${d.vendorId.toString(16)}:${d.productId.toString(16)})`)  
      );
      
      this.notifyListeners();
      return this.devices;
    } catch (error: any) {
      usbLogger.error('scan', 'Error al escanear dispositivos', error.message);
      return [];
    }
  }

  /**
   * Solicitar permisos para dispositivo USB
   */
  async requestPermission(deviceId: number): Promise<boolean> {
    if (Platform.OS !== 'android') {
      return false;
    }

    try {
      usbLogger.info('permission', `Solicitando permisos para dispositivo ${deviceId}...`);
      const granted = await UsbNativeModule.requestPermission(deviceId);
      if (granted) {
        usbLogger.success('permission', `Permisos concedidos para dispositivo ${deviceId}`);
      } else {
        usbLogger.warning('permission', `Permisos denegados para dispositivo ${deviceId}`);
      }
      return granted;
    } catch (error: any) {
      usbLogger.error('permission', 'Error al solicitar permisos', error.message);
      return false;
    }
  }

  /**
   * Abrir conexi√≥n a dispositivo USB
   */
  async openDevice(deviceId: number): Promise<boolean> {
    if (Platform.OS !== 'android') {
      return false;
    }

    try {
      usbLogger.info('connect', `Abriendo conexi√≥n a dispositivo ${deviceId}...`);
      const opened = await UsbNativeModule.openDevice(deviceId);
      if (opened) {
        this.currentDeviceId = deviceId;
        usbLogger.success('connect', `Dispositivo ${deviceId} conectado exitosamente`);
      } else {
        usbLogger.error('connect', `No se pudo abrir dispositivo ${deviceId}`);
      }
      return opened;
    } catch (error: any) {
      usbLogger.error('connect', 'Error al abrir dispositivo', error.message);
      return false;
    }
  }

  /**
   * Cerrar conexi√≥n a dispositivo USB
   */
  closeDevice(): boolean {
    if (Platform.OS !== 'android') {
      return false;
    }

    try {
      usbLogger.info('disconnect', 'Cerrando dispositivo USB...');
      const closed = UsbNativeModule.closeDevice();
      if (closed) {
        this.currentDeviceId = null;
        usbLogger.success('disconnect', 'Dispositivo desconectado exitosamente');
      } else {
        usbLogger.warning('disconnect', 'No se pudo cerrar el dispositivo');
      }
      return closed;
    } catch (error: any) {
      usbLogger.error('disconnect', 'Error al cerrar dispositivo', error.message);
      return false;
    }
  }

  /**
   * Leer datos de EEPROM en offset espec√≠fico
   */
  async readEEPROM(offset: number, length: number): Promise<EEPROMReadResult> {
    if (Platform.OS !== 'android') {
      throw new Error('USB operations only available on Android');
    }

    if (this.currentDeviceId === null) {
      throw new Error('No device connected');
    }

    try {
      usbLogger.info('read', `Leyendo ${length} bytes desde EEPROM offset 0x${offset.toString(16)}...`);
      const result = await UsbNativeModule.readEEPROM(offset, length);
      usbLogger.success('read', `Lectura exitosa: ${length} bytes`, `Data: ${result.data.substring(0, 32)}${result.data.length > 32 ? '...' : ''}`);
      return result;
    } catch (error: any) {
      usbLogger.error('read', 'Error al leer EEPROM', error.message);
      throw error;
    }
  }

  /**
   * Escribir datos a EEPROM en offset espec√≠fico
   */
  async writeEEPROM(offset: number, dataHex: string, skipVerification: boolean = false): Promise<{ bytesWritten: number; verified: boolean }> {
    if (Platform.OS !== 'android') {
      throw new Error('USB operations only available on Android');
    }

    if (this.currentDeviceId === null) {
      throw new Error('No device connected');
    }

    try {
      const mode = skipVerification ? '(SIN VERIFICACI√ìN)' : '(con verificaci√≥n)';
      usbLogger.info('write', `Escribiendo en EEPROM offset 0x${offset.toString(16)} ${mode}...`, `Data: ${dataHex}`);
      const result = await UsbNativeModule.writeEEPROM(offset, dataHex, MAGIC_VALUE, skipVerification);
      
      if (skipVerification) {
        usbLogger.warning('write', `Escritura completada: ${result.bytesWritten} bytes (verificaci√≥n omitida)`);
      } else {
        usbLogger.success('write', `Escritura y verificaci√≥n exitosa: ${result.bytesWritten} bytes`);
      }
      
      return result;
    } catch (error: any) {
      usbLogger.error('write', 'Error al escribir EEPROM', error.message);
      throw error;
    }
  }

  /**
   * Volcar contenido completo de EEPROM (256 bytes)
   */
  async dumpEEPROM(): Promise<EEPROMDumpResult> {
    if (Platform.OS !== 'android') {
      throw new Error('USB operations only available on Android');
    }

    if (this.currentDeviceId === null) {
      throw new Error('No device connected');
    }

    try {
      usbLogger.info('dump', 'Volcando EEPROM completa (256 bytes)...');
      const result = await UsbNativeModule.dumpEEPROM();
      usbLogger.success('dump', `Volcado exitoso: ${result.size} bytes`);
      return result;
    } catch (error: any) {
      usbLogger.error('dump', 'Error al volcar EEPROM', error.message);
      throw error;
    }
  }

  /**
   * Spoof VID/PID para hacer adaptador compatible con MIB2
   */
  async spoofVIDPID(targetVID: number = TARGET_VID, targetPID: number = TARGET_PID): Promise<SpoofResult> {
    if (Platform.OS !== 'android') {
      throw new Error('USB operations only available on Android');
    }

    if (this.currentDeviceId === null) {
      throw new Error('No device connected');
    }

    try {
      console.log(`[UsbService] Spoofing VID/PID to ${this.formatVIDPID(targetVID, targetPID)}`);
      const result = await UsbNativeModule.spoofVIDPID(targetVID, targetPID, MAGIC_VALUE);
      console.log(`[UsbService] Spoof ${result.success ? 'successful' : 'failed'}`);
      return result;
    } catch (error) {
      console.error('[UsbService] Error spoofing VID/PID:', error);
      throw error;
    }
  }

  /**
   * Crear backup autom√°tico de EEPROM
   */
  async createEEPROMBackup(): Promise<{ data: string; timestamp: number }> {
    const dump = await this.dumpEEPROM();
    const timestamp = Date.now();
    
    const backup = {
      data: dump.data,
      timestamp,
    };
    
    console.log('[UsbService] EEPROM backup created:', new Date(timestamp).toISOString());
    return backup;
  }

  /**
   * Obtener lista de dispositivos en cach√©
   */
  getDevices(): UsbDevice[] {
    return [...this.devices];
  }

  /**
   * Suscribirse a cambios de dispositivos
   */
  subscribe(listener: (devices: UsbDevice[]) => void): () => void {
    this.listeners.add(listener);
    listener([...this.devices]);
    return () => {
      this.listeners.delete(listener);
    };
  }

  /**
   * Notificar a todos los listeners
   */
  private notifyListeners(): void {
    this.listeners.forEach(listener => {
      listener([...this.devices]);
    });
  }

  /**
   * Iniciar monitoreo de cambios USB
   */
  private startMonitoring(): void {
    this.scanInterval = setInterval(() => {
      this.scanDevices().catch((error) => {
        console.error('[UsbService] Error in USB monitoring:', error);
      });
    }, 10000); // Optimizado: 10s en lugar de 5s para reducir consumo de bater√≠a
  }

  /**
   * Detener monitoreo
   */
  stopMonitoring(): void {
    if (this.scanInterval) {
      clearInterval(this.scanInterval);
      this.scanInterval = null;
    }
  }

  /**
   * Limpiar recursos
   */
  destroy(): void {
    this.closeDevice();
    this.stopMonitoring();
    this.listeners.clear();
    this.devices = [];
  }

  /**
   * Helper: Formatear VID/PID para display
   */
  formatVIDPID(vid: number, pid: number): string {
    return `${vid.toString(16).toUpperCase().padStart(4, '0')}:${pid.toString(16).toUpperCase().padStart(4, '0')}`;
  }

  /**
   * Helper: Identificar si dispositivo es adaptador ASIX
   */
  isASIXAdapter(device: UsbDevice): boolean {
    return device.vendorId === 0x0B95;
  }

  /**
   * Helper: Identificar si dispositivo ya est√° spoofed a D-Link
   */
  isDLinkAdapter(device: UsbDevice): boolean {
    return device.vendorId === 0x2001 && device.productId === 0x3C05;
  }

  /**
   * Helper: Verificar si dispositivo es compatible para spoofing
   */
  isCompatibleForSpoofing(device: UsbDevice): boolean {
    return this.isASIXAdapter(device) || this.isDLinkAdapter(device);
  }

  /**
   * Detectar tipo de EEPROM (externa vs eFuse) mediante prueba REAL de escritura
   * 
   * Realiza:
   * 1. Lectura REAL de EEPROM en offset seguro
   * 2. Escritura de prueba REAL en offset seguro (no modifica VID/PID)
   * 3. Verificaci√≥n REAL de escritura
   * 4. Restauraci√≥n del valor original
   * 
   * @returns Tipo de EEPROM y si es modificable
   */
  async detectEEPROMType(): Promise<{ type: 'external_eeprom' | 'efuse' | 'unknown'; writable: boolean; reason: string }> {
    if (Platform.OS !== 'android') {
      throw new Error('EEPROM detection only available on Android');
    }

    try {
      usbLogger.log('info', 'detectEEPROMType', 'üîç Iniciando detecci√≥n REAL de tipo de EEPROM...');
      
      const result = await UsbNativeModule.detectEEPROMType();
      
      usbLogger.log('success', 'detectEEPROMType', `‚úÖ Detecci√≥n completada: ${result.type} (writable: ${result.writable})`);
      usbLogger.log('info', 'detectEEPROMType', `üìù Raz√≥n: ${result.reason}`);
      
      return result;
    } catch (error) {
      usbLogger.log('error', 'detectEEPROMType', `‚ùå Error en detecci√≥n de EEPROM: ${error}`);
      throw error;
    }
  }
}

// Exportar instancia singleton
export const usbService = new UsbService();
export default usbService;

================================================================================
FILE: lib/usb-status-context.tsx
================================================================================

import { createContext, useContext, useState, useCallback, useEffect } from 'react';
import { AppState, AppStateStatus } from 'react-native';
import { usbService, UsbDevice } from './usb-service';
import { profilesService, VIDPIDProfile } from './profiles-service';

export type UsbStatus = 'disconnected' | 'detected' | 'connected';

interface UsbStatusContextType {
  status: UsbStatus;
  device: UsbDevice | null;
  devices: UsbDevice[];
  isScanning: boolean;
  detectedProfile: VIDPIDProfile | null;
  recommendedProfile: VIDPIDProfile | null;
  scanDevices: () => Promise<void>;
  connectToDevice: (device: UsbDevice) => Promise<boolean>;
  disconnectDevice: () => Promise<void>;
}

const UsbStatusContext = createContext<UsbStatusContextType | undefined>(undefined);

export function UsbStatusProvider({ children }: { children: React.ReactNode }) {
  const [status, setStatus] = useState<UsbStatus>('disconnected');
  const [device, setDevice] = useState<UsbDevice | null>(null);
  const [devices, setDevices] = useState<UsbDevice[]>([]);
  const [isScanning, setIsScanning] = useState(false);
  const [detectedProfile, setDetectedProfile] = useState<VIDPIDProfile | null>(null);
  const [recommendedProfile, setRecommendedProfile] = useState<VIDPIDProfile | null>(null);

  // Escanear dispositivos USB
  const scanDevices = useCallback(async () => {
    if (isScanning) return;
    
    setIsScanning(true);
    
    try {
      await usbService.initialize();
      const foundDevices = await usbService.scanDevices();
      setDevices(foundDevices);
      
      if (foundDevices.length > 0) {
        // Si hay dispositivos pero no estamos conectados, marcar como "detected"
        if (status === 'disconnected') {
          setStatus('detected');
        }
      } else {
        // No hay dispositivos
        if (status !== 'disconnected') {
          setStatus('disconnected');
          setDevice(null);
        }
      }
    } catch (error) {
      console.error('[UsbStatusProvider] Error scanning devices:', error);
      setStatus('disconnected');
      setDevice(null);
      setDevices([]);
    } finally {
      setIsScanning(false);
    }
  }, [isScanning, status]);

  // Conectar a un dispositivo espec√≠fico
  const connectToDevice = useCallback(async (targetDevice: UsbDevice): Promise<boolean> => {
    try {
      // Solicitar permisos y abrir dispositivo
      const granted = await usbService.requestPermission(targetDevice.deviceId);
      if (!granted) {
        return false;
      }
      
      const opened = await usbService.openDevice(targetDevice.deviceId);
      if (!opened) {
        return false;
      }

      // Detectar perfil del dispositivo
      const profile = await profilesService.findProfileByVIDPID(
        targetDevice.vendorId,
        targetDevice.productId
      );
      setDetectedProfile(profile);
      
      // Sugerir perfil MIB2 compatible si el dispositivo no lo es
      if (profile && !profile.compatible) {
        const recommended = profilesService.getMIB2CompatibleProfiles()[0]; // D-Link DUB-E100
        setRecommendedProfile(recommended);
        console.log(`[UsbStatusProvider] Device not MIB2 compatible. Recommending: ${recommended.name}`);
      } else {
        setRecommendedProfile(null);
      }
      
      // Marcar como conectado
      setDevice(targetDevice);
      setStatus('connected');
      return true;
    } catch (error) {
      console.error('[UsbStatusProvider] Connection error:', error);
      return false;
    }
  }, []);

  // Desconectar dispositivo actual
  const disconnectDevice = useCallback(async () => {
    if (!device) return;
    
    try {
      setDevice(null);
      setDetectedProfile(null);
      setRecommendedProfile(null);
      setStatus(devices.length > 0 ? 'detected' : 'disconnected');
    } catch (error) {
      console.error('[UsbStatusProvider] Disconnection error:', error);
    }
  }, [device, devices.length]);

  // Escaneo autom√°tico al montar y cuando la app vuelve al foreground
  useEffect(() => {
    // Escaneo inicial
    scanDevices();

    // Listener de cambios de estado de la app
    const subscription = AppState.addEventListener('change', (nextAppState: AppStateStatus) => {
      if (nextAppState === 'active') {
        // App volvi√≥ al foreground, escanear nuevamente
        scanDevices();
      }
    });

    return () => {
      subscription.remove();
    };
  }, [scanDevices]);

  // Escaneo peri√≥dico cada 5 segundos
  useEffect(() => {
    const interval = setInterval(() => {
      scanDevices();
    }, 5000);

    return () => clearInterval(interval);
  }, [scanDevices]);

  const value: UsbStatusContextType = {
    status,
    device,
    devices,
    isScanning,
    detectedProfile,
    recommendedProfile,
    scanDevices,
    connectToDevice,
    disconnectDevice,
  };

  return (
    <UsbStatusContext.Provider value={value}>
      {children}
    </UsbStatusContext.Provider>
  );
}

export function useUsbStatus(): UsbStatusContextType {
  const context = useContext(UsbStatusContext);
  if (!context) {
    throw new Error('useUsbStatus must be used within UsbStatusProvider');
  }
  return context;
}

================================================================================
FILE: lib/utils.ts
================================================================================

import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

/**
 * Combines class names using clsx and tailwind-merge.
 * This ensures Tailwind classes are properly merged without conflicts.
 *
 * Usage:
 * ```tsx
 * cn("px-4 py-2", isActive && "bg-primary", className)
 * ```
 */
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
