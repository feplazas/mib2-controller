/**
 * Generador de Códigos FEC (Feature Enable Codes)
 * Para activación de funciones SWaP en unidades MIB2
 * 
 * Basado en el documento técnico MIB2Acceso.pdf
 */

export interface FECCode {
  code: string;
  name: string;
  description: string;
  category: 'connectivity' | 'performance' | 'multimedia';
}

/**
 * Códigos FEC predefinidos para funciones comunes
 */
export const PREDEFINED_FEC_CODES: FECCode[] = [
  {
    code: '00010001',
    name: 'Apple CarPlay',
    description: 'Habilita integración de Apple CarPlay en el sistema de infotainment',
    category: 'connectivity',
  },
  {
    code: '00010002',
    name: 'Android Auto',
    description: 'Habilita integración de Android Auto en el sistema de infotainment',
    category: 'connectivity',
  },
  {
    code: '00010004',
    name: 'MirrorLink',
    description: 'Habilita MirrorLink para dispositivos compatibles',
    category: 'connectivity',
  },
  {
    code: '00010008',
    name: 'App-Connect (Full-Link)',
    description: 'Habilita todas las funciones de App-Connect',
    category: 'connectivity',
  },
  {
    code: '00060001',
    name: 'Performance Monitor',
    description: 'Habilita el monitor de rendimiento en el cuadro digital',
    category: 'performance',
  },
  {
    code: '09400008',
    name: 'Mapas Europa',
    description: 'Activa región de mapas Europa (EU)',
    category: 'multimedia',
  },
  {
    code: '09410008',
    name: 'Mapas Norteamérica',
    description: 'Activa región de mapas Norteamérica (NAR)',
    category: 'multimedia',
  },
];

/**
 * URL del generador FEC online
 */
export const FEC_GENERATOR_URL = 'https://vwcoding.ru/en/utils/fec/';

/**
 * Generar comandos Telnet para inyectar códigos FEC
 */
export function generateFecInjectionCommands(codes: string[]): string[] {
  return [
    '# Montar sistema de archivos',
    'mount -uw /net/rcc/dev/shmem',
    '',
    '# Inyectar códigos FEC',
    ...codes.map((code) => `echo "${code}" >> /net/rcc/dev/shmem/addfec.txt`),
    '',
    '# Reiniciar unidad para aplicar cambios',
    'reboot',
  ];
}

/**
 * Interfaz para datos del vehículo
 */
export interface VehicleData {
  vin: string;  // Vehicle Identification Number
  vcrn: string; // Vehicle Component Registration Number
}

/**
 * Validar formato de VIN (17 caracteres alfanuméricos)
 */
export function validateVIN(vin: string): boolean {
  const vinRegex = /^[A-HJ-NPR-Z0-9]{17}$/;
  return vinRegex.test(vin.toUpperCase());
}

/**
 * Validar formato de VCRN
 */
export function validateVCRN(vcrn: string): boolean {
  // VCRN típicamente es un número de serie de la unidad
  return vcrn.length >= 8 && vcrn.length <= 20;
}

/**
 * Generar código FEC basado en VIN y VCRN
 * 
 * NOTA: Este es un algoritmo simplificado para demostración.
 * El algoritmo real de VW es propietario y más complejo.
 * Para uso en producción, se requiere acceso a la base de datos oficial de VW
 * o uso de herramientas como OBDeleven que tienen acceso a los algoritmos reales.
 */
export function generateFECCode(vehicleData: VehicleData, featureCode: string): string {
  const { vin, vcrn } = vehicleData;
  
  // Validar inputs
  if (!validateVIN(vin)) {
    throw new Error('VIN inválido. Debe tener 17 caracteres alfanuméricos.');
  }
  
  if (!validateVCRN(vcrn)) {
    throw new Error('VCRN inválido. Debe tener entre 8 y 20 caracteres.');
  }
  
  // Algoritmo simplificado (placeholder)
  // En la realidad, esto requiere la clave privada de VW
  const vinHash = simpleHash(vin);
  const vcrnHash = simpleHash(vcrn);
  const featureHash = simpleHash(featureCode);
  
  const combinedHash = (vinHash + vcrnHash + featureHash) % 0xFFFFFFFF;
  const fecCode = combinedHash.toString(16).toUpperCase().padStart(8, '0');
  
  return fecCode;
}

/**
 * Función hash simple para demostración
 * (NO usar en producción - solo para propósitos educativos)
 */
function simpleHash(str: string): number {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  return Math.abs(hash);
}

/**
 * Generar contenido del archivo ExceptionList.txt
 */
export function generateExceptionList(fecCodes: string[]): string {
  const header = `# ExceptionList.txt
# Generated by MIB2 Controller
# Date: ${new Date().toISOString()}
# 
# Este archivo contiene códigos FEC que serán aceptados por el sistema
# independientemente de la validación criptográfica.
# 
# IMPORTANTE: Este método "parchea" el sistema para aceptar códigos sin
# verificación de firma digital de VW AG.
#
# Instrucciones:
# 1. Copiar este archivo a la tarjeta SD de la unidad MIB2
# 2. Ejecutar el MIB2 Toolbox para aplicar el parcheo
# 3. Los códigos listados serán aceptados como válidos
#
# Códigos FEC:
`;

  const codes = fecCodes.map(code => `${code}`).join('\n');
  
  return header + codes + '\n';
}

/**
 * Obtener código FEC predefinido por nombre
 */
export function getPredefinedFECCode(name: string): FECCode | undefined {
  return PREDEFINED_FEC_CODES.find(
    code => code.name.toLowerCase() === name.toLowerCase()
  );
}

/**
 * Obtener todos los códigos FEC por categoría
 */
export function getFECCodesByCategory(category: FECCode['category']): FECCode[] {
  return PREDEFINED_FEC_CODES.filter(code => code.category === category);
}

/**
 * Validar formato de código FEC (8 dígitos hexadecimales)
 */
export function validateFECCode(code: string): boolean {
  const fecRegex = /^[0-9A-F]{8}$/i;
  return fecRegex.test(code);
}

/**
 * Información sobre el proceso de inyección de códigos FEC
 */
export const FEC_INJECTION_INFO = {
  titleKey: 'fec.injection_title',
  steps: [
    {
      step: 1,
      titleKey: 'fec.step1_title',
      descriptionKey: 'fec.step1_desc',
    },
    {
      step: 2,
      titleKey: 'fec.step2_title',
      descriptionKey: 'fec.step2_desc',
    },
    {
      step: 3,
      titleKey: 'fec.step3_title',
      descriptionKey: 'fec.step3_desc',
    },
    {
      step: 4,
      titleKey: 'fec.step4_title',
      descriptionKey: 'fec.step4_desc',
    },
    {
      step: 5,
      titleKey: 'fec.step5_title',
      descriptionKey: 'fec.step5_desc',
    },
  ],
  warningKeys: [
    'fec.warning1',
    'fec.warning2',
    'fec.warning3',
    'fec.warning4',
  ],
  technicalNoteKey: 'fec.technical_note',
};

/**
 * Generar comando para inyección vía Toolbox
 */
export function generateToolboxInjectionCommand(fecCodes: string[]): string {
  return `# Comandos para inyección de códigos FEC vía MIB2 Toolbox
# Ejecutar desde Telnet (root@192.168.1.4)

# 1. Verificar que el Toolbox esté instalado
ls -la /net/mmx/mnt/app/eso/hmi/lsd/jars/

# 2. Crear ExceptionList.txt en la tarjeta SD
cat > /media/mp000/ExceptionList.txt << EOF
${fecCodes.join('\n')}
EOF

# 3. Aplicar parcheo (desde el menú verde GEM del Toolbox)
# Seleccionar: "Patch tsd.mibstd2.system.swap"

# 4. Verificar códigos inyectados
# Los códigos FEC ahora serán aceptados como válidos

echo "FEC codes injected successfully"
`;
}
